#!/usr/bin/env node

"use strict";

exports.command = {
    description: 'interpolate a comma-separated list of masters according to a CPS expression'
  , arguments: '<masters>'
};

var path = require('path');
var requirejs = require('requirejs');
require('rootpath')();
requirejs.config(require('config'));

if (require.main === module) {
    requirejs([
        'commander'
      , 'metapolator/errors'
      , 'ufojs/tools/io/staticNodeJS'
      , 'metapolator/project/MetapolatorProject'
      , 'metapolator/models/CPS/parsing/parseRules'
      , 'metapolator/models/CPS/Registry'
      , 'metapolator/models/Controller'
      , 'fs'
    ], function (
        program
      , errors
      , io
      , MetapolatorProject
      , parseRules
      , Registry
      , Controller
      , fs
    ) {
        var CommandLineError = errors.CommandLine;

	var collect = function(val, col) {
	    col.push(val);
	    return col;
	}

        program._name = path.basename(process.argv[1], '.js').replace('-', ' ');
        program.arguments(exports.command.arguments);
	program.option('-c, --cps [CPS]', 'CPS to apply', collect, [])
	program.option('-s, --selectors  [Sel]',   'CPS selector for the nodes to inspect', collect, [])
        program.action(function(masters) {
            if (program.args.length > program._args.length + 1)
                program.help();
	    if( !program.cps.length )
                program.help();

            var names = masters.split(',');
            console.log(names);
            // FIXME: very simple input validation, we'll need more I think
            // FIXME: factor out this validation (see import.js)
            for(var i = 0; i < names.length; i++) {
                if(names[i].indexOf('/') !== -1 || names[i].indexOf('\\') !== -1)
                    throw new CommandLineError('/ and \\ are not allowed in a '
                                              + 'Master name: ' + names[i]);
            }

            var parameterRegistry = new Registry();

            // FIXME: a ParameterDescription class/interface definition could
            // be the point here. So we can ensure a consistent api and
            // pinpoint programming errors
            parameterRegistry.register('value', {
                        type: 'string'
                      , description: 'this is a stub for the parameter description!'
            });

            parameterRegistry.register('height', {
                        type: 'compoundReal'
                      , description: 'the relative value of height'
            });

            parameterRegistry.register('heightIntrinsic', {
                        type: 'real'
                      , description: 'the intrinsic value of the height'
            });

            parameterRegistry.register('width', {
                        type: 'compoundReal'
                      , description: 'the relative value of width'
            });

            parameterRegistry.register('widthIntrinsic', {
                        type: 'real'
                      , description: 'the intrinsic value of the width'
            });

            parameterRegistry.register('zon', {
                        type: 'compoundVector'
                      , description: 'The center on curve point of a skeleton point'
            })
            parameterRegistry.register('zonIntrinsic', {
                        type: 'vector'
                      , description: 'the intrinsic value of the zon'
            })
            parameterRegistry.register('label', {
                type: 'string'
                , description: 'something new'
            })
            parameterRegistry.register('xx', {
                type: 'real'
                , description: 'and a number for mathses my precious'
            });

	    fs.readFile( program.cps[0], 'utf8', function (err,theCPSString) {
		var rules = parseRules.fromString( theCPSString, 'InterpolatorArgument', parameterRegistry );

		var project = new MetapolatorProject(io);
		project.load();
		for(i = 0; i < names.length; i++)
                    project.open(names[i]);

		console.log('interpolators:', rules);

		// OK, I'm not quite sure what this method needs to do //
		project.interpolate( rules );
		console.log('project:', project );

		var controller = new Controller(parameterRegistry);

	    });
        });
        program.parse(process.argv);
        if (process.argv.length < program._args.length + 2)
            program.help();
    }
)}
