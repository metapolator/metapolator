/** vim: et:ts=4:sw=4:sts=4
 * @license RequireJS 2.1.14 Copyright (c) 2010-2014, The Dojo Foundation All Rights Reserved.
 * Available via the MIT or new BSD license.
 * see: http://github.com/jrburke/requirejs for details
 */
//Not using strict: uneven strict support in browsers, #392, and causes
//problems with requirejs.exec()/transpiler plugins that may not be strict.
/*jslint regexp: true, nomen: true, sloppy: true */
/*global window, navigator, document, importScripts, setTimeout, opera */

var requirejs, require, define;
(function (global) {
    var req, s, head, baseElement, dataMain, src,
        interactiveScript, currentlyAddingScript, mainScript, subPath,
        version = '2.1.14',
        commentRegExp = /(\/\*([\s\S]*?)\*\/|([^:]|^)\/\/(.*)$)/mg,
        cjsRequireRegExp = /[^.]\s*require\s*\(\s*["']([^'"\s]+)["']\s*\)/g,
        jsSuffixRegExp = /\.js$/,
        currDirRegExp = /^\.\//,
        op = Object.prototype,
        ostring = op.toString,
        hasOwn = op.hasOwnProperty,
        ap = Array.prototype,
        apsp = ap.splice,
        isBrowser = !!(typeof window !== 'undefined' && typeof navigator !== 'undefined' && window.document),
        isWebWorker = !isBrowser && typeof importScripts !== 'undefined',
        //PS3 indicates loaded and complete, but need to wait for complete
        //specifically. Sequence is 'loading', 'loaded', execution,
        // then 'complete'. The UA check is unfortunate, but not sure how
        //to feature test w/o causing perf issues.
        readyRegExp = isBrowser && navigator.platform === 'PLAYSTATION 3' ?
                      /^complete$/ : /^(complete|loaded)$/,
        defContextName = '_',
        //Oh the tragedy, detecting opera. See the usage of isOpera for reason.
        isOpera = typeof opera !== 'undefined' && opera.toString() === '[object Opera]',
        contexts = {},
        cfg = {},
        globalDefQueue = [],
        useInteractive = false;

    function isFunction(it) {
        return ostring.call(it) === '[object Function]';
    }

    function isArray(it) {
        return ostring.call(it) === '[object Array]';
    }

    /**
     * Helper function for iterating over an array. If the func returns
     * a true value, it will break out of the loop.
     */
    function each(ary, func) {
        if (ary) {
            var i;
            for (i = 0; i < ary.length; i += 1) {
                if (ary[i] && func(ary[i], i, ary)) {
                    break;
                }
            }
        }
    }

    /**
     * Helper function for iterating over an array backwards. If the func
     * returns a true value, it will break out of the loop.
     */
    function eachReverse(ary, func) {
        if (ary) {
            var i;
            for (i = ary.length - 1; i > -1; i -= 1) {
                if (ary[i] && func(ary[i], i, ary)) {
                    break;
                }
            }
        }
    }

    function hasProp(obj, prop) {
        return hasOwn.call(obj, prop);
    }

    function getOwn(obj, prop) {
        return hasProp(obj, prop) && obj[prop];
    }

    /**
     * Cycles over properties in an object and calls a function for each
     * property value. If the function returns a truthy value, then the
     * iteration is stopped.
     */
    function eachProp(obj, func) {
        var prop;
        for (prop in obj) {
            if (hasProp(obj, prop)) {
                if (func(obj[prop], prop)) {
                    break;
                }
            }
        }
    }

    /**
     * Simple function to mix in properties from source into target,
     * but only if target does not already have a property of the same name.
     */
    function mixin(target, source, force, deepStringMixin) {
        if (source) {
            eachProp(source, function (value, prop) {
                if (force || !hasProp(target, prop)) {
                    if (deepStringMixin && typeof value === 'object' && value &&
                        !isArray(value) && !isFunction(value) &&
                        !(value instanceof RegExp)) {

                        if (!target[prop]) {
                            target[prop] = {};
                        }
                        mixin(target[prop], value, force, deepStringMixin);
                    } else {
                        target[prop] = value;
                    }
                }
            });
        }
        return target;
    }

    //Similar to Function.prototype.bind, but the 'this' object is specified
    //first, since it is easier to read/figure out what 'this' will be.
    function bind(obj, fn) {
        return function () {
            return fn.apply(obj, arguments);
        };
    }

    function scripts() {
        return document.getElementsByTagName('script');
    }

    function defaultOnError(err) {
        throw err;
    }

    //Allow getting a global that is expressed in
    //dot notation, like 'a.b.c'.
    function getGlobal(value) {
        if (!value) {
            return value;
        }
        var g = global;
        each(value.split('.'), function (part) {
            g = g[part];
        });
        return g;
    }

    /**
     * Constructs an error with a pointer to an URL with more information.
     * @param {String} id the error ID that maps to an ID on a web page.
     * @param {String} message human readable error.
     * @param {Error} [err] the original error, if there is one.
     *
     * @returns {Error}
     */
    function makeError(id, msg, err, requireModules) {
        var e = new Error(msg + '\nhttp://requirejs.org/docs/errors.html#' + id);
        e.requireType = id;
        e.requireModules = requireModules;
        if (err) {
            e.originalError = err;
        }
        return e;
    }

    if (typeof define !== 'undefined') {
        //If a define is already in play via another AMD loader,
        //do not overwrite.
        return;
    }

    if (typeof requirejs !== 'undefined') {
        if (isFunction(requirejs)) {
            //Do not overwrite an existing requirejs instance.
            return;
        }
        cfg = requirejs;
        requirejs = undefined;
    }

    //Allow for a require config object
    if (typeof require !== 'undefined' && !isFunction(require)) {
        //assume it is a config object.
        cfg = require;
        require = undefined;
    }

    function newContext(contextName) {
        var inCheckLoaded, Module, context, handlers,
            checkLoadedTimeoutId,
            config = {
                //Defaults. Do not set a default for map
                //config to speed up normalize(), which
                //will run faster if there is no default.
                waitSeconds: 7,
                baseUrl: './',
                paths: {},
                bundles: {},
                pkgs: {},
                shim: {},
                config: {}
            },
            registry = {},
            //registry of just enabled modules, to speed
            //cycle breaking code when lots of modules
            //are registered, but not activated.
            enabledRegistry = {},
            undefEvents = {},
            defQueue = [],
            defined = {},
            urlFetched = {},
            bundlesMap = {},
            requireCounter = 1,
            unnormalizedCounter = 1;

        /**
         * Trims the . and .. from an array of path segments.
         * It will keep a leading path segment if a .. will become
         * the first path segment, to help with module name lookups,
         * which act like paths, but can be remapped. But the end result,
         * all paths that use this function should look normalized.
         * NOTE: this method MODIFIES the input array.
         * @param {Array} ary the array of path segments.
         */
        function trimDots(ary) {
            var i, part;
            for (i = 0; i < ary.length; i++) {
                part = ary[i];
                if (part === '.') {
                    ary.splice(i, 1);
                    i -= 1;
                } else if (part === '..') {
                    // If at the start, or previous value is still ..,
                    // keep them so that when converted to a path it may
                    // still work when converted to a path, even though
                    // as an ID it is less than ideal. In larger point
                    // releases, may be better to just kick out an error.
                    if (i === 0 || (i == 1 && ary[2] === '..') || ary[i - 1] === '..') {
                        continue;
                    } else if (i > 0) {
                        ary.splice(i - 1, 2);
                        i -= 2;
                    }
                }
            }
        }

        /**
         * Given a relative module name, like ./something, normalize it to
         * a real name that can be mapped to a path.
         * @param {String} name the relative name
         * @param {String} baseName a real name that the name arg is relative
         * to.
         * @param {Boolean} applyMap apply the map config to the value. Should
         * only be done if this normalization is for a dependency ID.
         * @returns {String} normalized name
         */
        function normalize(name, baseName, applyMap) {
            var pkgMain, mapValue, nameParts, i, j, nameSegment, lastIndex,
                foundMap, foundI, foundStarMap, starI, normalizedBaseParts,
                baseParts = (baseName && baseName.split('/')),
                map = config.map,
                starMap = map && map['*'];

            //Adjust any relative paths.
            if (name) {
                name = name.split('/');
                lastIndex = name.length - 1;

                // If wanting node ID compatibility, strip .js from end
                // of IDs. Have to do this here, and not in nameToUrl
                // because node allows either .js or non .js to map
                // to same file.
                if (config.nodeIdCompat && jsSuffixRegExp.test(name[lastIndex])) {
                    name[lastIndex] = name[lastIndex].replace(jsSuffixRegExp, '');
                }

                // Starts with a '.' so need the baseName
                if (name[0].charAt(0) === '.' && baseParts) {
                    //Convert baseName to array, and lop off the last part,
                    //so that . matches that 'directory' and not name of the baseName's
                    //module. For instance, baseName of 'one/two/three', maps to
                    //'one/two/three.js', but we want the directory, 'one/two' for
                    //this normalization.
                    normalizedBaseParts = baseParts.slice(0, baseParts.length - 1);
                    name = normalizedBaseParts.concat(name);
                }

                trimDots(name);
                name = name.join('/');
            }

            //Apply map config if available.
            if (applyMap && map && (baseParts || starMap)) {
                nameParts = name.split('/');

                outerLoop: for (i = nameParts.length; i > 0; i -= 1) {
                    nameSegment = nameParts.slice(0, i).join('/');

                    if (baseParts) {
                        //Find the longest baseName segment match in the config.
                        //So, do joins on the biggest to smallest lengths of baseParts.
                        for (j = baseParts.length; j > 0; j -= 1) {
                            mapValue = getOwn(map, baseParts.slice(0, j).join('/'));

                            //baseName segment has config, find if it has one for
                            //this name.
                            if (mapValue) {
                                mapValue = getOwn(mapValue, nameSegment);
                                if (mapValue) {
                                    //Match, update name to the new value.
                                    foundMap = mapValue;
                                    foundI = i;
                                    break outerLoop;
                                }
                            }
                        }
                    }

                    //Check for a star map match, but just hold on to it,
                    //if there is a shorter segment match later in a matching
                    //config, then favor over this star map.
                    if (!foundStarMap && starMap && getOwn(starMap, nameSegment)) {
                        foundStarMap = getOwn(starMap, nameSegment);
                        starI = i;
                    }
                }

                if (!foundMap && foundStarMap) {
                    foundMap = foundStarMap;
                    foundI = starI;
                }

                if (foundMap) {
                    nameParts.splice(0, foundI, foundMap);
                    name = nameParts.join('/');
                }
            }

            // If the name points to a package's name, use
            // the package main instead.
            pkgMain = getOwn(config.pkgs, name);

            return pkgMain ? pkgMain : name;
        }

        function removeScript(name) {
            if (isBrowser) {
                each(scripts(), function (scriptNode) {
                    if (scriptNode.getAttribute('data-requiremodule') === name &&
                            scriptNode.getAttribute('data-requirecontext') === context.contextName) {
                        scriptNode.parentNode.removeChild(scriptNode);
                        return true;
                    }
                });
            }
        }

        function hasPathFallback(id) {
            var pathConfig = getOwn(config.paths, id);
            if (pathConfig && isArray(pathConfig) && pathConfig.length > 1) {
                //Pop off the first array value, since it failed, and
                //retry
                pathConfig.shift();
                context.require.undef(id);

                //Custom require that does not do map translation, since
                //ID is "absolute", already mapped/resolved.
                context.makeRequire(null, {
                    skipMap: true
                })([id]);

                return true;
            }
        }

        //Turns a plugin!resource to [plugin, resource]
        //with the plugin being undefined if the name
        //did not have a plugin prefix.
        function splitPrefix(name) {
            var prefix,
                index = name ? name.indexOf('!') : -1;
            if (index > -1) {
                prefix = name.substring(0, index);
                name = name.substring(index + 1, name.length);
            }
            return [prefix, name];
        }

        /**
         * Creates a module mapping that includes plugin prefix, module
         * name, and path. If parentModuleMap is provided it will
         * also normalize the name via require.normalize()
         *
         * @param {String} name the module name
         * @param {String} [parentModuleMap] parent module map
         * for the module name, used to resolve relative names.
         * @param {Boolean} isNormalized: is the ID already normalized.
         * This is true if this call is done for a define() module ID.
         * @param {Boolean} applyMap: apply the map config to the ID.
         * Should only be true if this map is for a dependency.
         *
         * @returns {Object}
         */
        function makeModuleMap(name, parentModuleMap, isNormalized, applyMap) {
            var url, pluginModule, suffix, nameParts,
                prefix = null,
                parentName = parentModuleMap ? parentModuleMap.name : null,
                originalName = name,
                isDefine = true,
                normalizedName = '';

            //If no name, then it means it is a require call, generate an
            //internal name.
            if (!name) {
                isDefine = false;
                name = '_@r' + (requireCounter += 1);
            }

            nameParts = splitPrefix(name);
            prefix = nameParts[0];
            name = nameParts[1];

            if (prefix) {
                prefix = normalize(prefix, parentName, applyMap);
                pluginModule = getOwn(defined, prefix);
            }

            //Account for relative paths if there is a base name.
            if (name) {
                if (prefix) {
                    if (pluginModule && pluginModule.normalize) {
                        //Plugin is loaded, use its normalize method.
                        normalizedName = pluginModule.normalize(name, function (name) {
                            return normalize(name, parentName, applyMap);
                        });
                    } else {
                        // If nested plugin references, then do not try to
                        // normalize, as it will not normalize correctly. This
                        // places a restriction on resourceIds, and the longer
                        // term solution is not to normalize until plugins are
                        // loaded and all normalizations to allow for async
                        // loading of a loader plugin. But for now, fixes the
                        // common uses. Details in #1131
                        normalizedName = name.indexOf('!') === -1 ?
                                         normalize(name, parentName, applyMap) :
                                         name;
                    }
                } else {
                    //A regular module.
                    normalizedName = normalize(name, parentName, applyMap);

                    //Normalized name may be a plugin ID due to map config
                    //application in normalize. The map config values must
                    //already be normalized, so do not need to redo that part.
                    nameParts = splitPrefix(normalizedName);
                    prefix = nameParts[0];
                    normalizedName = nameParts[1];
                    isNormalized = true;

                    url = context.nameToUrl(normalizedName);
                }
            }

            //If the id is a plugin id that cannot be determined if it needs
            //normalization, stamp it with a unique ID so two matching relative
            //ids that may conflict can be separate.
            suffix = prefix && !pluginModule && !isNormalized ?
                     '_unnormalized' + (unnormalizedCounter += 1) :
                     '';

            return {
                prefix: prefix,
                name: normalizedName,
                parentMap: parentModuleMap,
                unnormalized: !!suffix,
                url: url,
                originalName: originalName,
                isDefine: isDefine,
                id: (prefix ?
                        prefix + '!' + normalizedName :
                        normalizedName) + suffix
            };
        }

        function getModule(depMap) {
            var id = depMap.id,
                mod = getOwn(registry, id);

            if (!mod) {
                mod = registry[id] = new context.Module(depMap);
            }

            return mod;
        }

        function on(depMap, name, fn) {
            var id = depMap.id,
                mod = getOwn(registry, id);

            if (hasProp(defined, id) &&
                    (!mod || mod.defineEmitComplete)) {
                if (name === 'defined') {
                    fn(defined[id]);
                }
            } else {
                mod = getModule(depMap);
                if (mod.error && name === 'error') {
                    fn(mod.error);
                } else {
                    mod.on(name, fn);
                }
            }
        }

        function onError(err, errback) {
            var ids = err.requireModules,
                notified = false;

            if (errback) {
                errback(err);
            } else {
                each(ids, function (id) {
                    var mod = getOwn(registry, id);
                    if (mod) {
                        //Set error on module, so it skips timeout checks.
                        mod.error = err;
                        if (mod.events.error) {
                            notified = true;
                            mod.emit('error', err);
                        }
                    }
                });

                if (!notified) {
                    req.onError(err);
                }
            }
        }

        /**
         * Internal method to transfer globalQueue items to this context's
         * defQueue.
         */
        function takeGlobalQueue() {
            //Push all the globalDefQueue items into the context's defQueue
            if (globalDefQueue.length) {
                //Array splice in the values since the context code has a
                //local var ref to defQueue, so cannot just reassign the one
                //on context.
                apsp.apply(defQueue,
                           [defQueue.length, 0].concat(globalDefQueue));
                globalDefQueue = [];
            }
        }

        handlers = {
            'require': function (mod) {
                if (mod.require) {
                    return mod.require;
                } else {
                    return (mod.require = context.makeRequire(mod.map));
                }
            },
            'exports': function (mod) {
                mod.usingExports = true;
                if (mod.map.isDefine) {
                    if (mod.exports) {
                        return (defined[mod.map.id] = mod.exports);
                    } else {
                        return (mod.exports = defined[mod.map.id] = {});
                    }
                }
            },
            'module': function (mod) {
                if (mod.module) {
                    return mod.module;
                } else {
                    return (mod.module = {
                        id: mod.map.id,
                        uri: mod.map.url,
                        config: function () {
                            return  getOwn(config.config, mod.map.id) || {};
                        },
                        exports: mod.exports || (mod.exports = {})
                    });
                }
            }
        };

        function cleanRegistry(id) {
            //Clean up machinery used for waiting modules.
            delete registry[id];
            delete enabledRegistry[id];
        }

        function breakCycle(mod, traced, processed) {
            var id = mod.map.id;

            if (mod.error) {
                mod.emit('error', mod.error);
            } else {
                traced[id] = true;
                each(mod.depMaps, function (depMap, i) {
                    var depId = depMap.id,
                        dep = getOwn(registry, depId);

                    //Only force things that have not completed
                    //being defined, so still in the registry,
                    //and only if it has not been matched up
                    //in the module already.
                    if (dep && !mod.depMatched[i] && !processed[depId]) {
                        if (getOwn(traced, depId)) {
                            mod.defineDep(i, defined[depId]);
                            mod.check(); //pass false?
                        } else {
                            breakCycle(dep, traced, processed);
                        }
                    }
                });
                processed[id] = true;
            }
        }

        function checkLoaded() {
            var err, usingPathFallback,
                waitInterval = config.waitSeconds * 1000,
                //It is possible to disable the wait interval by using waitSeconds of 0.
                expired = waitInterval && (context.startTime + waitInterval) < new Date().getTime(),
                noLoads = [],
                reqCalls = [],
                stillLoading = false,
                needCycleCheck = true;

            //Do not bother if this call was a result of a cycle break.
            if (inCheckLoaded) {
                return;
            }

            inCheckLoaded = true;

            //Figure out the state of all the modules.
            eachProp(enabledRegistry, function (mod) {
                var map = mod.map,
                    modId = map.id;

                //Skip things that are not enabled or in error state.
                if (!mod.enabled) {
                    return;
                }

                if (!map.isDefine) {
                    reqCalls.push(mod);
                }

                if (!mod.error) {
                    //If the module should be executed, and it has not
                    //been inited and time is up, remember it.
                    if (!mod.inited && expired) {
                        if (hasPathFallback(modId)) {
                            usingPathFallback = true;
                            stillLoading = true;
                        } else {
                            noLoads.push(modId);
                            removeScript(modId);
                        }
                    } else if (!mod.inited && mod.fetched && map.isDefine) {
                        stillLoading = true;
                        if (!map.prefix) {
                            //No reason to keep looking for unfinished
                            //loading. If the only stillLoading is a
                            //plugin resource though, keep going,
                            //because it may be that a plugin resource
                            //is waiting on a non-plugin cycle.
                            return (needCycleCheck = false);
                        }
                    }
                }
            });

            if (expired && noLoads.length) {
                //If wait time expired, throw error of unloaded modules.
                err = makeError('timeout', 'Load timeout for modules: ' + noLoads, null, noLoads);
                err.contextName = context.contextName;
                return onError(err);
            }

            //Not expired, check for a cycle.
            if (needCycleCheck) {
                each(reqCalls, function (mod) {
                    breakCycle(mod, {}, {});
                });
            }

            //If still waiting on loads, and the waiting load is something
            //other than a plugin resource, or there are still outstanding
            //scripts, then just try back later.
            if ((!expired || usingPathFallback) && stillLoading) {
                //Something is still waiting to load. Wait for it, but only
                //if a timeout is not already in effect.
                if ((isBrowser || isWebWorker) && !checkLoadedTimeoutId) {
                    checkLoadedTimeoutId = setTimeout(function () {
                        checkLoadedTimeoutId = 0;
                        checkLoaded();
                    }, 50);
                }
            }

            inCheckLoaded = false;
        }

        Module = function (map) {
            this.events = getOwn(undefEvents, map.id) || {};
            this.map = map;
            this.shim = getOwn(config.shim, map.id);
            this.depExports = [];
            this.depMaps = [];
            this.depMatched = [];
            this.pluginMaps = {};
            this.depCount = 0;

            /* this.exports this.factory
               this.depMaps = [],
               this.enabled, this.fetched
            */
        };

        Module.prototype = {
            init: function (depMaps, factory, errback, options) {
                options = options || {};

                //Do not do more inits if already done. Can happen if there
                //are multiple define calls for the same module. That is not
                //a normal, common case, but it is also not unexpected.
                if (this.inited) {
                    return;
                }

                this.factory = factory;

                if (errback) {
                    //Register for errors on this module.
                    this.on('error', errback);
                } else if (this.events.error) {
                    //If no errback already, but there are error listeners
                    //on this module, set up an errback to pass to the deps.
                    errback = bind(this, function (err) {
                        this.emit('error', err);
                    });
                }

                //Do a copy of the dependency array, so that
                //source inputs are not modified. For example
                //"shim" deps are passed in here directly, and
                //doing a direct modification of the depMaps array
                //would affect that config.
                this.depMaps = depMaps && depMaps.slice(0);

                this.errback = errback;

                //Indicate this module has be initialized
                this.inited = true;

                this.ignore = options.ignore;

                //Could have option to init this module in enabled mode,
                //or could have been previously marked as enabled. However,
                //the dependencies are not known until init is called. So
                //if enabled previously, now trigger dependencies as enabled.
                if (options.enabled || this.enabled) {
                    //Enable this module and dependencies.
                    //Will call this.check()
                    this.enable();
                } else {
                    this.check();
                }
            },

            defineDep: function (i, depExports) {
                //Because of cycles, defined callback for a given
                //export can be called more than once.
                if (!this.depMatched[i]) {
                    this.depMatched[i] = true;
                    this.depCount -= 1;
                    this.depExports[i] = depExports;
                }
            },

            fetch: function () {
                if (this.fetched) {
                    return;
                }
                this.fetched = true;

                context.startTime = (new Date()).getTime();

                var map = this.map;

                //If the manager is for a plugin managed resource,
                //ask the plugin to load it now.
                if (this.shim) {
                    context.makeRequire(this.map, {
                        enableBuildCallback: true
                    })(this.shim.deps || [], bind(this, function () {
                        return map.prefix ? this.callPlugin() : this.load();
                    }));
                } else {
                    //Regular dependency.
                    return map.prefix ? this.callPlugin() : this.load();
                }
            },

            load: function () {
                var url = this.map.url;

                //Regular dependency.
                if (!urlFetched[url]) {
                    urlFetched[url] = true;
                    context.load(this.map.id, url);
                }
            },

            /**
             * Checks if the module is ready to define itself, and if so,
             * define it.
             */
            check: function () {
                if (!this.enabled || this.enabling) {
                    return;
                }

                var err, cjsModule,
                    id = this.map.id,
                    depExports = this.depExports,
                    exports = this.exports,
                    factory = this.factory;

                if (!this.inited) {
                    this.fetch();
                } else if (this.error) {
                    this.emit('error', this.error);
                } else if (!this.defining) {
                    //The factory could trigger another require call
                    //that would result in checking this module to
                    //define itself again. If already in the process
                    //of doing that, skip this work.
                    this.defining = true;

                    if (this.depCount < 1 && !this.defined) {
                        if (isFunction(factory)) {
                            //If there is an error listener, favor passing
                            //to that instead of throwing an error. However,
                            //only do it for define()'d  modules. require
                            //errbacks should not be called for failures in
                            //their callbacks (#699). However if a global
                            //onError is set, use that.
                            if ((this.events.error && this.map.isDefine) ||
                                req.onError !== defaultOnError) {
                                try {
                                    exports = context.execCb(id, factory, depExports, exports);
                                } catch (e) {
                                    err = e;
                                }
                            } else {
                                exports = context.execCb(id, factory, depExports, exports);
                            }

                            // Favor return value over exports. If node/cjs in play,
                            // then will not have a return value anyway. Favor
                            // module.exports assignment over exports object.
                            if (this.map.isDefine && exports === undefined) {
                                cjsModule = this.module;
                                if (cjsModule) {
                                    exports = cjsModule.exports;
                                } else if (this.usingExports) {
                                    //exports already set the defined value.
                                    exports = this.exports;
                                }
                            }

                            if (err) {
                                err.requireMap = this.map;
                                err.requireModules = this.map.isDefine ? [this.map.id] : null;
                                err.requireType = this.map.isDefine ? 'define' : 'require';
                                return onError((this.error = err));
                            }

                        } else {
                            //Just a literal value
                            exports = factory;
                        }

                        this.exports = exports;

                        if (this.map.isDefine && !this.ignore) {
                            defined[id] = exports;

                            if (req.onResourceLoad) {
                                req.onResourceLoad(context, this.map, this.depMaps);
                            }
                        }

                        //Clean up
                        cleanRegistry(id);

                        this.defined = true;
                    }

                    //Finished the define stage. Allow calling check again
                    //to allow define notifications below in the case of a
                    //cycle.
                    this.defining = false;

                    if (this.defined && !this.defineEmitted) {
                        this.defineEmitted = true;
                        this.emit('defined', this.exports);
                        this.defineEmitComplete = true;
                    }

                }
            },

            callPlugin: function () {
                var map = this.map,
                    id = map.id,
                    //Map already normalized the prefix.
                    pluginMap = makeModuleMap(map.prefix);

                //Mark this as a dependency for this plugin, so it
                //can be traced for cycles.
                this.depMaps.push(pluginMap);

                on(pluginMap, 'defined', bind(this, function (plugin) {
                    var load, normalizedMap, normalizedMod,
                        bundleId = getOwn(bundlesMap, this.map.id),
                        name = this.map.name,
                        parentName = this.map.parentMap ? this.map.parentMap.name : null,
                        localRequire = context.makeRequire(map.parentMap, {
                            enableBuildCallback: true
                        });

                    //If current map is not normalized, wait for that
                    //normalized name to load instead of continuing.
                    if (this.map.unnormalized) {
                        //Normalize the ID if the plugin allows it.
                        if (plugin.normalize) {
                            name = plugin.normalize(name, function (name) {
                                return normalize(name, parentName, true);
                            }) || '';
                        }

                        //prefix and name should already be normalized, no need
                        //for applying map config again either.
                        normalizedMap = makeModuleMap(map.prefix + '!' + name,
                                                      this.map.parentMap);
                        on(normalizedMap,
                            'defined', bind(this, function (value) {
                                this.init([], function () { return value; }, null, {
                                    enabled: true,
                                    ignore: true
                                });
                            }));

                        normalizedMod = getOwn(registry, normalizedMap.id);
                        if (normalizedMod) {
                            //Mark this as a dependency for this plugin, so it
                            //can be traced for cycles.
                            this.depMaps.push(normalizedMap);

                            if (this.events.error) {
                                normalizedMod.on('error', bind(this, function (err) {
                                    this.emit('error', err);
                                }));
                            }
                            normalizedMod.enable();
                        }

                        return;
                    }

                    //If a paths config, then just load that file instead to
                    //resolve the plugin, as it is built into that paths layer.
                    if (bundleId) {
                        this.map.url = context.nameToUrl(bundleId);
                        this.load();
                        return;
                    }

                    load = bind(this, function (value) {
                        this.init([], function () { return value; }, null, {
                            enabled: true
                        });
                    });

                    load.error = bind(this, function (err) {
                        this.inited = true;
                        this.error = err;
                        err.requireModules = [id];

                        //Remove temp unnormalized modules for this module,
                        //since they will never be resolved otherwise now.
                        eachProp(registry, function (mod) {
                            if (mod.map.id.indexOf(id + '_unnormalized') === 0) {
                                cleanRegistry(mod.map.id);
                            }
                        });

                        onError(err);
                    });

                    //Allow plugins to load other code without having to know the
                    //context or how to 'complete' the load.
                    load.fromText = bind(this, function (text, textAlt) {
                        /*jslint evil: true */
                        var moduleName = map.name,
                            moduleMap = makeModuleMap(moduleName),
                            hasInteractive = useInteractive;

                        //As of 2.1.0, support just passing the text, to reinforce
                        //fromText only being called once per resource. Still
                        //support old style of passing moduleName but discard
                        //that moduleName in favor of the internal ref.
                        if (textAlt) {
                            text = textAlt;
                        }

                        //Turn off interactive script matching for IE for any define
                        //calls in the text, then turn it back on at the end.
                        if (hasInteractive) {
                            useInteractive = false;
                        }

                        //Prime the system by creating a module instance for
                        //it.
                        getModule(moduleMap);

                        //Transfer any config to this other module.
                        if (hasProp(config.config, id)) {
                            config.config[moduleName] = config.config[id];
                        }

                        try {
                            req.exec(text);
                        } catch (e) {
                            return onError(makeError('fromtexteval',
                                             'fromText eval for ' + id +
                                            ' failed: ' + e,
                                             e,
                                             [id]));
                        }

                        if (hasInteractive) {
                            useInteractive = true;
                        }

                        //Mark this as a dependency for the plugin
                        //resource
                        this.depMaps.push(moduleMap);

                        //Support anonymous modules.
                        context.completeLoad(moduleName);

                        //Bind the value of that module to the value for this
                        //resource ID.
                        localRequire([moduleName], load);
                    });

                    //Use parentName here since the plugin's name is not reliable,
                    //could be some weird string with no path that actually wants to
                    //reference the parentName's path.
                    plugin.load(map.name, localRequire, load, config);
                }));

                context.enable(pluginMap, this);
                this.pluginMaps[pluginMap.id] = pluginMap;
            },

            enable: function () {
                enabledRegistry[this.map.id] = this;
                this.enabled = true;

                //Set flag mentioning that the module is enabling,
                //so that immediate calls to the defined callbacks
                //for dependencies do not trigger inadvertent load
                //with the depCount still being zero.
                this.enabling = true;

                //Enable each dependency
                each(this.depMaps, bind(this, function (depMap, i) {
                    var id, mod, handler;

                    if (typeof depMap === 'string') {
                        //Dependency needs to be converted to a depMap
                        //and wired up to this module.
                        depMap = makeModuleMap(depMap,
                                               (this.map.isDefine ? this.map : this.map.parentMap),
                                               false,
                                               !this.skipMap);
                        this.depMaps[i] = depMap;

                        handler = getOwn(handlers, depMap.id);

                        if (handler) {
                            this.depExports[i] = handler(this);
                            return;
                        }

                        this.depCount += 1;

                        on(depMap, 'defined', bind(this, function (depExports) {
                            this.defineDep(i, depExports);
                            this.check();
                        }));

                        if (this.errback) {
                            on(depMap, 'error', bind(this, this.errback));
                        }
                    }

                    id = depMap.id;
                    mod = registry[id];

                    //Skip special modules like 'require', 'exports', 'module'
                    //Also, don't call enable if it is already enabled,
                    //important in circular dependency cases.
                    if (!hasProp(handlers, id) && mod && !mod.enabled) {
                        context.enable(depMap, this);
                    }
                }));

                //Enable each plugin that is used in
                //a dependency
                eachProp(this.pluginMaps, bind(this, function (pluginMap) {
                    var mod = getOwn(registry, pluginMap.id);
                    if (mod && !mod.enabled) {
                        context.enable(pluginMap, this);
                    }
                }));

                this.enabling = false;

                this.check();
            },

            on: function (name, cb) {
                var cbs = this.events[name];
                if (!cbs) {
                    cbs = this.events[name] = [];
                }
                cbs.push(cb);
            },

            emit: function (name, evt) {
                each(this.events[name], function (cb) {
                    cb(evt);
                });
                if (name === 'error') {
                    //Now that the error handler was triggered, remove
                    //the listeners, since this broken Module instance
                    //can stay around for a while in the registry.
                    delete this.events[name];
                }
            }
        };

        function callGetModule(args) {
            //Skip modules already defined.
            if (!hasProp(defined, args[0])) {
                getModule(makeModuleMap(args[0], null, true)).init(args[1], args[2]);
            }
        }

        function removeListener(node, func, name, ieName) {
            //Favor detachEvent because of IE9
            //issue, see attachEvent/addEventListener comment elsewhere
            //in this file.
            if (node.detachEvent && !isOpera) {
                //Probably IE. If not it will throw an error, which will be
                //useful to know.
                if (ieName) {
                    node.detachEvent(ieName, func);
                }
            } else {
                node.removeEventListener(name, func, false);
            }
        }

        /**
         * Given an event from a script node, get the requirejs info from it,
         * and then removes the event listeners on the node.
         * @param {Event} evt
         * @returns {Object}
         */
        function getScriptData(evt) {
            //Using currentTarget instead of target for Firefox 2.0's sake. Not
            //all old browsers will be supported, but this one was easy enough
            //to support and still makes sense.
            var node = evt.currentTarget || evt.srcElement;

            //Remove the listeners once here.
            removeListener(node, context.onScriptLoad, 'load', 'onreadystatechange');
            removeListener(node, context.onScriptError, 'error');

            return {
                node: node,
                id: node && node.getAttribute('data-requiremodule')
            };
        }

        function intakeDefines() {
            var args;

            //Any defined modules in the global queue, intake them now.
            takeGlobalQueue();

            //Make sure any remaining defQueue items get properly processed.
            while (defQueue.length) {
                args = defQueue.shift();
                if (args[0] === null) {
                    return onError(makeError('mismatch', 'Mismatched anonymous define() module: ' + args[args.length - 1]));
                } else {
                    //args are id, deps, factory. Should be normalized by the
                    //define() function.
                    callGetModule(args);
                }
            }
        }

        context = {
            config: config,
            contextName: contextName,
            registry: registry,
            defined: defined,
            urlFetched: urlFetched,
            defQueue: defQueue,
            Module: Module,
            makeModuleMap: makeModuleMap,
            nextTick: req.nextTick,
            onError: onError,

            /**
             * Set a configuration for the context.
             * @param {Object} cfg config object to integrate.
             */
            configure: function (cfg) {
                //Make sure the baseUrl ends in a slash.
                if (cfg.baseUrl) {
                    if (cfg.baseUrl.charAt(cfg.baseUrl.length - 1) !== '/') {
                        cfg.baseUrl += '/';
                    }
                }

                //Save off the paths since they require special processing,
                //they are additive.
                var shim = config.shim,
                    objs = {
                        paths: true,
                        bundles: true,
                        config: true,
                        map: true
                    };

                eachProp(cfg, function (value, prop) {
                    if (objs[prop]) {
                        if (!config[prop]) {
                            config[prop] = {};
                        }
                        mixin(config[prop], value, true, true);
                    } else {
                        config[prop] = value;
                    }
                });

                //Reverse map the bundles
                if (cfg.bundles) {
                    eachProp(cfg.bundles, function (value, prop) {
                        each(value, function (v) {
                            if (v !== prop) {
                                bundlesMap[v] = prop;
                            }
                        });
                    });
                }

                //Merge shim
                if (cfg.shim) {
                    eachProp(cfg.shim, function (value, id) {
                        //Normalize the structure
                        if (isArray(value)) {
                            value = {
                                deps: value
                            };
                        }
                        if ((value.exports || value.init) && !value.exportsFn) {
                            value.exportsFn = context.makeShimExports(value);
                        }
                        shim[id] = value;
                    });
                    config.shim = shim;
                }

                //Adjust packages if necessary.
                if (cfg.packages) {
                    each(cfg.packages, function (pkgObj) {
                        var location, name;

                        pkgObj = typeof pkgObj === 'string' ? { name: pkgObj } : pkgObj;

                        name = pkgObj.name;
                        location = pkgObj.location;
                        if (location) {
                            config.paths[name] = pkgObj.location;
                        }

                        //Save pointer to main module ID for pkg name.
                        //Remove leading dot in main, so main paths are normalized,
                        //and remove any trailing .js, since different package
                        //envs have different conventions: some use a module name,
                        //some use a file name.
                        config.pkgs[name] = pkgObj.name + '/' + (pkgObj.main || 'main')
                                     .replace(currDirRegExp, '')
                                     .replace(jsSuffixRegExp, '');
                    });
                }

                //If there are any "waiting to execute" modules in the registry,
                //update the maps for them, since their info, like URLs to load,
                //may have changed.
                eachProp(registry, function (mod, id) {
                    //If module already has init called, since it is too
                    //late to modify them, and ignore unnormalized ones
                    //since they are transient.
                    if (!mod.inited && !mod.map.unnormalized) {
                        mod.map = makeModuleMap(id);
                    }
                });

                //If a deps array or a config callback is specified, then call
                //require with those args. This is useful when require is defined as a
                //config object before require.js is loaded.
                if (cfg.deps || cfg.callback) {
                    context.require(cfg.deps || [], cfg.callback);
                }
            },

            makeShimExports: function (value) {
                function fn() {
                    var ret;
                    if (value.init) {
                        ret = value.init.apply(global, arguments);
                    }
                    return ret || (value.exports && getGlobal(value.exports));
                }
                return fn;
            },

            makeRequire: function (relMap, options) {
                options = options || {};

                function localRequire(deps, callback, errback) {
                    var id, map, requireMod;

                    if (options.enableBuildCallback && callback && isFunction(callback)) {
                        callback.__requireJsBuild = true;
                    }

                    if (typeof deps === 'string') {
                        if (isFunction(callback)) {
                            //Invalid call
                            return onError(makeError('requireargs', 'Invalid require call'), errback);
                        }

                        //If require|exports|module are requested, get the
                        //value for them from the special handlers. Caveat:
                        //this only works while module is being defined.
                        if (relMap && hasProp(handlers, deps)) {
                            return handlers[deps](registry[relMap.id]);
                        }

                        //Synchronous access to one module. If require.get is
                        //available (as in the Node adapter), prefer that.
                        if (req.get) {
                            return req.get(context, deps, relMap, localRequire);
                        }

                        //Normalize module name, if it contains . or ..
                        map = makeModuleMap(deps, relMap, false, true);
                        id = map.id;

                        if (!hasProp(defined, id)) {
                            return onError(makeError('notloaded', 'Module name "' +
                                        id +
                                        '" has not been loaded yet for context: ' +
                                        contextName +
                                        (relMap ? '' : '. Use require([])')));
                        }
                        return defined[id];
                    }

                    //Grab defines waiting in the global queue.
                    intakeDefines();

                    //Mark all the dependencies as needing to be loaded.
                    context.nextTick(function () {
                        //Some defines could have been added since the
                        //require call, collect them.
                        intakeDefines();

                        requireMod = getModule(makeModuleMap(null, relMap));

                        //Store if map config should be applied to this require
                        //call for dependencies.
                        requireMod.skipMap = options.skipMap;

                        requireMod.init(deps, callback, errback, {
                            enabled: true
                        });

                        checkLoaded();
                    });

                    return localRequire;
                }

                mixin(localRequire, {
                    isBrowser: isBrowser,

                    /**
                     * Converts a module name + .extension into an URL path.
                     * *Requires* the use of a module name. It does not support using
                     * plain URLs like nameToUrl.
                     */
                    toUrl: function (moduleNamePlusExt) {
                        var ext,
                            index = moduleNamePlusExt.lastIndexOf('.'),
                            segment = moduleNamePlusExt.split('/')[0],
                            isRelative = segment === '.' || segment === '..';

                        //Have a file extension alias, and it is not the
                        //dots from a relative path.
                        if (index !== -1 && (!isRelative || index > 1)) {
                            ext = moduleNamePlusExt.substring(index, moduleNamePlusExt.length);
                            moduleNamePlusExt = moduleNamePlusExt.substring(0, index);
                        }

                        return context.nameToUrl(normalize(moduleNamePlusExt,
                                                relMap && relMap.id, true), ext,  true);
                    },

                    defined: function (id) {
                        return hasProp(defined, makeModuleMap(id, relMap, false, true).id);
                    },

                    specified: function (id) {
                        id = makeModuleMap(id, relMap, false, true).id;
                        return hasProp(defined, id) || hasProp(registry, id);
                    }
                });

                //Only allow undef on top level require calls
                if (!relMap) {
                    localRequire.undef = function (id) {
                        //Bind any waiting define() calls to this context,
                        //fix for #408
                        takeGlobalQueue();

                        var map = makeModuleMap(id, relMap, true),
                            mod = getOwn(registry, id);

                        removeScript(id);

                        delete defined[id];
                        delete urlFetched[map.url];
                        delete undefEvents[id];

                        //Clean queued defines too. Go backwards
                        //in array so that the splices do not
                        //mess up the iteration.
                        eachReverse(defQueue, function(args, i) {
                            if(args[0] === id) {
                                defQueue.splice(i, 1);
                            }
                        });

                        if (mod) {
                            //Hold on to listeners in case the
                            //module will be attempted to be reloaded
                            //using a different config.
                            if (mod.events.defined) {
                                undefEvents[id] = mod.events;
                            }

                            cleanRegistry(id);
                        }
                    };
                }

                return localRequire;
            },

            /**
             * Called to enable a module if it is still in the registry
             * awaiting enablement. A second arg, parent, the parent module,
             * is passed in for context, when this method is overridden by
             * the optimizer. Not shown here to keep code compact.
             */
            enable: function (depMap) {
                var mod = getOwn(registry, depMap.id);
                if (mod) {
                    getModule(depMap).enable();
                }
            },

            /**
             * Internal method used by environment adapters to complete a load event.
             * A load event could be a script load or just a load pass from a synchronous
             * load call.
             * @param {String} moduleName the name of the module to potentially complete.
             */
            completeLoad: function (moduleName) {
                var found, args, mod,
                    shim = getOwn(config.shim, moduleName) || {},
                    shExports = shim.exports;

                takeGlobalQueue();

                while (defQueue.length) {
                    args = defQueue.shift();
                    if (args[0] === null) {
                        args[0] = moduleName;
                        //If already found an anonymous module and bound it
                        //to this name, then this is some other anon module
                        //waiting for its completeLoad to fire.
                        if (found) {
                            break;
                        }
                        found = true;
                    } else if (args[0] === moduleName) {
                        //Found matching define call for this script!
                        found = true;
                    }

                    callGetModule(args);
                }

                //Do this after the cycle of callGetModule in case the result
                //of those calls/init calls changes the registry.
                mod = getOwn(registry, moduleName);

                if (!found && !hasProp(defined, moduleName) && mod && !mod.inited) {
                    if (config.enforceDefine && (!shExports || !getGlobal(shExports))) {
                        if (hasPathFallback(moduleName)) {
                            return;
                        } else {
                            return onError(makeError('nodefine',
                                             'No define call for ' + moduleName,
                                             null,
                                             [moduleName]));
                        }
                    } else {
                        //A script that does not call define(), so just simulate
                        //the call for it.
                        callGetModule([moduleName, (shim.deps || []), shim.exportsFn]);
                    }
                }

                checkLoaded();
            },

            /**
             * Converts a module name to a file path. Supports cases where
             * moduleName may actually be just an URL.
             * Note that it **does not** call normalize on the moduleName,
             * it is assumed to have already been normalized. This is an
             * internal API, not a public one. Use toUrl for the public API.
             */
            nameToUrl: function (moduleName, ext, skipExt) {
                var paths, syms, i, parentModule, url,
                    parentPath, bundleId,
                    pkgMain = getOwn(config.pkgs, moduleName);

                if (pkgMain) {
                    moduleName = pkgMain;
                }

                bundleId = getOwn(bundlesMap, moduleName);

                if (bundleId) {
                    return context.nameToUrl(bundleId, ext, skipExt);
                }

                //If a colon is in the URL, it indicates a protocol is used and it is just
                //an URL to a file, or if it starts with a slash, contains a query arg (i.e. ?)
                //or ends with .js, then assume the user meant to use an url and not a module id.
                //The slash is important for protocol-less URLs as well as full paths.
                if (req.jsExtRegExp.test(moduleName)) {
                    //Just a plain path, not module name lookup, so just return it.
                    //Add extension if it is included. This is a bit wonky, only non-.js things pass
                    //an extension, this method probably needs to be reworked.
                    url = moduleName + (ext || '');
                } else {
                    //A module that needs to be converted to a path.
                    paths = config.paths;

                    syms = moduleName.split('/');
                    //For each module name segment, see if there is a path
                    //registered for it. Start with most specific name
                    //and work up from it.
                    for (i = syms.length; i > 0; i -= 1) {
                        parentModule = syms.slice(0, i).join('/');

                        parentPath = getOwn(paths, parentModule);
                        if (parentPath) {
                            //If an array, it means there are a few choices,
                            //Choose the one that is desired
                            if (isArray(parentPath)) {
                                parentPath = parentPath[0];
                            }
                            syms.splice(0, i, parentPath);
                            break;
                        }
                    }

                    //Join the path parts together, then figure out if baseUrl is needed.
                    url = syms.join('/');
                    url += (ext || (/^data\:|\?/.test(url) || skipExt ? '' : '.js'));
                    url = (url.charAt(0) === '/' || url.match(/^[\w\+\.\-]+:/) ? '' : config.baseUrl) + url;
                }

                return config.urlArgs ? url +
                                        ((url.indexOf('?') === -1 ? '?' : '&') +
                                         config.urlArgs) : url;
            },

            //Delegates to req.load. Broken out as a separate function to
            //allow overriding in the optimizer.
            load: function (id, url) {
                req.load(context, id, url);
            },

            /**
             * Executes a module callback function. Broken out as a separate function
             * solely to allow the build system to sequence the files in the built
             * layer in the right sequence.
             *
             * @private
             */
            execCb: function (name, callback, args, exports) {
                return callback.apply(exports, args);
            },

            /**
             * callback for script loads, used to check status of loading.
             *
             * @param {Event} evt the event from the browser for the script
             * that was loaded.
             */
            onScriptLoad: function (evt) {
                //Using currentTarget instead of target for Firefox 2.0's sake. Not
                //all old browsers will be supported, but this one was easy enough
                //to support and still makes sense.
                if (evt.type === 'load' ||
                        (readyRegExp.test((evt.currentTarget || evt.srcElement).readyState))) {
                    //Reset interactive script so a script node is not held onto for
                    //to long.
                    interactiveScript = null;

                    //Pull out the name of the module and the context.
                    var data = getScriptData(evt);
                    context.completeLoad(data.id);
                }
            },

            /**
             * Callback for script errors.
             */
            onScriptError: function (evt) {
                var data = getScriptData(evt);
                if (!hasPathFallback(data.id)) {
                    return onError(makeError('scripterror', 'Script error for: ' + data.id, evt, [data.id]));
                }
            }
        };

        context.require = context.makeRequire();
        return context;
    }

    /**
     * Main entry point.
     *
     * If the only argument to require is a string, then the module that
     * is represented by that string is fetched for the appropriate context.
     *
     * If the first argument is an array, then it will be treated as an array
     * of dependency string names to fetch. An optional function callback can
     * be specified to execute when all of those dependencies are available.
     *
     * Make a local req variable to help Caja compliance (it assumes things
     * on a require that are not standardized), and to give a short
     * name for minification/local scope use.
     */
    req = requirejs = function (deps, callback, errback, optional) {

        //Find the right context, use default
        var context, config,
            contextName = defContextName;

        // Determine if have config object in the call.
        if (!isArray(deps) && typeof deps !== 'string') {
            // deps is a config object
            config = deps;
            if (isArray(callback)) {
                // Adjust args if there are dependencies
                deps = callback;
                callback = errback;
                errback = optional;
            } else {
                deps = [];
            }
        }

        if (config && config.context) {
            contextName = config.context;
        }

        context = getOwn(contexts, contextName);
        if (!context) {
            context = contexts[contextName] = req.s.newContext(contextName);
        }

        if (config) {
            context.configure(config);
        }

        return context.require(deps, callback, errback);
    };

    /**
     * Support require.config() to make it easier to cooperate with other
     * AMD loaders on globally agreed names.
     */
    req.config = function (config) {
        return req(config);
    };

    /**
     * Execute something after the current tick
     * of the event loop. Override for other envs
     * that have a better solution than setTimeout.
     * @param  {Function} fn function to execute later.
     */
    req.nextTick = typeof setTimeout !== 'undefined' ? function (fn) {
        setTimeout(fn, 4);
    } : function (fn) { fn(); };

    /**
     * Export require as a global, but only if it does not already exist.
     */
    if (!require) {
        require = req;
    }

    req.version = version;

    //Used to filter out dependencies that are already paths.
    req.jsExtRegExp = /^\/|:|\?|\.js$/;
    req.isBrowser = isBrowser;
    s = req.s = {
        contexts: contexts,
        newContext: newContext
    };

    //Create default context.
    req({});

    //Exports some context-sensitive methods on global require.
    each([
        'toUrl',
        'undef',
        'defined',
        'specified'
    ], function (prop) {
        //Reference from contexts instead of early binding to default context,
        //so that during builds, the latest instance of the default context
        //with its config gets used.
        req[prop] = function () {
            var ctx = contexts[defContextName];
            return ctx.require[prop].apply(ctx, arguments);
        };
    });

    if (isBrowser) {
        head = s.head = document.getElementsByTagName('head')[0];
        //If BASE tag is in play, using appendChild is a problem for IE6.
        //When that browser dies, this can be removed. Details in this jQuery bug:
        //http://dev.jquery.com/ticket/2709
        baseElement = document.getElementsByTagName('base')[0];
        if (baseElement) {
            head = s.head = baseElement.parentNode;
        }
    }

    /**
     * Any errors that require explicitly generates will be passed to this
     * function. Intercept/override it if you want custom error handling.
     * @param {Error} err the error object.
     */
    req.onError = defaultOnError;

    /**
     * Creates the node for the load command. Only used in browser envs.
     */
    req.createNode = function (config, moduleName, url) {
        var node = config.xhtml ?
                document.createElementNS('http://www.w3.org/1999/xhtml', 'html:script') :
                document.createElement('script');
        node.type = config.scriptType || 'text/javascript';
        node.charset = 'utf-8';
        node.async = true;
        return node;
    };

    /**
     * Does the request to load a module for the browser case.
     * Make this a separate function to allow other environments
     * to override it.
     *
     * @param {Object} context the require context to find state.
     * @param {String} moduleName the name of the module.
     * @param {Object} url the URL to the module.
     */
    req.load = function (context, moduleName, url) {
        var config = (context && context.config) || {},
            node;
        if (isBrowser) {
            //In the browser so use a script tag
            node = req.createNode(config, moduleName, url);

            node.setAttribute('data-requirecontext', context.contextName);
            node.setAttribute('data-requiremodule', moduleName);

            //Set up load listener. Test attachEvent first because IE9 has
            //a subtle issue in its addEventListener and script onload firings
            //that do not match the behavior of all other browsers with
            //addEventListener support, which fire the onload event for a
            //script right after the script execution. See:
            //https://connect.microsoft.com/IE/feedback/details/648057/script-onload-event-is-not-fired-immediately-after-script-execution
            //UNFORTUNATELY Opera implements attachEvent but does not follow the script
            //script execution mode.
            if (node.attachEvent &&
                    //Check if node.attachEvent is artificially added by custom script or
                    //natively supported by browser
                    //read https://github.com/jrburke/requirejs/issues/187
                    //if we can NOT find [native code] then it must NOT natively supported.
                    //in IE8, node.attachEvent does not have toString()
                    //Note the test for "[native code" with no closing brace, see:
                    //https://github.com/jrburke/requirejs/issues/273
                    !(node.attachEvent.toString && node.attachEvent.toString().indexOf('[native code') < 0) &&
                    !isOpera) {
                //Probably IE. IE (at least 6-8) do not fire
                //script onload right after executing the script, so
                //we cannot tie the anonymous define call to a name.
                //However, IE reports the script as being in 'interactive'
                //readyState at the time of the define call.
                useInteractive = true;

                node.attachEvent('onreadystatechange', context.onScriptLoad);
                //It would be great to add an error handler here to catch
                //404s in IE9+. However, onreadystatechange will fire before
                //the error handler, so that does not help. If addEventListener
                //is used, then IE will fire error before load, but we cannot
                //use that pathway given the connect.microsoft.com issue
                //mentioned above about not doing the 'script execute,
                //then fire the script load event listener before execute
                //next script' that other browsers do.
                //Best hope: IE10 fixes the issues,
                //and then destroys all installs of IE 6-9.
                //node.attachEvent('onerror', context.onScriptError);
            } else {
                node.addEventListener('load', context.onScriptLoad, false);
                node.addEventListener('error', context.onScriptError, false);
            }
            node.src = url;

            //For some cache cases in IE 6-8, the script executes before the end
            //of the appendChild execution, so to tie an anonymous define
            //call to the module name (which is stored on the node), hold on
            //to a reference to this node, but clear after the DOM insertion.
            currentlyAddingScript = node;
            if (baseElement) {
                head.insertBefore(node, baseElement);
            } else {
                head.appendChild(node);
            }
            currentlyAddingScript = null;

            return node;
        } else if (isWebWorker) {
            try {
                //In a web worker, use importScripts. This is not a very
                //efficient use of importScripts, importScripts will block until
                //its script is downloaded and evaluated. However, if web workers
                //are in play, the expectation that a build has been done so that
                //only one script needs to be loaded anyway. This may need to be
                //reevaluated if other use cases become common.
                importScripts(url);

                //Account for anonymous modules
                context.completeLoad(moduleName);
            } catch (e) {
                context.onError(makeError('importscripts',
                                'importScripts failed for ' +
                                    moduleName + ' at ' + url,
                                e,
                                [moduleName]));
            }
        }
    };

    function getInteractiveScript() {
        if (interactiveScript && interactiveScript.readyState === 'interactive') {
            return interactiveScript;
        }

        eachReverse(scripts(), function (script) {
            if (script.readyState === 'interactive') {
                return (interactiveScript = script);
            }
        });
        return interactiveScript;
    }

    //Look for a data-main script attribute, which could also adjust the baseUrl.
    if (isBrowser && !cfg.skipDataMain) {
        //Figure out baseUrl. Get it from the script tag with require.js in it.
        eachReverse(scripts(), function (script) {
            //Set the 'head' where we can append children by
            //using the script's parent.
            if (!head) {
                head = script.parentNode;
            }

            //Look for a data-main attribute to set main script for the page
            //to load. If it is there, the path to data main becomes the
            //baseUrl, if it is not already set.
            dataMain = script.getAttribute('data-main');
            if (dataMain) {
                //Preserve dataMain in case it is a path (i.e. contains '?')
                mainScript = dataMain;

                //Set final baseUrl if there is not already an explicit one.
                if (!cfg.baseUrl) {
                    //Pull off the directory of data-main for use as the
                    //baseUrl.
                    src = mainScript.split('/');
                    mainScript = src.pop();
                    subPath = src.length ? src.join('/')  + '/' : './';

                    cfg.baseUrl = subPath;
                }

                //Strip off any trailing .js since mainScript is now
                //like a module name.
                mainScript = mainScript.replace(jsSuffixRegExp, '');

                 //If mainScript is still a path, fall back to dataMain
                if (req.jsExtRegExp.test(mainScript)) {
                    mainScript = dataMain;
                }

                //Put the data-main script in the files to load.
                cfg.deps = cfg.deps ? cfg.deps.concat(mainScript) : [mainScript];

                return true;
            }
        });
    }

    /**
     * The function that handles definitions of modules. Differs from
     * require() in that a string for the module should be the first argument,
     * and the function to execute after dependencies are loaded should
     * return a value to define the module corresponding to the first argument's
     * name.
     */
    define = function (name, deps, callback) {
        var node, context;

        //Allow for anonymous modules
        if (typeof name !== 'string') {
            //Adjust args appropriately
            callback = deps;
            deps = name;
            name = null;
        }

        //This module may not have dependencies
        if (!isArray(deps)) {
            callback = deps;
            deps = null;
        }

        //If no name, and callback is a function, then figure out if it a
        //CommonJS thing with dependencies.
        if (!deps && isFunction(callback)) {
            deps = [];
            //Remove comments from the callback string,
            //look for require calls, and pull them into the dependencies,
            //but only if there are function args.
            if (callback.length) {
                callback
                    .toString()
                    .replace(commentRegExp, '')
                    .replace(cjsRequireRegExp, function (match, dep) {
                        deps.push(dep);
                    });

                //May be a CommonJS thing even without require calls, but still
                //could use exports, and module. Avoid doing exports and module
                //work though if it just needs require.
                //REQUIRES the function to expect the CommonJS variables in the
                //order listed below.
                deps = (callback.length === 1 ? ['require'] : ['require', 'exports', 'module']).concat(deps);
            }
        }

        //If in IE 6-8 and hit an anonymous define() call, do the interactive
        //work.
        if (useInteractive) {
            node = currentlyAddingScript || getInteractiveScript();
            if (node) {
                if (!name) {
                    name = node.getAttribute('data-requiremodule');
                }
                context = contexts[node.getAttribute('data-requirecontext')];
            }
        }

        //Always save off evaluating the def call until the script onload handler.
        //This allows multiple modules to be in a file without prematurely
        //tracing dependencies, and allows for anonymous module support,
        //where the module name is not known until the script onload event
        //occurs. If no context, use the global queue, and get it processed
        //in the onscript load callback.
        (context ? context.defQueue : globalDefQueue).push([name, deps, callback]);
    };

    define.amd = {
        jQuery: true
    };


    /**
     * Executes the text. Normally just uses eval, but can be modified
     * to use a better, environment-specific call. Only used for transpiling
     * loader plugins, not for plain JS modules.
     * @param {String} text the text to execute/evaluate.
     */
    req.exec = function (text) {
        /*jslint evil: true */
        return eval(text);
    };

    //Set up with config info.
    req(cfg);
}(this));

define("requireLib", function(){});

// we can define document as a dependency
// works only in a browser context
define('webAPI/document',[], document);

define('metapolator/errors',[],function() {
    
    //metapolator errors
    var errors = {};

    /**
     * save three lines of coding for each error with this factory
     *
     * and observe that extending Error is uncool
     */
    var makeError = function(name, Constructor, prototype, namespace)
    {
        if(prototype === undefined)
            prototype = new Error();

        if(Constructor === undefined) {
            Constructor = function(message, stack) {
                if(message !== undefined) {
                    this.name = name + 'Error';
                    this.message = message || "(no error message)";
                }

                if(!stack && typeof Error.captureStackTrace === 'function')
                    Error.captureStackTrace(this, Constructor);
                else {
                    stack = stack || (new Error()).stack || '(no stack available)';
                    this.stack = [this.name+': ', this.message, '\n'
                                                    , stack].join('');
                }
            };
        }
        Constructor.prototype = prototype;
        Constructor.prototype.constructor = Constructor;
        if(namespace === undefined)
            namespace = errors;
        namespace[name] = Constructor;
    };
    errors.makeError = makeError;
    /**
     * the definitions go here
     */
    makeError('Error');
    makeError('Unhandled');
    makeError('Assertion', undefined , new errors.Error());
    makeError('CommandLine', undefined , new errors.Error());
    makeError('Value', undefined , new RangeError());
    makeError('MOM', undefined , new errors.Error());
    makeError('NotImplemented', undefined , new errors.Error());
    makeError('Deprecated', undefined , new errors.Error());
    makeError('AbstractInterface', undefined , new errors.Error());
    makeError('CPS', undefined , new errors.Error());
    makeError('Key', undefined , new errors.Error());
    makeError('CPSRegistryKey', undefined , new errors.Key());
    makeError('CPSKey', undefined , new errors.Key());
    makeError('CPSRecursion', undefined , new errors.CPS());
    makeError('CPSFormula', undefined , new errors.CPS());
    // deprecated, CPSFormula superseeds this
    makeError('CPSAlgebra', undefined , new errors.CPSFormula());
    makeError('Project', undefined , new errors.CPS());
    makeError('PointPen', undefined , new errors.CPS());
    makeError('CPSParser', undefined , new errors.CPS());
    makeError('Import', undefined , new errors.CPS());
    makeError('ImportPenstroke', undefined , new errors.Import());
    makeError('ImportContour', undefined , new errors.Import());
    makeError('Event', undefined , new errors.Error());
    makeError('Emitter', undefined , new errors.Event());
    makeError('Receiver', undefined , new errors.Event());

    /**
     * if expression is false, throw an Assertion
     * pass a message to explain yourself
     **/
    errors.assert = function(exp, message) {
        if (!exp) {
            throw new errors.Assertion(message);
        }
    };
    errors.warn = function(message) {
        if(typeof console !== 'undefined' && console.warn)
            console.warn('WARNING: ' + message);
    };

    /**
     * ES6/Promises have the fundamental flaw, that, if there is no
     * Error handler attached, an unhandled error stays unnoticed and
     * just disappears.
     * Because handling all Errors always correctly is not possible at
     * any given time e.g. a program may still be under construction for
     * example, this is a default handler to mark a promise as unhandled.
     *
     * Using this error-handler at the very end of the promise chain
     * ensures that the unhandled Proxy exception is not just disappearing
     * unnoticed by the main program.
     */
    function unhandledPromise(originalError) {
        var error = new errors.Unhandled(originalError+'');
        error.originalError = originalError;
        // use setTimout to escape the catch all that es6/Promise applies
        // and that silences unhandled errors
        setTimeout(function unhandledError(){throw error;}, 0);
    }
    errors.unhandledPromise = unhandledPromise;

    return errors;
});

/*
 * Don't edit this file by hand!
 * This file was generated from a npm-package using gulp. 
 * For more information see gulpfile.js in the project root
 */
define('path',['require','exports','module'],function (require, exports, module) {var process = process || {};
(function () {
  

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.


var isWindows = process.platform === 'win32';


// resolves . and .. elements in a path array with directory names there
// must be no slashes, empty elements, or device names (c:\) in the array
// (so also no leading and trailing slashes - it does not distinguish
// relative and absolute paths)
function normalizeArray(parts, allowAboveRoot) {
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = parts.length; i >= 0; i--) {
    var last = parts[i];
    if (last == '.') {
      parts.splice(i, 1);
    } else if (last === '..') {
      parts.splice(i, 1);
      up++;
    } else if (up) {
      parts.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift('..');
    }
  }

  return parts;
}


if (isWindows) {

  // Regex to split a filename into [*, dir, basename, ext]
  // windows version
  var splitPathRe = /^(.+(?:[\\\/](?!$)|:)|[\\\/])?((?:.+?)?(\.[^.]*)?)$/;

  // Regex to split a windows path into three parts: [*, device, slash,
  // tail] windows-only
  var splitDeviceRe =
      /^([a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/][^\\\/]+)?([\\\/])?(.*?)$/;

  // path.resolve([from ...], to)
  // windows version
  exports.resolve = function() {
    var resolvedDevice = '',
        resolvedTail = '',
        resolvedAbsolute = false;

    for (var i = arguments.length; i >= -1; i--) {
      var path = (i >= 0)
          ? arguments[i]
          : process.cwd();

      // Skip empty and invalid entries
      if (typeof path !== 'string' || !path) {
        continue;
      }

      var result = splitDeviceRe.exec(path),
          device = result[1] || '',
          isUnc = device && device.charAt(1) !== ':',
          isAbsolute = !!result[2] || isUnc, // UNC paths are always absolute
          tail = result[3];

      if (device &&
          resolvedDevice &&
          device.toLowerCase() !== resolvedDevice.toLowerCase()) {
        // This path points to another device so it is not applicable
        continue;
      }

      if (!resolvedDevice) {
        resolvedDevice = device;
      }
      if (!resolvedAbsolute) {
        resolvedTail = tail + '\\' + resolvedTail;
        resolvedAbsolute = isAbsolute;
      }

      if (resolvedDevice && resolvedAbsolute) {
        break;
      }
    }

    if (!resolvedAbsolute && resolvedDevice) {
      // If we still don't have an absolute path,
      // prepend the current path for the device found.

      // TODO
      // Windows stores the current directories for 'other' drives
      // as hidden environment variables like =C:=c:\windows (literally)
      // var deviceCwd = os.getCwdForDrive(resolvedDevice);
      var deviceCwd = '';

      // If there is no cwd set for the drive, it is at root
      resolvedTail = deviceCwd + '\\' + resolvedTail;
      resolvedAbsolute = true;
    }

    // Replace slashes (in UNC share name) by backslashes
    resolvedDevice = resolvedDevice.replace(/\//g, '\\');

    // At this point the path should be resolved to a full absolute path,
    // but handle relative paths to be safe (might happen when process.cwd()
    // fails)

    // Normalize the tail path

    function f(p) {
      return !!p;
    }

    resolvedTail = normalizeArray(resolvedTail.split(/[\\\/]+/).filter(f),
                                  !resolvedAbsolute).join('\\');

    return (resolvedDevice + (resolvedAbsolute ? '\\' : '') + resolvedTail) ||
           '.';
  };

  // windows version
  exports.normalize = function(path) {
    var result = splitDeviceRe.exec(path),
        device = result[1] || '',
        isUnc = device && device.charAt(1) !== ':',
        isAbsolute = !!result[2] || isUnc, // UNC paths are always absolute
        tail = result[3],
        trailingSlash = /[\\\/]$/.test(tail);

    // Normalize the tail path
    tail = normalizeArray(tail.split(/[\\\/]+/).filter(function(p) {
      return !!p;
    }), !isAbsolute).join('\\');

    if (!tail && !isAbsolute) {
      tail = '.';
    }
    if (tail && trailingSlash) {
      tail += '\\';
    }

    return device + (isAbsolute ? '\\' : '') + tail;
  };

  // windows version
  exports.join = function() {
    function f(p) {
      return p && typeof p === 'string';
    }

    var paths = Array.prototype.slice.call(arguments, 0).filter(f);
    var joined = paths.join('\\');

    // Make sure that the joined path doesn't start with two slashes
    // - it will be mistaken for an unc path by normalize() -
    // unless the paths[0] also starts with two slashes
    if (/^[\\\/]{2}/.test(joined) && !/^[\\\/]{2}/.test(paths[0])) {
      joined = joined.slice(1);
    }

    return exports.normalize(joined);
  };


} else /* posix */ {

  // Regex to split a filename into [*, dir, basename, ext]
  // posix version
  var splitPathRe = /^(.+\/(?!$)|\/)?((?:.+?)?(\.[^.]*)?)$/;

  // path.resolve([from ...], to)
  // posix version
  exports.resolve = function() {
    var resolvedPath = '',
        resolvedAbsolute = false;

    for (var i = arguments.length; i >= -1 && !resolvedAbsolute; i--) {
      var path = (i >= 0)
          ? arguments[i]
          : process.cwd();

      // Skip empty and invalid entries
      if (typeof path !== 'string' || !path) {
        continue;
      }

      resolvedPath = path + '/' + resolvedPath;
      resolvedAbsolute = path.charAt(0) === '/';
    }

    // At this point the path should be resolved to a full absolute path, but
    // handle relative paths to be safe (might happen when process.cwd() fails)

    // Normalize the path
    resolvedPath = normalizeArray(resolvedPath.split('/').filter(function(p) {
      return !!p;
    }), !resolvedAbsolute).join('/');

    return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
  };

  // path.normalize(path)
  // posix version
  exports.normalize = function(path) {
    var isAbsolute = path.charAt(0) === '/',
        trailingSlash = path.slice(-1) === '/';

    // Normalize the path
    path = normalizeArray(path.split('/').filter(function(p) {
      return !!p;
    }), !isAbsolute).join('/');

    if (!path && !isAbsolute) {
      path = '.';
    }
    if (path && trailingSlash) {
      path += '/';
    }

    return (isAbsolute ? '/' : '') + path;
  };


  // posix version
  exports.join = function() {
    var paths = Array.prototype.slice.call(arguments, 0);
    return exports.normalize(paths.filter(function(p, index) {
      return p && typeof p === 'string';
    }).join('/'));
  };
}


exports.dirname = function(path) {
  var dir = splitPathRe.exec(path)[1] || '';
  if (!dir) {
    // No dirname
    return '.';
  } else if (dir.length === 1 ||
      (isWindows && dir.length <= 3 && dir.charAt(1) === ':')) {
    // It is just a slash or a drive letter with a slash
    return dir;
  } else {
    // It is a full dirname, strip trailing slash
    return dir.substring(0, dir.length - 1);
  }
};


exports.basename = function(path, ext) {
  var f = splitPathRe.exec(path)[2] || '';
  // TODO: make this comparison case-insensitive on windows?
  if (ext && f.substr(-1 * ext.length) === ext) {
    f = f.substr(0, f.length - ext.length);
  }
  return f;
};


exports.extname = function(path) {
  return splitPathRe.exec(path)[3] || '';
};


exports.exists = function(path, callback) {
  process.binding('fs').stat(path, function(err, stats) {
    if (callback) callback(err ? false : true);
  });
};


exports.existsSync = function(path) {
  try {
    process.binding('fs').stat(path);
    return true;
  } catch (e) {
    return false;
  }
};

}());

});

/*
 * Don't edit this file by hand!
 * This file was generated from a npm-package using gulp. 
 * For more information see gulpfile.js in the project root
 */
define('util/isBufferBrowser',['require','exports','module'],function (require, exports, module) {module.exports = function isBuffer(arg) {
  return arg && typeof arg === 'object'
    && typeof arg.copy === 'function'
    && typeof arg.fill === 'function'
    && typeof arg.readUInt8 === 'function';
}
});

/*
 * Don't edit this file by hand!
 * This file was generated from a npm-package using gulp. 
 * For more information see gulpfile.js in the project root
 */
define('inherits',['require','exports','module'],function (require, exports, module) {if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}

});

/*
 * Don't edit this file by hand!
 * This file was generated from a npm-package using gulp. 
 * For more information see gulpfile.js in the project root
 */
define('util/util',['require','exports','module','./isBufferBrowser','inherits'],function (require, exports, module) {// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};


// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function(fn, msg) {
  // Allow for deprecating things in the process of starting up.
  if (isUndefined(global.process)) {
    return function() {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  if (process.noDeprecation === true) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
};


var debugs = {};
var debugEnviron;
exports.debuglog = function(set) {
  if (isUndefined(debugEnviron))
    debugEnviron = process.env.NODE_DEBUG || '';
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
      var pid = process.pid;
      debugs[set] = function() {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function() {};
    }
  }
  return debugs[set];
};


/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  array.forEach(function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value)
      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = require('./isBufferBrowser');

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = require('inherits');

exports._extend = function(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

});

/*
 * Don't edit this file by hand!
 * This file was generated from a npm-package using gulp. 
 * For more information see gulpfile.js in the project root
 */
define('util-logging/level',['require','exports','module','util/util'],function (require, exports, module) {var util = require("util/util");

/**
 * This class represents a logging level.
 * @name Level
 * @param {object} [options] If provided, then both "name", and "value" fields must be given, otherwise it uses default values.
 * @param {String} [options.name="INFO"] Logging level name
 * @param {int} [options.value=4] Logging level value
 * @returns {Level}
 * @constructor
 */
var Level = function(options) {
  var self = this;
  (self.super_ = Level.super_).call(self);

  var options = options || {};

  if (options.name == undefined || options.value === undefined) {
    self._name = "INFO";
    self._value = 4;
    return self;
  }

  self._name = options.name;
  self._value = options.value;

  return self;
};

util.inherits(Level, Object);

/**
 * OFF is a special level that can be used to turn off logging.
 * @constant
 */
Level.OFF = new Level({"name": "OFF", "value": 7});
Level.prototype.OFF = Level.OFF;

/**
 * SEVERE is a message level indicating a serious failure.
 * @constant
 */
Level.SEVERE = new Level({"name": "SEVERE", "value": 6});
Level.prototype.SEVERE = Level.SEVERE;

/**
 * WARNING is a message level indicating a potential problem.
 * @constant
 */
Level.WARNING = new Level({"name":"WARNING", "value": 5});
Level.prototype.WARNING = Level.WARNING;

/**
 * INFO is a message level for informational messages.
 * @constant
 */
Level.INFO =  new Level({"name": "INFO", "value": 4});
Level.prototype.INFO = Level.INFO;

/**
 * CONFIG is a message level for static configuration messages.
 * @constant
 */
Level.CONFIG = new Level({"name": "CONFIG", "value": 3});
Level.prototype.CONFIG = Level.CONFIG;

/**
 * FINER indicates a fairly detailed tracing message.
 * @constant
 */
Level.FINE = new Level({"name": "FINE", "value": 2});
Level.prototype.FINE = Level.FINE;

/**
 * FINE is a message level providing tracing information.
 * @constant
 */
Level.FINER = new Level({"name": "FINER", "value": 1});
Level.prototype.FINER = Level.FINER;

/**
 * FINEST indicates a highly detailed tracing message.
 * @constant
 */
Level.FINEST = new Level({"name": "FINEST", "value": 0});
Level.prototype.FINEST = Level.FINEST;

/**
 * ALL indicates that all messages should be logged.
 * @constant
 */
Level.ALL = new Level({"name":"ALL", "value": 0});
Level.prototype.ALL = Level.ALL;



/**
 * This function returns the integer value associated with the level
 * @returns {Number}
 */
Level.prototype.intValue = function() {
  return this._value;
};


/**
 * This function returns the string name associated with the level
 * @returns {String}
 */
Level.prototype.getName = function() {
  return this._name;
};

/**
 * This function checks if the name, and int value of this {@link Level} object matches
 * the name and value of the given [level]{@link Level} object.
 * @param {Level} level The {@link Level} object to compare against
 * @returns {boolean}
 * {@linkcode true} if equal
 * {@linkcode false} if not equal
 */
Level.prototype.equals = function(level) {
  if (!(level instanceof  Level)) {
    return false;
  }
  return (this.intValue() == level.intValue());
};



/**
 * This function compares the int value of this {@link Level} object against the
 * the int value of the given [level]{@link Level} object.
 * @param {Level} level The {@link Level} object to compare against
 * @returns {number | undefined}
 * {@linkcode <0} If this {@link Level} object's int value is less <br />
 * {@linkcode =0} If this {@link Level} object's int value is the same <br />
 * {@linkcode >0} If this {@link Level} object's int value is greater <br />
 * {@linkcode undefined} if the argument is not of {@link Level} type
 */
Level.prototype.compare = function(level) {
  if (!(level instanceof Level)) {
    return undefined;
  }

  var intA = this.intValue();
  var intB = level.intValue();

  if (intA == intB) {
    return 0;
  }

  if (intA > intB) {
    return 1;
  }

  if (intA <  intB) {
    return -1;
  }
};

Level.prototype.toString = function() {
  return this.getName();
};


Level.isValid =  function(level) {
  if (!level || !(level instanceof Level)) {
    return false;
  }
  return typeof (level instanceof Level) &&
      (level.intValue() >= Level.ALL.intValue() || level <= Level.OFF.intValue());
};


Level.prototype.isValid = function() {
  return Level.isValid(this);
};

module.exports = Level;

});

/*
 * Don't edit this file by hand!
 * This file was generated from a npm-package using gulp. 
 * For more information see gulpfile.js in the project root
 */
define('util-logging/logrecord',['require','exports','module','./level','util/util'],function (require, exports, module) {


var Level = require("./level");
var util = require("util/util");

/**
 * This class is equivalent to java.util.logging.LogRecord
 * @name LogRecord
 * @param {object} [options] Options used to initialize this {@link LogRecord}
 * @param {Level} [options.level=Level.INFO] logging {@link Level}
 * @param {string} [options.message=null] message string
 * @param {number} [options.millis=new Date().getTime()] time in milliseconds
 * @param {string} [options.loggerName=null] logger name
 * @param {Array} [options.parameters=null] {@link Array} of parameters
 * @param {Error} [options.thrown=null] {@link Error} object
 * @param {string} [options.sourceMethodName=null] source method name
 * @param {string} [options.sourceFileName=null] source file name
 * @constructor
 *
 */
var LogRecord = function(options) {
  var self = this;
  (self.super_ = LogRecord.super_).call(self);

  options = options || {};

  self._sourceStack = options._sourceStack || null;

  self._level = options.level || Level.INFO;
  self._message = options.message || null;
  self._millis = options.millis || (new Date()).getTime();
  self._loggerName = options.loggerName || null;
  self._parameters = options.parameters || null;
  self._thrown = options.thrown || null;
  self._sourceMethodName = options._sourceMethodName || null;
  self._sourceFileName = options._sourceFileName || null;

  return self;
};

util.inherits(LogRecord, Object);



/**
 * Sets the logging {@link Level} associated with this {@link LogRecord}
 * @param {Level} level Logging level
 * @returns {LogRecord}
 */
LogRecord.prototype.setLevel = function(level) {
  this._level = level;
  return this;
};

/**
 * Retrieves the logging {@link Level} associated with this {@link LogRecord}
 * @returns {Level}
 */
LogRecord.prototype.getLevel = function() {
  return this._level;
};

/**
 * Sets the message associated with this {@link LogRecord}
 * @param {string} message Message string
 * @returns {LogRecord}
 */
LogRecord.prototype.setMessage = function(message) {
  this._message = message;
  return this;
};

/**
 * Retrieves the message associated with this {@link LogRecord}
 * @returns {string}
 */
LogRecord.prototype.getMessage = function() {
  return this._message;
};

/**
 * Sets the time (in milliseconds) associated with this {@link LogRecord}
 * @param {number} millis Time in milliseconds
 * @returns {LogRecord}
 */
LogRecord.prototype.setMillis = function(millis) {
  this._millis = millis;
};

/**
 * Retrieves the time (in milliseconds) associated with this {@link LogRecord}
 * @returns {number}
 */
LogRecord.prototype.getMillis = function() {
  return this._millis;
};

/**
 * Sets the logger name associated with this {@link LogRecord}
 * @param {string} loggerName Logger name
 * @returns {LogRecord}
 */
LogRecord.prototype.setLoggerName = function(loggerName) {
  this._loggerName = loggerName;
  return this;
};

/**
 * Retrieves the logger name associated with this {@link LogRecord}
 * @returns {String}
 */
LogRecord.prototype.getLoggerName = function() {
  return this._loggerName;
};

/**
 * Sets the parameters array associated with this {@link LogRecord}
 * @param {Array} parameters Array of parameters
 * @returns {LogRecord}
 */
LogRecord.prototype.setParameters = function(parameters) {
  this._parameters = parameters;
  return this;
};

/**
 * Retrieves the parameters array associated with this {@link LogRecord}
 * @returns {Array}
 */
LogRecord.prototype.getParameters = function() {
  return this._parameters;
};

/**
 * Sets the thrown {@link Error} associated with this {@link LogRecord}
 * @param {Error} thrown Error object
 * @returns {LogRecord}
 */
LogRecord.prototype.setThrown = function(thrown) {
  if (!util.isError(thrown)) {
    return this;
  }

  this._thrown = thrown;

  return this;
};

/**
 * Retrieves the thrown {@link Error} associated with this {@link LogRecord}
 * @returns {Error}
 */
LogRecord.prototype.getThrown = function() {
  return this._thrown;
};

/**
 * Sets the source method name associated with this {@link LogRecord}
 * @param {string} methodName Method name
 * @returns {LogRecord}
 */
LogRecord.prototype.setSourceMethodName = function(methodName) {
  this._sourceMethodName = methodName;
  return this;
};

/**
 * Retrieves the source method name associated with this {@link LogRecord}
 * @returns {string}
 */
LogRecord.prototype.getSourceMethodName = function() {
  return this._sourceMethodName;
};

/**
 * Sets the source file name associated with this {@link LogRecord}
 * @param {string} fileName File name
 * @returns {LogRecord}
 */
LogRecord.prototype.setSourceFileName = function(fileName) {
  this._sourceFileName = fileName
  return this;
};

/**
 * Retrieves the source file name associated with this {@link LogRecord}
 * @return {String}
 */
LogRecord.prototype.getSourceFileName = function() {
  return this._sourceFileName;
};



LogRecord.prototype.setSourceStackFrame = function(sourceStack) {
  this._sourceStack = sourceStack
};


LogRecord.prototype.getSourceStackFrame = function() {
  return this._sourceStack;
};

module.exports = LogRecord;
});

/*
 * Don't edit this file by hand!
 * This file was generated from a npm-package using gulp. 
 * For more information see gulpfile.js in the project root
 */
define('util-logging/handler',['require','exports','module','./level','./logrecord','util/util'],function (require, exports, module) {

var Level = require("./level");
var LogRecord = require("./logrecord");

var util = require("util/util");

/**
 * This class is equivalent to java.util.logging.Handler.
 *
 * It stores all the pushed {@link LogRecord} objects in memory, until flushed.
 *
 * @name Handler
 * @returns {Handler}
 * @constructor
 */
var Handler = function() {
  var self = this;
  (self.super_ = Handler.super_).call(self);
  self._level = Level.FINEST;
  self._formatter = undefined;
  self._logRecords = [];
  return self;
};


util.inherits(Handler, Object);
/**
 * Sets the logging {@link Level} for this {@link Handler}
 * @param {Level} level Logging level
 * @returns {Handler}
 */
Handler.prototype.setLevel = function(level) {
  if (!Level.isValid(level)) {
    return this;
  }
  this._level = level;
  return this;
};

/**
 * Retrieves the logging {@link Level} for this {@link Handler}
 * @returns {Level}
 */
Handler.prototype.getLevel = function() {
  return this._level;
};

/**
 * Checks if the specified {@link LogRecord} object can be logged given the current logging {@link Level} of this {@link Handler}
 * @param {LogRecord} logRecord {@link LogRecord} to be checked
 * @returns {boolean}
 * {@Linkcode true} if the {@link LogRecord} can be logged <br />
 * {@linkcode false} if the {@link LogRecord} cannot be logged
 */
Handler.prototype.isLoggable = function(logRecord) {
  if (!logRecord || !(logRecord instanceof  LogRecord)) {
    return false;
  }

  var level = logRecord.getLevel();

  return Level.isValid(level) && level >= this.getLevel();
};

/**
 * This function stores the given {@link LogRecord} object internally in memory. <br />
 * <br />
 * Note that this function will not print the record. If you want to actually do something useful
 * with the {@link LogRecord} object, you must extend this class, and override this method. <br />
 * <br />
 * {@link ConsoleHandler} is an example of a class that extends this class.
 *
 * @param {LogRecord} logRecord {@link LogRecord} to be published
 * @returns {Handler}
 */
Handler.prototype.publish = function(logRecord) {
  if (!this.isLoggable(logRecord)) {
    return this;
  }
  //default-handler, store records in memory
  this._logRecords.push(logRecord);
  return this;
};

/**
 * This function clears the internal array of log records.
 * @returns {Handler}
 *
 */
Handler.prototype.flush = function() {
  this._logRecords = [];
  return this;
};

/**
 * This function sets the {@link Formatter} to use for this {@link LogRecord} {@link Handler}
 * @param {Formatter} formatter The {@link Formatter} object
 * @returns {Handler}
 */
Handler.prototype.setFormatter = function(formatter) {
  this._formatter = formatter;
  return this;
};

/**
 * This function retrieves the {@link Formatter} for this {@link LogRecord} {@link Handler}
 * @returns {Formatter}
 */
Handler.prototype.getFormatter = function() {
  return this._formatter;
};


module.exports = Handler;
});

/*
 * Don't edit this file by hand!
 * This file was generated from a npm-package using gulp. 
 * For more information see gulpfile.js in the project root
 */
define('util-logging/logger',['require','exports','module','path','util/util','./level','./handler','./logrecord'],function (require, exports, module) {


var path = require("path");
var util = require("util/util");
var Level = require("./level");
var Handler = require("./handler");
var LogRecord = require("./logrecord");

/**
 * This class is the equivalent of java.util.logging.Logger
 * @name Logger
 * @param {object} [options]
 * @param {String} [options.name=null] Name to describe this logger
 * @param {Level} [options.level=Level.SEVERE] Default logging level
 *
 * @returns {Logger}
 * @constructor
 */
var Logger = function(options) {
  var self = this;
  (self.super_ = Logger.super_).call(self);

  var options = options || {};
  this._level = (Level.isValid(options.level))? options.level: Level.SEVERE;
  this._name = options.name;

  this._handlers = [];
  return this;
};

util.inherits(Logger, Object);

var fillStackInfo = function(/** LogRecord */ record) {
  var orig = Error.prepareStackTrace;
  try {
    var err = new Error();
    var caller;

    Error.prepareStackTrace = function (err, stack) {
      return stack;
    };

    var parentFrame = err.stack.shift();
    var current = parentFrame.getFileName();
    while (err.stack.length) {
      var currentFrame = err.stack.shift();
      caller = currentFrame.getFileName();
      if(current!==caller) {
        var info = currentFrame.toString();
        record.setSourceFileName(currentFrame.getFileName());
        record.setSourceMethodName(currentFrame.getMethodName());
        record.setSourceStackFrame(currentFrame);
        return info;
      }
    }
  } catch (err) {}
  finally {
    Error.prepareStackTrace = orig;
  }
  return undefined;
};


/**
 * Sets the logging {@link Level} for this {@link Logger}
 * @param {Level} level Logging level
 *
 * @returns {Logger}
 */
Logger.prototype.setLevel = function(level) {
  if (!Level.isValid(level)) {
    return this;
  }

  this._level = level;
  return this;
};

/**
 * Retrieves the logging {@link Level} for this {@link Logger}
 * @returns {Level} Logging level
 */
Logger.prototype.getLevel = function() {
  return this._level;
};

/**
 * Set the name of the logger
 * @param {string} name Logger name
 * @returns {Logger}
 */
Logger.prototype.setName = function(name) {
  if (!name || typeof "name" !== "string") {
    return this;
  }

  this._name = name;
  return this;
};

/**
 * Retrieves the name of the logger
 * @returns {string} Logger name
 */
Logger.prototype.getName = function() {
  return this._name;
};

/**
 * Adds a handler to the the logger
 * @param {Handler} handler The {@link Handler} to add
 * @returns {Logger}
 */
Logger.prototype.addHandler = function(handler) {
  if (!handler || !(handler instanceof  Handler)) {
    return this;
  }
  this._handlers.push(handler);
  return this;
};

/**
 * Removes the specified handler from the logger
 * @param {Handler} handler The {@link Handler} to remove
 * @returns {Logger}
 */
Logger.prototype.removeHandler = function(handler) {
  if (!handler || !(handler instanceof  Handler)) {
    return this;
  }

  var index = this._handlers.indexOf(handler);
  if (index < 0) {
    return this;
  }

  this._handlers.splice(index,1);
  return this;
};

/**
 * Retrieves the {@link Handler}s associated with the {@link Logger}
 * @returns {Array}
 */
Logger.prototype.getHandlers =  function() {
  return  this._handlers;
};


/**
 * Logs the given {@linkcode message} at the specified {@linkcode level}
 * @param {Level} level Logging level
 * @param {string} message Message to log
 *
 * @returns {Logger}
 */
Logger.prototype.log = function() {};
/**
 * Logs the given {@linkcode message}, and error at the specified {@linkcode level}
 * @param {Level} level Logging level
 * @param {string} message Message to log
 * @param {Error} error Error object to log
 *
 * @returns {Logger}
 */
Logger.prototype.log = function() {};
/**
 * Logs the formatted message ({@linkcode format}), with the given {@linkcode params}
 * array as input to the {@linkcode format}, at the specified {@linkcode level}
 * @param {Level} level Logging level
 * @param {string} format Format to use for the message
 * @param {...*} params Variable number of parameters as input to the {@linkcode format}
 *
 * @returns {Logger}
 */
/**
 * Logs the given {@linkcode object}, at the specified {@linkcode level}
 * @param {Level} level Logging level
 * @param {object} object Object to log
 *
 * @returns {Logger}
 */
Logger.prototype.log = function() {};
Logger.prototype.log = function() {};
/**
 * Logs the formatted message ({@linkcode format}), with the given variable {@linkcode params}
 * as input to the {@linkcode format}, at the specified {@linkcode level}
 * @param {Level} level Logging level
 * @param {string} format Format to use for the message
 * @param {...*} params Variable number of parameters as input to the {@linkcode format}
 *
 * @returns {Logger}
 */
Logger.prototype.log = function() {

  var args = Array.prototype.splice.call(arguments,0);

  if (args.length < 2) {
    return this;
  }

  var level = args.shift();
  var message = args.shift();
  var thrown;
  var parameters = [];

  if (util.isError(message) && args.length == 0) {
    thrown = message;
    message = "";
  }

  else if (args.length == 1 && util.isError(args[0])) {
    thrown = args[0];
  }
  else if (args.length == 1 && args[0] instanceof Array) {
    parameters = args[0];
  }
  else {
    parameters = args;
  }


  if (!Level.isValid(level) || message === undefined) {
    return this;
  }

  var handlers = this.getHandlers();

  if (level < this.getLevel()) {
    return this;
  }

  var logRecord = new LogRecord();
  logRecord.setLevel(level);
  logRecord.setLoggerName(this.getName());
  logRecord.setMessage(message);
  logRecord.setMillis(new Date().getTime());
  logRecord.setParameters(parameters);
  logRecord.setThrown(thrown);
  fillStackInfo(logRecord);

  handlers.forEach(function(handler) {
    handler.publish(logRecord);
  });

  return this;
};


Logger.prototype._log = function(level, args) {
  args = Array.prototype.splice.call(args, 0);
  args.unshift(level);
  this.log.apply(this, args);
  return this;
};


/**
 * Logs the given message, at {@linkCode Level.SEVERE} level
 * @param {string} message Message to log
 * @returns {Logger}
 */
Logger.prototype.severe =  function() {};
/**
 * Logs the given formatted message ({@linkcode format}) using the variable {@linkcode params} as input,
 * at {@linkCode Level.SEVERE} level
 * @param {string} format Format to use for the message
 * @param {...*} params Variable number of parameters as input to the {@linkcode format}
 * @returns {Logger}
 */
Logger.prototype.severe =  function() {};
/**
 * Logs the given {@linkcode object}, at {@linkCode Level.SEVERE} level
 * @param {object} object Object to log
 *
 * @returns {Logger}
 */
Logger.prototype.severe = function() {};
/**
 * Logs the given message, and error at {@linkCode Level.SEVERE} level
 * @param {string} message Message to log
 * @param {Error} error Error object to log
 * @returns {Logger}
 */
Logger.prototype.severe =  function() {
  return this._log(Level.SEVERE, arguments);
};

/**
 * Logs the given message, at {@linkCode Level.WARNING} level
 * @param {string} message Message to log
 * @returns {Logger}
 */
Logger.prototype.warning =  function() {};
/**
 * Logs the given formatted message ({@linkcode format}) using the variable {@linkcode params} as input,
 * at {@linkCode Level.WARNING} level
 * @param {string} format Format to use for the message
 * @param {...*} params Variable number of parameters as input to the {@linkcode format}
 * @returns {Logger}
 */
Logger.prototype.warning =  function() {};
/**
 * Logs the given {@linkcode object}, at {@linkCode Level.WARNING} level
 * @param {object} object Object to log
 *
 * @returns {Logger}
 */
Logger.prototype.warning =  function() {};

/**
 * Logs the given message, and error at {@linkCode Level.WARNING} level
 * @param {string} message Message to log
 * @param {Error} error Error object to log
 * @returns {Logger}
 */
Logger.prototype.warning =  function() {
  return this._log(Level.WARNING, arguments);
};

/**
 * Logs the given message, at {@linkCode Level.CONFIG} level
 * @param {string} message Message to log
 * @returns {Logger}
 */
Logger.prototype.config =  function() {};
/**
 * Logs the given formatted message ({@linkcode format}) using the variable {@linkcode params} as input,
 * at {@link Level.CONFIG} level
 * @param {string} format Format to use for the message
 * @param {...*} params Variable number of parameters as input to the {@linkcode format}
 * @returns {Logger}
 */
Logger.prototype.config =  function() {};
/**
 * Logs the given {@linkcode object}, at {@linkCode Level.CONFIG} level
 * @param {object} object Object to log
 *
 * @returns {Logger}
 */
Logger.prototype.config =  function() {};
/**
 * Logs the given message, and error at {@linkCode Level.CONFIG} level
 * @param {string} message Message to log
 * @param {Error} error Error object to log
 * @returns {Logger}
 */
Logger.prototype.config =  function() {
  return this._log(Level.CONFIG, arguments);
};

/**
 * Logs the given message, at {@linkCode Level.INFO} level
 * @param {string} message Message to log
 * @returns {Logger}
 */
Logger.prototype.info =  function() {}
/**
 * Logs the given formatted message ({@linkcode format}) using the variable {@linkcode params} as input,
 * at {@linkCode Level.INFO} level
 * @param {string} format Format to use for the message
 * @param {...*} params Variable number of parameters as input to the {@linkcode format}
 * @returns {Logger}
 */
Logger.prototype.info =  function() {}
/**
 * Logs the given {@linkcode object}, at {@linkCode Level.INFO} level
 * @param {object} object Object to log
 *
 * @returns {Logger}
 */
Logger.prototype.info =  function() {};
/**
 * Logs the given message, and error at {@linkCode Level.INFO} level
 * @param {string} message Message to log
 * @param {Error} error Error object to log
 * @returns {Logger}
 */
Logger.prototype.info =  function() {
  return this._log(Level.INFO, arguments);
};

/**
 * Logs the given message, at {@linkCode Level.FINE} level
 * @param {string} message Message to log
 * @returns {Logger}
 */
Logger.prototype.fine =  function() {}
/**
 * Logs the given formatted message ({@linkcode format}) using the variable {@linkcode params} as input,
 * at {@linkCode Level.FINE} level
 * @param {string} format Format to use for the message
 * @param {...*} params Variable number of parameters as input to the {@linkcode format}
 * @returns {Logger}
 */
Logger.prototype.fine =  function() {}
/**
 * Logs the given {@linkcode object}, at {@linkCode Level.FINE} level
 * @param {object} object Object to log
 *
 * @returns {Logger}
 */
Logger.prototype.fine =  function() {};
/**
 * Logs the given message, and error at {@linkCode Level.FINE} level
 * @param {string} message Message to log
 * @param {Error} error Error object to log
 * @returns {Logger}
 */
Logger.prototype.fine =  function() {
  return this._log(Level.FINE, arguments);
};

/**
 * Logs the given message, at {@linkCode Level.FINER} level
 * @param {string} message Message to log
 * @returns {Logger}
 */
Logger.prototype.finer =  function() {}
/**
 * Logs the given formatted message ({@linkcode format}) using the variable {@linkcode params} as input,
 * at {@linkCode Level.FINER} level
 * @param {string} format Format to use for the message
 * @param {...*} params Variable number of parameters as input to the {@linkcode format}
 * @returns {Logger}
 */
Logger.prototype.finer =  function() {}
/**
 * Logs the given {@linkcode object}, at {@linkCode Level.FINER} level
 * @param {object} object Object to log
 *
 * @returns {Logger}
 */
Logger.prototype.finer =  function() {};
/**
 * Logs the given message, and error at {@linkCode Level.FINER} level
 * @param {string} message Message to log
 * @param {Error} error Error object to log
 * @returns {Logger}
 */
Logger.prototype.finer =  function() {
  return this._log(Level.FINER, arguments);
};



/**
 * Logs the given message, at {@linkCode Level.FINEST} level
 * @param {string} message Message to log
 * @returns {Logger}
 */
Logger.prototype.finest = function() {};
/**
 * Logs the given formatted message ({@linkcode format}) using the variable {@linkcode params} as input,
 * at {@link Level.FINEST} level
 * @param {string} format Format to use for the message
 * @param {...*} params Variable number of parameters as input to the {@linkcode format}
 * @returns {Logger}
 */
Logger.prototype.finest = function() {};
/**
 * Logs the given {@linkcode object}, at {@linkCode Level.FINEST} level
 * @param {object} object Object to log
 *
 * @returns {Logger}
 */
Logger.prototype.finest =  function() {};
/**
 * Logs the given message, and error at {@linkCode Level.FINEST} level
 * @param {string} message
 * @param {Error} error Error object to log
 * @returns {Logger}
 */
Logger.prototype.finest =  function() {
  return this._log(Level.FINEST, arguments);
};

module.exports = Logger;


});

/*
 * Don't edit this file by hand!
 * This file was generated from a npm-package using gulp. 
 * For more information see gulpfile.js in the project root
 */
define('util-logging/formatter',['require','exports','module','util/util','./logrecord','./level','path'],function (require, exports, module) {

var util = require("util/util");
var LogRecord = require("./logrecord");
var Level = require("./level");
var path = require("path");


/**
 * This class us equivalent to java.util.logging.Formatter. <br />
 * <br />
 * It provides support for formatting LogRecord objects.
 *
 * @name Formatter
 * @constructor
 */
var Formatter = function() {
  var self = this;
  (self.super_ = Formatter.super_).call(self);
  return self;
};

util.inherits(Formatter, Object);


/**
 * This function formats a {@link LogRecord} object as follows:<br />
 * <br />
 * <pre>
 * {datetime} - [{logger-name}] [{level}] [{stack-location}] - {formatted-params}
 * </pre>
 * <br />
 * Internally it makes use of Node.js [util.format]{@link http://nodejs.org/api/util.html#util_util_format_format} to create the {formatted-params} section.
 *
 * @param  {LogRecord} logRecord Record to be formatted
 */
Formatter.prototype.formatMessage = function(logRecord) {
  if (!logRecord || !(logRecord instanceof  LogRecord)) {
    return;
  }


  var message = logRecord.getMessage() || "";

  //log errors as strings
  if (util.isError(message)) {
    message =  message.message || message.toString();
  }

  //for the message to be a string
  if (typeof message !== "string") {
    message = "\n" + JSON.stringify(message, null, 2);
  }

  var millis = logRecord.getMillis();
  var date = new Date();
  if (millis && (typeof  millis === "number")){
    date.setTime(millis);
  }

  var level = logRecord.getLevel();
  var levelName = (level)? level.getName():undefined;
  var loggerName = logRecord.getLoggerName();


  var prefix =  date.toISOString() + " - [" + levelName + "] ";
  if (levelName && typeof loggerName == "string") {
    prefix = prefix +   "[" + loggerName + "] ";
  }

  var stack =  logRecord.getSourceStackFrame();
  if (stack) {
    var actualFile = stack.getFileName();
    var baseFile = path.basename(actualFile);
    var info = stack.toString();
    info = info.replace(actualFile, baseFile);
    prefix = prefix + "[" + info + "] ";
  }

  var parameters = logRecord.getParameters();
  if (parameters &&  parameters instanceof Array) {
    parameters.unshift(message);
    message = util.format.apply(this, parameters);
    parameters.shift();
  }

  message = prefix + message;

  var thrown = logRecord.getThrown();
  if (thrown && util.isError(thrown)) {

    if (thrown.message) {
      message += thrown.message;
    }

    if (thrown.stack) {
      message += "\n" + thrown .stack;
    }
  }

  return message;
};

module.exports = Formatter;
});

/*
 * Don't edit this file by hand!
 * This file was generated from a npm-package using gulp. 
 * For more information see gulpfile.js in the project root
 */
define('util-logging/consolehandler',['require','exports','module','./level','./handler','./formatter','util/util'],function (require, exports, module) {

var Level = require("./level");
var Handler = require("./handler");
var Formatter = require("./formatter");

var util = require("util/util");

/**
 * This class is equivalent to java.util.logging.ConsoleHandler. <br />
 * <br />
 * The published {@link LogRecord} objects are printed using Node.js [console.log]{@link http://nodejs.org/api/stdio.html#stdio_console_log_data} function.
 * <br />
 * Internally, the {@link ConsoleHandler} uses the {@link Formatter} class to generate the string.
 *
 * @name ConsoleHandler
 * @returns {ConsoleHandler}
 * @constructor
 * @extends Handler
 */
var ConsoleHandler =  function() {
  var self = this;
  (self.super_ = ConsoleHandler.super_).call(self);
  this._defaultFormatter = new Formatter();
  return this;
};

util.inherits(ConsoleHandler, Handler);


ConsoleHandler.prototype.getDefaultFormatter = function() {
  return this._defaultFormatter;
};

/**
 * Prints a formatted log record to the console using  console.log.
 *
 * @param {LogRecord} logRecord {@link LogRecord} to be published
 */
ConsoleHandler.prototype.publish = function(logRecord) {
  if (!this.isLoggable(logRecord)) {
    return;
  }

  var formatter = this.getFormatter();
  if (!formatter || !(formatter instanceof Formatter)) {
    formatter = this.getDefaultFormatter();
  }

  var message = formatter.formatMessage(logRecord);
  if (!message || typeof message !== "string") {
    return;
  }

  console.log(message);
};


module.exports = ConsoleHandler;

});

/*
 * Don't edit this file by hand!
 * This file was generated from a npm-package using gulp. 
 * For more information see gulpfile.js in the project root
 */
define('util-logging/consolelogger',['require','exports','module','./logger','./consolehandler','./level','util/util'],function (require, exports, module) {


var Logger = require("./logger");
var ConsoleHandler = require("./consolehandler");
var Level = require("./level");
var util = require("util/util");

/**
 * This is a sample class that makes use of the of both {@link ConsoleHandler}, and {@link Logger}
 * to create a logger that prints messages to the console.
 *
 * @name ConsoleLogger
 * @param  {object} [options] Optional arguments to build the logger. See the parent class [constructor]{@link Logger} for more details.
 * @returns {ConsoleLogger}
 * @constructor
 * @extends Logger
 */
var ConsoleLogger = function(options) {
  var self = this;
  (self.super_ = ConsoleLogger.super_).call(self, options);

  var handler = new ConsoleHandler();
  handler.setLevel(Level.FINEST);
  self.addHandler(handler);
  self.setLevel(Level.SEVERE);
  return this;
};

util.inherits(ConsoleLogger, Logger);


module.exports = ConsoleLogger;
});

/*
 * Don't edit this file by hand!
 * This file was generated from a npm-package using gulp. 
 * For more information see gulpfile.js in the project root
 */
define('util-logging/util-logging',['require','exports','module','./logger','./level','./consolehandler','./consolelogger','./handler','./logrecord','./formatter'],function (require, exports, module) {

/**
 * This module exports all the classes that make up the util-logging package.
 * @module util-logging
 * @exports LogRecord
 * @exports Logger
 */
module.exports = {
  /**
   * {@link Logger} class
   */
  "Logger" :  require("./logger"),
  /**
   * {@link Level} class
   */
  "Level" : require("./level"),
  /**
   * {@link ConsoleHandler} class
   */
  "ConsoleHandler" : require("./consolehandler"),
  /**
   * {@link ConsoleLogger} class
   */
  "ConsoleLogger" : require("./consolelogger"),
  /**
   * {@link Handler} class
   */
  "Handler" :  require("./handler"),
  /**
   * {@link LogRecord} class
   */
  "LogRecord" : require("./logrecord"),
  /**
   * @{link Formatter} class
   */
  "Formatter": require("./formatter")
}

});

define('logging/callbackhandler',['require','exports','module','util-logging/level','util-logging/handler','util-logging/formatter','util/util'],function (require, exports, module) {


var Level = require("util-logging/level");
var Handler = require("util-logging/handler");
var Formatter = require("util-logging/formatter");

var util = require("util/util");

/**
 * The published {@link LogRecord} objects are fed to a callback
 *
 * Internally, the {@link CallbackHandler} uses the {@link Formatter} class to generate the string.
 *
 * @name CallbackHandler
 * @param cb callback to pass each formatted log entry to
 * @returns {CallbackHandler}
 * @constructor
 * @extends Handler
 */
var CallbackHandler = function(cb) {
  var self = this;
  (self.super_ = CallbackHandler.super_).call(self);
  self._defaultFormatter = new Formatter();
  self._callback = cb;
  return self;
};

util.inherits(CallbackHandler, Handler);


CallbackHandler.prototype.getDefaultFormatter = function() {
  return this._defaultFormatter;
};

/**
 * Logs formatted log record to a file.
 *
 * @param {LogRecord} logRecord {@link LogRecord} to be published
 */
CallbackHandler.prototype.publish = function(logRecord) {
  if (!this.isLoggable(logRecord)) {
    return;
  }

  var formatter = this.getFormatter();
  if (!formatter || !(formatter instanceof Formatter)) {
    formatter = this.getDefaultFormatter();
  }

  var message = formatter.formatMessage(logRecord);
  if (!message || typeof message !== "string") {
    return;
  }

  this._callback(message);
};


module.exports = CallbackHandler;
});

/* js-yaml 3.2.0 https://github.com/nodeca/js-yaml */
!function(e){if("object"==typeof exports&&"undefined"!=typeof module)module.exports=e();else if("function"==typeof define&&define.amd)define('yaml',[],e);else{var t;"undefined"!=typeof window?t=window:"undefined"!=typeof global?t=global:"undefined"!=typeof self&&(t=self),t.jsyaml=e()}}(function(){return function e(t,n,i){function r(a,s){if(!n[a]){if(!t[a]){var c="function"==typeof require&&require;if(!s&&c)return c(a,!0);if(o)return o(a,!0);throw new Error("Cannot find module '"+a+"'")}var u=n[a]={exports:{}};t[a][0].call(u.exports,function(e){var n=t[a][1][e];return r(n?n:e)},u,u.exports,e,t,n,i)}return n[a].exports}for(var o="function"==typeof require&&require,a=0;a<i.length;a++)r(i[a]);return r}({1:[function(e,t){var n=e("./lib/js-yaml.js");t.exports=n},{"./lib/js-yaml.js":2}],2:[function(e,t){function n(e){return function(){throw new Error("Function "+e+" is deprecated and cannot be used.")}}var i=e("./js-yaml/loader"),r=e("./js-yaml/dumper");t.exports.Type=e("./js-yaml/type"),t.exports.Schema=e("./js-yaml/schema"),t.exports.FAILSAFE_SCHEMA=e("./js-yaml/schema/failsafe"),t.exports.JSON_SCHEMA=e("./js-yaml/schema/json"),t.exports.CORE_SCHEMA=e("./js-yaml/schema/core"),t.exports.DEFAULT_SAFE_SCHEMA=e("./js-yaml/schema/default_safe"),t.exports.DEFAULT_FULL_SCHEMA=e("./js-yaml/schema/default_full"),t.exports.load=i.load,t.exports.loadAll=i.loadAll,t.exports.safeLoad=i.safeLoad,t.exports.safeLoadAll=i.safeLoadAll,t.exports.dump=r.dump,t.exports.safeDump=r.safeDump,t.exports.YAMLException=e("./js-yaml/exception"),t.exports.MINIMAL_SCHEMA=e("./js-yaml/schema/failsafe"),t.exports.SAFE_SCHEMA=e("./js-yaml/schema/default_safe"),t.exports.DEFAULT_SCHEMA=e("./js-yaml/schema/default_full"),t.exports.scan=n("scan"),t.exports.parse=n("parse"),t.exports.compose=n("compose"),t.exports.addConstructor=n("addConstructor")},{"./js-yaml/dumper":4,"./js-yaml/exception":5,"./js-yaml/loader":6,"./js-yaml/schema":8,"./js-yaml/schema/core":9,"./js-yaml/schema/default_full":10,"./js-yaml/schema/default_safe":11,"./js-yaml/schema/failsafe":12,"./js-yaml/schema/json":13,"./js-yaml/type":14}],3:[function(e,t){function n(e){return void 0===e||null===e}function i(e){return"object"==typeof e&&null!==e}function r(e){return Array.isArray(e)?e:n(e)?[]:[e]}function o(e,t){var n,i,r,o;if(t)for(o=Object.keys(t),n=0,i=o.length;i>n;n+=1)r=o[n],e[r]=t[r];return e}function a(e,t){var n,i="";for(n=0;t>n;n+=1)i+=e;return i}function s(e){return 0===e&&Number.NEGATIVE_INFINITY===1/e}t.exports.isNothing=n,t.exports.isObject=i,t.exports.toArray=r,t.exports.repeat=a,t.exports.isNegativeZero=s,t.exports.extend=o},{}],4:[function(e,t){function n(e,t){var n,i,r,o,a,s,c;if(null===t)return{};for(n={},i=Object.keys(t),r=0,o=i.length;o>r;r+=1)a=i[r],s=String(t[a]),"!!"===a.slice(0,2)&&(a="tag:yaml.org,2002:"+a.slice(2)),c=e.compiledTypeMap[a],c&&b.call(c.styleAliases,s)&&(s=c.styleAliases[s]),n[a]=s;return n}function i(e){var t,n,i;if(t=e.toString(16).toUpperCase(),255>=e)n="x",i=2;else if(65535>=e)n="u",i=4;else{if(!(4294967295>=e))throw new y("code point within a string may not be greater than 0xFFFFFFFF");n="U",i=8}return"\\"+n+g.repeat("0",i-t.length)+t}function r(e){this.schema=e.schema||x,this.indent=Math.max(1,e.indent||2),this.skipInvalid=e.skipInvalid||!1,this.flowLevel=g.isNothing(e.flowLevel)?-1:e.flowLevel,this.styleMap=n(this.schema,e.styles||null),this.implicitTypes=this.schema.compiledImplicit,this.explicitTypes=this.schema.compiledExplicit,this.tag=null,this.result=""}function o(e,t){return"\n"+g.repeat(" ",e.indent*t)}function a(e,t){var n,i,r;for(n=0,i=e.implicitTypes.length;i>n;n+=1)if(r=e.implicitTypes[n],r.resolve(t))return!0;return!1}function s(e,t){var n,r,o,s,c,u;for(e.dump="",n=!1,r=0,u=t.charCodeAt(0)||0,-1!==V.indexOf(t)?n=!0:0===t.length?n=!0:j===u||j===t.charCodeAt(t.length-1)?n=!0:(_===u||q===u)&&(n=!0),o=0,s=t.length;s>o;o+=1)c=t.charCodeAt(o),n||(w===c||C===c||k===c||L===c||D===c||P===c||H===c||B===c||E===c||F===c||T===c||I===c||$===c||Y===c||N===c||S===c||O===c||U===c||M===c||R===c)&&(n=!0),(G[c]||!(c>=32&&126>=c||133===c||c>=160&&55295>=c||c>=57344&&65533>=c||c>=65536&&1114111>=c))&&(e.dump+=t.slice(r,o),e.dump+=G[c]||i(c),r=o+1,n=!0);o>r&&(e.dump+=t.slice(r,o)),!n&&a(e,e.dump)&&(n=!0),n&&(e.dump='"'+e.dump+'"')}function c(e,t,n){var i,r,o="",a=e.tag;for(i=0,r=n.length;r>i;i+=1)d(e,t,n[i],!1,!1)&&(0!==i&&(o+=", "),o+=e.dump);e.tag=a,e.dump="["+o+"]"}function u(e,t,n,i){var r,a,s="",c=e.tag;for(r=0,a=n.length;a>r;r+=1)d(e,t+1,n[r],!0,!0)&&(i&&0===r||(s+=o(e,t)),s+="- "+e.dump);e.tag=c,e.dump=s||"[]"}function l(e,t,n){var i,r,o,a,s,c="",u=e.tag,l=Object.keys(n);for(i=0,r=l.length;r>i;i+=1)s="",0!==i&&(s+=", "),o=l[i],a=n[o],d(e,t,o,!1,!1)&&(e.dump.length>1024&&(s+="? "),s+=e.dump+": ",d(e,t,a,!1,!1)&&(s+=e.dump,c+=s));e.tag=u,e.dump="{"+c+"}"}function p(e,t,n,i){var r,a,s,c,u,l,p="",f=e.tag,h=Object.keys(n);for(r=0,a=h.length;a>r;r+=1)l="",i&&0===r||(l+=o(e,t)),s=h[r],c=n[s],d(e,t+1,s,!0,!0)&&(u=null!==e.tag&&"?"!==e.tag||e.dump&&e.dump.length>1024,u&&(l+=e.dump&&C===e.dump.charCodeAt(0)?"?":"? "),l+=e.dump,u&&(l+=o(e,t)),d(e,t+1,c,!0,u)&&(l+=e.dump&&C===e.dump.charCodeAt(0)?":":": ",l+=e.dump,p+=l));e.tag=f,e.dump=p||"{}"}function f(e,t,n){var i,r,o,a,s,c;for(r=n?e.explicitTypes:e.implicitTypes,o=0,a=r.length;a>o;o+=1)if(s=r[o],(s.instanceOf||s.predicate)&&(!s.instanceOf||"object"==typeof t&&t instanceof s.instanceOf)&&(!s.predicate||s.predicate(t))){if(e.tag=n?s.tag:"?",s.represent){if(c=e.styleMap[s.tag]||s.defaultStyle,"[object Function]"===A.call(s.represent))i=s.represent(t,c);else{if(!b.call(s.represent,c))throw new y("!<"+s.tag+'> tag resolver accepts not "'+c+'" style');i=s.represent[c](t,c)}e.dump=i}return!0}return!1}function d(e,t,n,i,r){e.tag=null,e.dump=n,f(e,n,!1)||f(e,n,!0);var o=A.call(e.dump);if(i&&(i=0>e.flowLevel||e.flowLevel>t),(null!==e.tag&&"?"!==e.tag||2!==e.indent&&t>0)&&(r=!1),"[object Object]"===o)i&&0!==Object.keys(e.dump).length?p(e,t,e.dump,r):l(e,t,e.dump);else if("[object Array]"===o)i&&0!==e.dump.length?u(e,t,e.dump,r):c(e,t,e.dump);else{if("[object String]"!==o){if(e.skipInvalid)return!1;throw new y("unacceptabe kind of an object to dump "+o)}"?"!==e.tag&&s(e,e.dump)}return null!==e.tag&&"?"!==e.tag&&(e.dump="!<"+e.tag+"> "+e.dump),!0}function h(e,t){t=t||{};var n=new r(t);return d(n,0,e,!0,!0)?n.dump+"\n":""}function m(e,t){return h(e,g.extend({schema:v},t))}var g=e("./common"),y=e("./exception"),x=e("./schema/default_full"),v=e("./schema/default_safe"),A=Object.prototype.toString,b=Object.prototype.hasOwnProperty,w=9,C=10,k=13,j=32,I=33,S=34,E=35,O=37,F=38,N=39,T=42,L=44,_=45,M=58,Y=62,q=63,U=64,D=91,P=93,R=96,H=123,$=124,B=125,G={};G[0]="\\0",G[7]="\\a",G[8]="\\b",G[9]="\\t",G[10]="\\n",G[11]="\\v",G[12]="\\f",G[13]="\\r",G[27]="\\e",G[34]='\\"',G[92]="\\\\",G[133]="\\N",G[160]="\\_",G[8232]="\\L",G[8233]="\\P";var V=["y","Y","yes","Yes","YES","on","On","ON","n","N","no","No","NO","off","Off","OFF"];t.exports.dump=h,t.exports.safeDump=m},{"./common":3,"./exception":5,"./schema/default_full":10,"./schema/default_safe":11}],5:[function(e,t){function n(e,t){this.name="YAMLException",this.reason=e,this.mark=t,this.message=this.toString(!1)}n.prototype.toString=function(e){var t;return t="JS-YAML: "+(this.reason||"(unknown reason)"),!e&&this.mark&&(t+=" "+this.mark.toString()),t},t.exports=n},{}],6:[function(e,t){function n(e){return 10===e||13===e}function i(e){return 9===e||32===e}function r(e){return 9===e||32===e||10===e||13===e}function o(e){return 44===e||91===e||93===e||123===e||125===e}function a(e){var t;return e>=48&&57>=e?e-48:(t=32|e,t>=97&&102>=t?t-97+10:-1)}function s(e){return 120===e?2:117===e?4:85===e?8:0}function c(e){return e>=48&&57>=e?e-48:-1}function u(e){return 48===e?"\x00":97===e?"":98===e?"\b":116===e?"	":9===e?"	":110===e?"\n":118===e?"":102===e?"\f":114===e?"\r":101===e?"":32===e?" ":34===e?'"':47===e?"/":92===e?"\\":78===e?"":95===e?"":76===e?"\u2028":80===e?"\u2029":""}function l(e,t){this.input=e,this.filename=t.filename||null,this.schema=t.schema||H,this.onWarning=t.onWarning||null,this.legacy=t.legacy||!1,this.implicitTypes=this.schema.compiledImplicit,this.typeMap=this.schema.compiledTypeMap,this.length=e.length,this.position=0,this.line=0,this.lineStart=0,this.lineIndent=0,this.documents=[]}function p(e,t){return new D(t,new P(e.filename,e.input,e.position,e.line,e.position-e.lineStart))}function f(e,t){throw p(e,t)}function d(e,t){var n=p(e,t);if(!e.onWarning)throw n;e.onWarning.call(null,n)}function h(e,t,n,i){var r,o,a,s;if(n>t){if(s=e.input.slice(t,n),i)for(r=0,o=s.length;o>r;r+=1)a=s.charCodeAt(r),9===a||a>=32&&1114111>=a||f(e,"expected valid JSON character");e.result+=s}}function m(e,t,n){var i,r,o,a;for(U.isObject(n)||f(e,"cannot merge mappings; the provided source object is unacceptable"),i=Object.keys(n),o=0,a=i.length;a>o;o+=1)r=i[o],$.call(t,r)||(t[r]=n[r])}function g(e,t,n,i,r){var o,a;if(i=String(i),null===t&&(t={}),"tag:yaml.org,2002:merge"===n)if(Array.isArray(r))for(o=0,a=r.length;a>o;o+=1)m(e,t,r[o]);else m(e,t,r);else t[i]=r;return t}function y(e){var t;t=e.input.charCodeAt(e.position),10===t?e.position++:13===t?(e.position++,10===e.input.charCodeAt(e.position)&&e.position++):f(e,"a line break is expected"),e.line+=1,e.lineStart=e.position}function x(e,t,r){for(var o=0,a=e.input.charCodeAt(e.position);0!==a;){for(;i(a);)a=e.input.charCodeAt(++e.position);if(t&&35===a)do a=e.input.charCodeAt(++e.position);while(10!==a&&13!==a&&0!==a);if(!n(a))break;for(y(e),a=e.input.charCodeAt(e.position),o++,e.lineIndent=0;32===a;)e.lineIndent++,a=e.input.charCodeAt(++e.position);e.lineIndent<r&&d(e,"deficient indentation")}return o}function v(e){var t,n=e.position;return t=e.input.charCodeAt(n),45!==t&&46!==t||e.input.charCodeAt(n+1)!==t||e.input.charCodeAt(n+2)!==t||(n+=3,t=e.input.charCodeAt(n),0!==t&&!r(t))?!1:!0}function A(e,t){1===t?e.result+=" ":t>1&&(e.result+=U.repeat("\n",t-1))}function b(e,t,a){var s,c,u,l,p,f,d,m,g,y=e.kind,b=e.result;if(g=e.input.charCodeAt(e.position),r(g)||o(g)||35===g||38===g||42===g||33===g||124===g||62===g||39===g||34===g||37===g||64===g||96===g)return!1;if((63===g||45===g)&&(c=e.input.charCodeAt(e.position+1),r(c)||a&&o(c)))return!1;for(e.kind="scalar",e.result="",u=l=e.position,p=!1;0!==g;){if(58===g){if(c=e.input.charCodeAt(e.position+1),r(c)||a&&o(c))break}else if(35===g){if(s=e.input.charCodeAt(e.position-1),r(s))break}else{if(e.position===e.lineStart&&v(e)||a&&o(g))break;if(n(g)){if(f=e.line,d=e.lineStart,m=e.lineIndent,x(e,!1,-1),e.lineIndent>=t){p=!0,g=e.input.charCodeAt(e.position);continue}e.position=l,e.line=f,e.lineStart=d,e.lineIndent=m;break}}p&&(h(e,u,l,!1),A(e,e.line-f),u=l=e.position,p=!1),i(g)||(l=e.position+1),g=e.input.charCodeAt(++e.position)}return h(e,u,l,!1),e.result?!0:(e.kind=y,e.result=b,!1)}function w(e,t){var i,r,o;if(i=e.input.charCodeAt(e.position),39!==i)return!1;for(e.kind="scalar",e.result="",e.position++,r=o=e.position;0!==(i=e.input.charCodeAt(e.position));)if(39===i){if(h(e,r,e.position,!0),i=e.input.charCodeAt(++e.position),39!==i)return!0;r=o=e.position,e.position++}else n(i)?(h(e,r,o,!0),A(e,x(e,!1,t)),r=o=e.position):e.position===e.lineStart&&v(e)?f(e,"unexpected end of the document within a single quoted scalar"):(e.position++,o=e.position);f(e,"unexpected end of the stream within a single quoted scalar")}function C(e,t){var i,r,o,c,u,l;if(l=e.input.charCodeAt(e.position),34!==l)return!1;for(e.kind="scalar",e.result="",e.position++,i=r=e.position;0!==(l=e.input.charCodeAt(e.position));){if(34===l)return h(e,i,e.position,!0),e.position++,!0;if(92===l){if(h(e,i,e.position,!0),l=e.input.charCodeAt(++e.position),n(l))x(e,!1,t);else if(256>l&&nt[l])e.result+=it[l],e.position++;else if((u=s(l))>0){for(o=u,c=0;o>0;o--)l=e.input.charCodeAt(++e.position),(u=a(l))>=0?c=(c<<4)+u:f(e,"expected hexadecimal character");e.result+=String.fromCharCode(c),e.position++}else f(e,"unknown escape sequence");i=r=e.position}else n(l)?(h(e,i,r,!0),A(e,x(e,!1,t)),i=r=e.position):e.position===e.lineStart&&v(e)?f(e,"unexpected end of the document within a double quoted scalar"):(e.position++,r=e.position)}f(e,"unexpected end of the stream within a double quoted scalar")}function k(e,t){var n,i,o,a,s,c,u,l,p,d,h,m=!0,y=e.tag;if(h=e.input.charCodeAt(e.position),91===h)a=93,u=!1,i=[];else{if(123!==h)return!1;a=125,u=!0,i={}}for(null!==e.anchor&&(e.anchorMap[e.anchor]=i),h=e.input.charCodeAt(++e.position);0!==h;){if(x(e,!0,t),h=e.input.charCodeAt(e.position),h===a)return e.position++,e.tag=y,e.kind=u?"mapping":"sequence",e.result=i,!0;m||f(e,"missed comma between flow collection entries"),p=l=d=null,s=c=!1,63===h&&(o=e.input.charCodeAt(e.position+1),r(o)&&(s=c=!0,e.position++,x(e,!0,t))),n=e.line,N(e,t,B,!1,!0),p=e.tag,l=e.result,x(e,!0,t),h=e.input.charCodeAt(e.position),!c&&e.line!==n||58!==h||(s=!0,h=e.input.charCodeAt(++e.position),x(e,!0,t),N(e,t,B,!1,!0),d=e.result),u?g(e,i,p,l,d):i.push(s?g(e,null,p,l,d):l),x(e,!0,t),h=e.input.charCodeAt(e.position),44===h?(m=!0,h=e.input.charCodeAt(++e.position)):m=!1}f(e,"unexpected end of the stream within a flow collection")}function j(e,t){var r,o,a,s,u=Z,l=!1,p=t,d=0,m=!1;if(s=e.input.charCodeAt(e.position),124===s)o=!1;else{if(62!==s)return!1;o=!0}for(e.kind="scalar",e.result="";0!==s;)if(s=e.input.charCodeAt(++e.position),43===s||45===s)Z===u?u=43===s?z:J:f(e,"repeat of a chomping mode identifier");else{if(!((a=c(s))>=0))break;0===a?f(e,"bad explicit indentation width of a block scalar; it cannot be less than one"):l?f(e,"repeat of an indentation width identifier"):(p=t+a-1,l=!0)}if(i(s)){do s=e.input.charCodeAt(++e.position);while(i(s));if(35===s)do s=e.input.charCodeAt(++e.position);while(!n(s)&&0!==s)}for(;0!==s;){for(y(e),e.lineIndent=0,s=e.input.charCodeAt(e.position);(!l||e.lineIndent<p)&&32===s;)e.lineIndent++,s=e.input.charCodeAt(++e.position);if(!l&&e.lineIndent>p&&(p=e.lineIndent),n(s))d++;else{if(e.lineIndent<p){u===z?e.result+=U.repeat("\n",d):u===Z&&l&&(e.result+="\n");break}o?i(s)?(m=!0,e.result+=U.repeat("\n",d+1)):m?(m=!1,e.result+=U.repeat("\n",d+1)):0===d?l&&(e.result+=" "):e.result+=U.repeat("\n",d):e.result+=l?U.repeat("\n",d+1):U.repeat("\n",d),l=!0,d=0,r=e.position;do s=e.input.charCodeAt(++e.position);while(!n(s)&&0!==s);h(e,r,e.position,!1),s=e.input.charCodeAt(e.position)}}return!0}function I(e,t){var n,i,o,a=e.tag,s=[],c=!1;for(null!==e.anchor&&(e.anchorMap[e.anchor]=s),o=e.input.charCodeAt(e.position);0!==o&&45===o&&(i=e.input.charCodeAt(e.position+1),r(i));)if(c=!0,e.position++,x(e,!0,-1)&&e.lineIndent<=t)s.push(null),o=e.input.charCodeAt(e.position);else if(n=e.line,N(e,t,V,!1,!0),s.push(e.result),x(e,!0,-1),o=e.input.charCodeAt(e.position),(e.line===n||e.lineIndent>t)&&0!==o)f(e,"bad indentation of a sequence entry");else if(e.lineIndent<t)break;return c?(e.tag=a,e.kind="sequence",e.result=s,!0):!1}function S(e,t,n){var o,a,s,c,u=e.tag,l={},p=null,d=null,h=null,m=!1,y=!1;for(null!==e.anchor&&(e.anchorMap[e.anchor]=l),c=e.input.charCodeAt(e.position);0!==c;){if(o=e.input.charCodeAt(e.position+1),s=e.line,63!==c&&58!==c||!r(o)){if(!N(e,n,G,!1,!0))break;if(e.line===s){for(c=e.input.charCodeAt(e.position);i(c);)c=e.input.charCodeAt(++e.position);if(58===c)c=e.input.charCodeAt(++e.position),r(c)||f(e,"a whitespace character is expected after the key-value separator within a block mapping"),m&&(g(e,l,p,d,null),p=d=h=null),y=!0,m=!1,a=!1,p=e.tag,d=e.result;else{if(!y)return e.tag=u,!0;f(e,"can not read an implicit mapping pair; a colon is missed")}}else{if(!y)return e.tag=u,!0;f(e,"can not read a block mapping entry; a multiline key may not be an implicit key")}}else 63===c?(m&&(g(e,l,p,d,null),p=d=h=null),y=!0,m=!0,a=!0):m?(m=!1,a=!0):f(e,"incomplete explicit mapping pair; a key node is missed"),e.position+=1,c=o;if((e.line===s||e.lineIndent>t)&&(N(e,t,W,!0,a)&&(m?d=e.result:h=e.result),m||(g(e,l,p,d,h),p=d=h=null),x(e,!0,-1),c=e.input.charCodeAt(e.position)),e.lineIndent>t&&0!==c)f(e,"bad indentation of a mapping entry");else if(e.lineIndent<t)break}return m&&g(e,l,p,d,null),y&&(e.tag=u,e.kind="mapping",e.result=l),y}function E(e){var t,n,i,o,a=!1,s=!1;if(o=e.input.charCodeAt(e.position),33!==o)return!1;if(null!==e.tag&&f(e,"duplication of a tag property"),o=e.input.charCodeAt(++e.position),60===o?(a=!0,o=e.input.charCodeAt(++e.position)):33===o?(s=!0,n="!!",o=e.input.charCodeAt(++e.position)):n="!",t=e.position,a){do o=e.input.charCodeAt(++e.position);while(0!==o&&62!==o);e.position<e.length?(i=e.input.slice(t,e.position),o=e.input.charCodeAt(++e.position)):f(e,"unexpected end of the stream within a verbatim tag")}else{for(;0!==o&&!r(o);)33===o&&(s?f(e,"tag suffix cannot contain exclamation marks"):(n=e.input.slice(t-1,e.position+1),et.test(n)||f(e,"named tag handle cannot contain such characters"),s=!0,t=e.position+1)),o=e.input.charCodeAt(++e.position);i=e.input.slice(t,e.position),X.test(i)&&f(e,"tag suffix cannot contain flow indicator characters")}return i&&!tt.test(i)&&f(e,"tag name cannot contain such characters: "+i),a?e.tag=i:$.call(e.tagMap,n)?e.tag=e.tagMap[n]+i:"!"===n?e.tag="!"+i:"!!"===n?e.tag="tag:yaml.org,2002:"+i:f(e,'undeclared tag handle "'+n+'"'),!0}function O(e){var t,n;if(n=e.input.charCodeAt(e.position),38!==n)return!1;for(null!==e.anchor&&f(e,"duplication of an anchor property"),n=e.input.charCodeAt(++e.position),t=e.position;0!==n&&!r(n)&&!o(n);)n=e.input.charCodeAt(++e.position);return e.position===t&&f(e,"name of an anchor node must contain at least one character"),e.anchor=e.input.slice(t,e.position),!0}function F(e){{var t,n,i;e.length,e.input}if(i=e.input.charCodeAt(e.position),42!==i)return!1;for(i=e.input.charCodeAt(++e.position),t=e.position;0!==i&&!r(i)&&!o(i);)i=e.input.charCodeAt(++e.position);return e.position===t&&f(e,"name of an alias node must contain at least one character"),n=e.input.slice(t,e.position),e.anchorMap.hasOwnProperty(n)||f(e,'unidentified alias "'+n+'"'),e.result=e.anchorMap[n],x(e,!0,-1),!0}function N(e,t,n,i,r){var o,a,s,c,u,l,p,h,m=!1,g=!0,y=!1;if(e.tag=null,e.anchor=null,e.kind=null,e.result=null,o=a=s=W===n||V===n,i&&x(e,!0,-1))if(m=!0,e.lineIndent===t)g=!1;else{if(!(e.lineIndent>t))return!1;g=!0}if(g)for(;E(e)||O(e);)if(x(e,!0,-1))if(m=!0,e.lineIndent>t)g=!0,s=o;else{if(e.lineIndent!==t)return!0;g=!1,s=o}else s=!1;if(s&&(s=m||r),(g||W===n)&&(p=B===n||G===n?t:t+1,h=e.position-e.lineStart,g?s&&(I(e,h)||S(e,h,p))||k(e,p)?y=!0:(a&&j(e,p)||w(e,p)||C(e,p)?y=!0:F(e)?(y=!0,(null!==e.tag||null!==e.anchor)&&f(e,"alias node should not have any properties")):b(e,p,B===n)&&(y=!0,null===e.tag&&(e.tag="?")),null!==e.anchor&&(e.anchorMap[e.anchor]=e.result)):y=s&&I(e,h)),null!==e.tag&&"!"!==e.tag)if("?"===e.tag){for(c=0,u=e.implicitTypes.length;u>c;c+=1)if(l=e.implicitTypes[c],l.resolve(e.result)){e.result=l.construct(e.result),e.tag=l.tag;break}}else $.call(e.typeMap,e.tag)?(l=e.typeMap[e.tag],null!==e.result&&l.kind!==e.kind&&f(e,"unacceptable node kind for !<"+e.tag+'> tag; it should be "'+l.kind+'", not "'+e.kind+'"'),l.resolve(e.result)?e.result=l.construct(e.result):f(e,"cannot resolve a node with !<"+e.tag+"> explicit tag")):d(e,"unknown tag !<"+e.tag+">");return null!==e.tag||null!==e.anchor||y}function T(e){var t,o,a,s,c=e.position,u=!1;for(e.version=null,e.checkLineBreaks=e.legacy,e.tagMap={},e.anchorMap={};0!==(s=e.input.charCodeAt(e.position))&&(x(e,!0,-1),s=e.input.charCodeAt(e.position),!(e.lineIndent>0||37!==s));){for(u=!0,s=e.input.charCodeAt(++e.position),t=e.position;0!==s&&!r(s);)s=e.input.charCodeAt(++e.position);for(o=e.input.slice(t,e.position),a=[],o.length<1&&f(e,"directive name must not be less than one character in length");0!==s;){for(;i(s);)s=e.input.charCodeAt(++e.position);if(35===s){do s=e.input.charCodeAt(++e.position);while(0!==s&&!n(s));break}if(n(s))break;for(t=e.position;0!==s&&!r(s);)s=e.input.charCodeAt(++e.position);a.push(e.input.slice(t,e.position))}0!==s&&y(e),$.call(ot,o)?ot[o](e,o,a):d(e,'unknown document directive "'+o+'"')}return x(e,!0,-1),0===e.lineIndent&&45===e.input.charCodeAt(e.position)&&45===e.input.charCodeAt(e.position+1)&&45===e.input.charCodeAt(e.position+2)?(e.position+=3,x(e,!0,-1)):u&&f(e,"directives end mark is expected"),N(e,e.lineIndent-1,W,!1,!0),x(e,!0,-1),e.checkLineBreaks&&Q.test(e.input.slice(c,e.position))&&d(e,"non-ASCII line breaks are interpreted as content"),e.documents.push(e.result),e.position===e.lineStart&&v(e)?void(46===e.input.charCodeAt(e.position)&&(e.position+=3,x(e,!0,-1))):void(e.position<e.length-1&&f(e,"end of the stream or a document separator is expected"))}function L(e,t){e=String(e),t=t||{},0!==e.length&&10!==e.charCodeAt(e.length-1)&&13!==e.charCodeAt(e.length-1)&&(e+="\n");var n=new l(e,t);for(K.test(n.input)&&f(n,"the stream contains non-printable characters"),n.input+="\x00";32===n.input.charCodeAt(n.position);)n.lineIndent+=1;for(;n.position<n.length-1;)T(n);return n.documents}function _(e,t,n){var i,r,o=L(e,n);for(i=0,r=o.length;r>i;i+=1)t(o[i])}function M(e,t){var n=L(e,t);if(0===n.length)return void 0;if(1===n.length)return n[0];throw new D("expected a single document in the stream, but found more")}function Y(e,t,n){_(e,t,U.extend({schema:R},n))}function q(e,t){return M(e,U.extend({schema:R},t))}for(var U=e("./common"),D=e("./exception"),P=e("./mark"),R=e("./schema/default_safe"),H=e("./schema/default_full"),$=Object.prototype.hasOwnProperty,B=1,G=2,V=3,W=4,Z=1,J=2,z=3,K=/[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uD800-\uDFFF\uFFFE\uFFFF]/,Q=/[\x85\u2028\u2029]/,X=/[,\[\]\{\}]/,et=/^(?:!|!!|![a-z\-]+!)$/i,tt=/^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i,nt=new Array(256),it=new Array(256),rt=0;256>rt;rt++)nt[rt]=u(rt)?1:0,it[rt]=u(rt);var ot={YAML:function(e,t,n){var i,r,o;null!==e.version&&f(e,"duplication of %YAML directive"),1!==n.length&&f(e,"YAML directive accepts exactly one argument"),i=/^([0-9]+)\.([0-9]+)$/.exec(n[0]),null===i&&f(e,"ill-formed argument of the YAML directive"),r=parseInt(i[1],10),o=parseInt(i[2],10),1!==r&&f(e,"unacceptable YAML version of the document"),e.version=n[0],e.checkLineBreaks=2>o,1!==o&&2!==o&&d(e,"unsupported YAML version of the document")},TAG:function(e,t,n){var i,r;2!==n.length&&f(e,"TAG directive accepts exactly two arguments"),i=n[0],r=n[1],et.test(i)||f(e,"ill-formed tag handle (first argument) of the TAG directive"),$.call(e.tagMap,i)&&f(e,'there is a previously declared suffix for "'+i+'" tag handle'),tt.test(r)||f(e,"ill-formed tag prefix (second argument) of the TAG directive"),e.tagMap[i]=r}};t.exports.loadAll=_,t.exports.load=M,t.exports.safeLoadAll=Y,t.exports.safeLoad=q},{"./common":3,"./exception":5,"./mark":7,"./schema/default_full":10,"./schema/default_safe":11}],7:[function(e,t){function n(e,t,n,i,r){this.name=e,this.buffer=t,this.position=n,this.line=i,this.column=r}var i=e("./common");n.prototype.getSnippet=function(e,t){var n,r,o,a,s;if(!this.buffer)return null;for(e=e||4,t=t||75,n="",r=this.position;r>0&&-1==="\x00\r\n\u2028\u2029".indexOf(this.buffer.charAt(r-1));)if(r-=1,this.position-r>t/2-1){n=" ... ",r+=5;break}for(o="",a=this.position;a<this.buffer.length&&-1==="\x00\r\n\u2028\u2029".indexOf(this.buffer.charAt(a));)if(a+=1,a-this.position>t/2-1){o=" ... ",a-=5;break}return s=this.buffer.slice(r,a),i.repeat(" ",e)+n+s+o+"\n"+i.repeat(" ",e+this.position-r+n.length)+"^"},n.prototype.toString=function(e){var t,n="";return this.name&&(n+='in "'+this.name+'" '),n+="at line "+(this.line+1)+", column "+(this.column+1),e||(t=this.getSnippet(),t&&(n+=":\n"+t)),n},t.exports=n},{"./common":3}],8:[function(e,t){function n(e,t,i){var r=[];return e.include.forEach(function(e){i=n(e,t,i)}),e[t].forEach(function(e){i.forEach(function(t,n){t.tag===e.tag&&r.push(n)}),i.push(e)}),i.filter(function(e,t){return-1===r.indexOf(t)})}function i(){function e(e){i[e.tag]=e}var t,n,i={};for(t=0,n=arguments.length;n>t;t+=1)arguments[t].forEach(e);return i}function r(e){this.include=e.include||[],this.implicit=e.implicit||[],this.explicit=e.explicit||[],this.implicit.forEach(function(e){if(e.loadKind&&"scalar"!==e.loadKind)throw new a("There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.")}),this.compiledImplicit=n(this,"implicit",[]),this.compiledExplicit=n(this,"explicit",[]),this.compiledTypeMap=i(this.compiledImplicit,this.compiledExplicit)}var o=e("./common"),a=e("./exception"),s=e("./type");r.DEFAULT=null,r.create=function(){var e,t;switch(arguments.length){case 1:e=r.DEFAULT,t=arguments[0];break;case 2:e=arguments[0],t=arguments[1];break;default:throw new a("Wrong number of arguments for Schema.create function")}if(e=o.toArray(e),t=o.toArray(t),!e.every(function(e){return e instanceof r}))throw new a("Specified list of super schemas (or a single Schema object) contains a non-Schema object.");if(!t.every(function(e){return e instanceof s}))throw new a("Specified list of YAML types (or a single Type object) contains a non-Type object.");return new r({include:e,explicit:t})},t.exports=r},{"./common":3,"./exception":5,"./type":14}],9:[function(e,t){var n=e("../schema");t.exports=new n({include:[e("./json")]})},{"../schema":8,"./json":13}],10:[function(e,t){var n=e("../schema");t.exports=n.DEFAULT=new n({include:[e("./default_safe")],explicit:[e("../type/js/undefined"),e("../type/js/regexp"),e("../type/js/function")]})},{"../schema":8,"../type/js/function":19,"../type/js/regexp":20,"../type/js/undefined":21,"./default_safe":11}],11:[function(e,t){var n=e("../schema");t.exports=new n({include:[e("./core")],implicit:[e("../type/timestamp"),e("../type/merge")],explicit:[e("../type/binary"),e("../type/omap"),e("../type/pairs"),e("../type/set")]})},{"../schema":8,"../type/binary":15,"../type/merge":23,"../type/omap":25,"../type/pairs":26,"../type/set":28,"../type/timestamp":30,"./core":9}],12:[function(e,t){var n=e("../schema");t.exports=new n({explicit:[e("../type/str"),e("../type/seq"),e("../type/map")]})},{"../schema":8,"../type/map":22,"../type/seq":27,"../type/str":29}],13:[function(e,t){var n=e("../schema");t.exports=new n({include:[e("./failsafe")],implicit:[e("../type/null"),e("../type/bool"),e("../type/int"),e("../type/float")]})},{"../schema":8,"../type/bool":16,"../type/float":17,"../type/int":18,"../type/null":24,"./failsafe":12}],14:[function(e,t){function n(e){var t={};return null!==e&&Object.keys(e).forEach(function(n){e[n].forEach(function(e){t[String(e)]=n})}),t}function i(e,t){if(t=t||{},Object.keys(t).forEach(function(t){if(-1===o.indexOf(t))throw new r('Unknown option "'+t+'" is met in definition of "'+e+'" YAML type.')}),this.tag=e,this.kind=t.kind||null,this.resolve=t.resolve||function(){return!0},this.construct=t.construct||function(e){return e},this.instanceOf=t.instanceOf||null,this.predicate=t.predicate||null,this.represent=t.represent||null,this.defaultStyle=t.defaultStyle||null,this.styleAliases=n(t.styleAliases||null),-1===a.indexOf(this.kind))throw new r('Unknown kind "'+this.kind+'" is specified for "'+e+'" YAML type.')}var r=e("./exception"),o=["kind","resolve","construct","instanceOf","predicate","represent","defaultStyle","styleAliases"],a=["scalar","sequence","mapping"];t.exports=i},{"./exception":5}],15:[function(e,t){function n(e){var t,n,i=0,r=e.length;for(n=0,i=0;r>i;i+=1)if(t=e.charCodeAt(i),10!==t&&13!==t){if(-1===u[127&t])return!1;n+=6,n>=8&&(n-=8)}return n?!1:!0}function i(e){var t,n,i,r,o=0,s=e.length,l=[];for(i=0,r=0,o=0;s>o;o+=1)n=e.charCodeAt(o),t=u[127&n],10!==n&&13!==n&&(r=r<<6|t,i+=6,i>=8&&(i-=8,c!==e.charAt(o)&&l.push(r>>i&255),r&=(1<<i)-1));return a?new a(l):l}function r(e){var t,n,i,r="";for(t=0,n=e.length-2;n>t;t+=3)r+=l[e[t+0]>>2],r+=l[((3&e[t+0])<<4)+(e[t+1]>>4)],r+=l[((15&e[t+1])<<2)+(e[t+2]>>6)],r+=l[63&e[t+2]];return i=e.length%3,0!==i&&(t=e.length-i,r+=l[e[t+0]>>2],2===i?(r+=l[((3&e[t+0])<<4)+(e[t+1]>>4)],r+=l[(15&e[t+1])<<2],r+=c):(r+=l[(3&e[t+0])<<4],r+=c+c)),r}function o(e){return a&&a.isBuffer(e)}var a=e("buffer").Buffer,s=e("../type"),c="=",u=[-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,62,-1,-1,-1,63,52,53,54,55,56,57,58,59,60,61,-1,-1,-1,0,-1,-1,-1,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,-1,-1,-1,-1,-1,-1,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,-1,-1,-1,-1,-1],l="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split("");t.exports=new s("tag:yaml.org,2002:binary",{kind:"scalar",resolve:n,construct:i,predicate:o,represent:r})},{"../type":14,buffer:31}],16:[function(e,t){function n(e){var t=e.length;return 4===t&&("true"===e||"True"===e||"TRUE"===e)||5===t&&("false"===e||"False"===e||"FALSE"===e)}function i(e){return"true"===e||"True"===e||"TRUE"===e}function r(e){return"[object Boolean]"===Object.prototype.toString.call(e)}var o=e("../type");t.exports=new o("tag:yaml.org,2002:bool",{kind:"scalar",resolve:n,construct:i,predicate:r,represent:{lowercase:function(e){return e?"true":"false"},uppercase:function(e){return e?"TRUE":"FALSE"},camelcase:function(e){return e?"True":"False"}},defaultStyle:"lowercase"})},{"../type":14}],17:[function(e,t){function n(e){return c.test(e)?!0:!1}function i(e){var t,n,i,r;return t=e.replace(/_/g,"").toLowerCase(),n="-"===t[0]?-1:1,r=[],0<="+-".indexOf(t[0])&&(t=t.slice(1)),".inf"===t?1===n?Number.POSITIVE_INFINITY:Number.NEGATIVE_INFINITY:".nan"===t?0/0:0<=t.indexOf(":")?(t.split(":").forEach(function(e){r.unshift(parseFloat(e,10))}),t=0,i=1,r.forEach(function(e){t+=e*i,i*=60}),n*t):n*parseFloat(t,10)}function r(e,t){if(isNaN(e))switch(t){case"lowercase":return".nan";case"uppercase":return".NAN";case"camelcase":return".NaN"}else if(Number.POSITIVE_INFINITY===e)switch(t){case"lowercase":return".inf";case"uppercase":return".INF";case"camelcase":return".Inf"}else{if(Number.NEGATIVE_INFINITY!==e)return a.isNegativeZero(e)?"-0.0":e.toString(10);switch(t){case"lowercase":return"-.inf";case"uppercase":return"-.INF";case"camelcase":return"-.Inf"}}}function o(e){return"[object Number]"===Object.prototype.toString.call(e)&&(0!==e%1||a.isNegativeZero(e))}var a=e("../common"),s=e("../type"),c=new RegExp("^(?:[-+]?(?:[0-9][0-9_]*)\\.[0-9_]*(?:[eE][-+][0-9]+)?|\\.[0-9_]+(?:[eE][-+][0-9]+)?|[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\\.[0-9_]*|[-+]?\\.(?:inf|Inf|INF)|\\.(?:nan|NaN|NAN))$");t.exports=new s("tag:yaml.org,2002:float",{kind:"scalar",resolve:n,construct:i,predicate:o,represent:r,defaultStyle:"lowercase"})},{"../common":3,"../type":14}],18:[function(e,t){function n(e){return e>=48&&57>=e||e>=65&&70>=e||e>=97&&102>=e}function i(e){return e>=48&&55>=e}function r(e){return e>=48&&57>=e}function o(e){var t,o=e.length,a=0,s=!1;if(!o)return!1;if(t=e[a],("-"===t||"+"===t)&&(t=e[++a]),"0"===t){if(a+1===o)return!0;if(t=e[++a],"b"===t){for(a++;o>a;a++)if(t=e[a],"_"!==t){if("0"!==t&&"1"!==t)return!1;s=!0}return s}if("x"===t){for(a++;o>a;a++)if(t=e[a],"_"!==t){if(!n(e.charCodeAt(a)))return!1;s=!0}return s}for(;o>a;a++)if(t=e[a],"_"!==t){if(!i(e.charCodeAt(a)))return!1;s=!0}return s}for(;o>a;a++)if(t=e[a],"_"!==t){if(":"===t)break;if(!r(e.charCodeAt(a)))return!1;s=!0}return s?":"!==t?!0:/^(:[0-5]?[0-9])+$/.test(e.slice(a)):!1}function a(e){var t,n,i=e,r=1,o=[];return-1!==i.indexOf("_")&&(i=i.replace(/_/g,"")),t=i[0],("-"===t||"+"===t)&&("-"===t&&(r=-1),i=i.slice(1),t=i[0]),"0"===i?0:"0"===t?"b"===i[1]?r*parseInt(i.slice(2),2):"x"===i[1]?r*parseInt(i,16):r*parseInt(i,8):-1!==i.indexOf(":")?(i.split(":").forEach(function(e){o.unshift(parseInt(e,10))}),i=0,n=1,o.forEach(function(e){i+=e*n,n*=60}),r*i):r*parseInt(i,10)}function s(e){return"[object Number]"===Object.prototype.toString.call(e)&&0===e%1&&!c.isNegativeZero(e)}var c=e("../common"),u=e("../type");t.exports=new u("tag:yaml.org,2002:int",{kind:"scalar",resolve:o,construct:a,predicate:s,represent:{binary:function(e){return"0b"+e.toString(2)
},octal:function(e){return"0"+e.toString(8)},decimal:function(e){return e.toString(10)},hexadecimal:function(e){return"0x"+e.toString(16).toUpperCase()}},defaultStyle:"decimal",styleAliases:{binary:[2,"bin"],octal:[8,"oct"],decimal:[10,"dec"],hexadecimal:[16,"hex"]}})},{"../common":3,"../type":14}],19:[function(e,t){function n(e){try{var t="("+e+")",n=a.parse(t,{range:!0});return"Program"!==n.type||1!==n.body.length||"ExpressionStatement"!==n.body[0].type||"FunctionExpression"!==n.body[0].expression.type?!1:!0}catch(i){return!1}}function i(e){var t,n="("+e+")",i=a.parse(n,{range:!0}),r=[];if("Program"!==i.type||1!==i.body.length||"ExpressionStatement"!==i.body[0].type||"FunctionExpression"!==i.body[0].expression.type)throw new Error("Failed to resolve function");return i.body[0].expression.params.forEach(function(e){r.push(e.name)}),t=i.body[0].expression.body.range,new Function(r,n.slice(t[0]+1,t[1]-1))}function r(e){return e.toString()}function o(e){return"[object Function]"===Object.prototype.toString.call(e)}var a;try{a=e("esprima")}catch(s){"undefined"!=typeof window&&(a=window.esprima)}var c=e("../../type");t.exports=new c("tag:yaml.org,2002:js/function",{kind:"scalar",resolve:n,construct:i,predicate:o,represent:r})},{"../../type":14,esprima:"Lkr711"}],20:[function(e,t){function n(e){var t=e,n=/\/([gim]*)$/.exec(e),i="";if("/"===t[0]){if(n&&(i=n[1]),i.length>3)return!1;if("/"!==t[t.length-i.length-1])return!1;t=t.slice(1,t.length-i.length-1)}try{{new RegExp(t,i)}return!0}catch(r){return!1}}function i(e){var t=e,n=/\/([gim]*)$/.exec(e),i="";return"/"===t[0]&&(n&&(i=n[1]),t=t.slice(1,t.length-i.length-1)),new RegExp(t,i)}function r(e){var t="/"+e.source+"/";return e.global&&(t+="g"),e.multiline&&(t+="m"),e.ignoreCase&&(t+="i"),t}function o(e){return"[object RegExp]"===Object.prototype.toString.call(e)}var a=e("../../type");t.exports=new a("tag:yaml.org,2002:js/regexp",{kind:"scalar",resolve:n,construct:i,predicate:o,represent:r})},{"../../type":14}],21:[function(e,t){function n(){return!0}function i(){return void 0}function r(){return""}function o(e){return"undefined"==typeof e}var a=e("../../type");t.exports=new a("tag:yaml.org,2002:js/undefined",{kind:"scalar",resolve:n,construct:i,predicate:o,represent:r})},{"../../type":14}],22:[function(e,t){var n=e("../type");t.exports=new n("tag:yaml.org,2002:map",{kind:"mapping"})},{"../type":14}],23:[function(e,t){function n(e){return"<<"===e}var i=e("../type");t.exports=new i("tag:yaml.org,2002:merge",{kind:"scalar",resolve:n})},{"../type":14}],24:[function(e,t){function n(e){var t=e.length;return 1===t&&"~"===e||4===t&&("null"===e||"Null"===e||"NULL"===e)}function i(){return null}function r(e){return null===e}var o=e("../type");t.exports=new o("tag:yaml.org,2002:null",{kind:"scalar",resolve:n,construct:i,predicate:r,represent:{canonical:function(){return"~"},lowercase:function(){return"null"},uppercase:function(){return"NULL"},camelcase:function(){return"Null"}},defaultStyle:"lowercase"})},{"../type":14}],25:[function(e,t){function n(e){var t,n,i,a,s,c=[],u=e;for(t=0,n=u.length;n>t;t+=1){if(i=u[t],s=!1,"[object Object]"!==o.call(i))return!1;for(a in i)if(r.call(i,a)){if(s)return!1;s=!0}if(!s)return!1;if(-1!==c.indexOf(a))return!1;c.push(a)}return!0}var i=e("../type"),r=Object.prototype.hasOwnProperty,o=Object.prototype.toString;t.exports=new i("tag:yaml.org,2002:omap",{kind:"sequence",resolve:n})},{"../type":14}],26:[function(e,t){function n(e){var t,n,i,r,a,s=e;for(a=new Array(s.length),t=0,n=s.length;n>t;t+=1){if(i=s[t],"[object Object]"!==o.call(i))return!1;if(r=Object.keys(i),1!==r.length)return!1;a[t]=[r[0],i[r[0]]]}return!0}function i(e){var t,n,i,r,o,a=e;for(o=new Array(a.length),t=0,n=a.length;n>t;t+=1)i=a[t],r=Object.keys(i),o[t]=[r[0],i[r[0]]];return o}var r=e("../type"),o=Object.prototype.toString;t.exports=new r("tag:yaml.org,2002:pairs",{kind:"sequence",resolve:n,construct:i})},{"../type":14}],27:[function(e,t){var n=e("../type");t.exports=new n("tag:yaml.org,2002:seq",{kind:"sequence"})},{"../type":14}],28:[function(e,t){function n(e){var t,n=e;for(t in n)if(r.call(n,t)&&null!==n[t])return!1;return!0}var i=e("../type"),r=Object.prototype.hasOwnProperty;t.exports=new i("tag:yaml.org,2002:set",{kind:"mapping",resolve:n})},{"../type":14}],29:[function(e,t){var n=e("../type");t.exports=new n("tag:yaml.org,2002:str",{kind:"scalar"})},{"../type":14}],30:[function(e,t){function n(e){var t;return t=a.exec(e),null===t?!1:!0}function i(e){var t,n,i,r,o,s,c,u,l,p,f=0,d=null;if(t=a.exec(e),null===t)throw new Error("Date resolve error");if(n=+t[1],i=+t[2]-1,r=+t[3],!t[4])return new Date(Date.UTC(n,i,r));if(o=+t[4],s=+t[5],c=+t[6],t[7]){for(f=t[7].slice(0,3);f.length<3;)f+="0";f=+f}return t[9]&&(u=+t[10],l=+(t[11]||0),d=6e4*(60*u+l),"-"===t[9]&&(d=-d)),p=new Date(Date.UTC(n,i,r,o,s,c,f)),d&&p.setTime(p.getTime()-d),p}function r(e){return e.toISOString()}var o=e("../type"),a=new RegExp("^([0-9][0-9][0-9][0-9])-([0-9][0-9]?)-([0-9][0-9]?)(?:(?:[Tt]|[ \\t]+)([0-9][0-9]?):([0-9][0-9]):([0-9][0-9])(?:\\.([0-9]*))?(?:[ \\t]*(Z|([-+])([0-9][0-9]?)(?::([0-9][0-9]))?))?)?$");t.exports=new o("tag:yaml.org,2002:timestamp",{kind:"scalar",resolve:n,construct:i,instanceOf:Date,represent:r})},{"../type":14}],31:[function(){},{}]},{},[1])(1)});
define('logging/yamlformatter',['require','exports','module','util/util','util-logging/formatter','util-logging/logrecord','yaml'],function (require, exports, module) {


var util = require("util/util");
var Formatter = require("util-logging/formatter");
var LogRecord = require("util-logging/logrecord");
var yaml = require("yaml");


/**
 * This class formats LogRecord objects as YAML.
 *
 * @name YAMLFormatter
 * @constructor
 */
var YAMLFormatter = function() {
  var self = this;
  (self.super_ = Formatter.super_).call(self);
  return self;
};

util.inherits(YAMLFormatter, Formatter);


/**
 * This function formats a {@link LogRecord} object in YAML as follows:
 *
 * time: {datetime}
 * message: {message}
 * [logger-name]: {string}
 * [level]: {level}
 * [parameters]: {parameters} (if more than 0)
 *
 * Each entry is returned as an array of length 1, which can be appended to
 * a log file (see FileLogger) as part of an "infinite" array.
 *
 * @param {LogRecord} logRecord Record to be formatted
 */
YAMLFormatter.prototype.formatMessage = function(logRecord) {
  if (!logRecord || !(logRecord instanceof LogRecord))
    return {};

  var record = {};
  record.message = logRecord.getMessage() || "";

  //log errors as strings
  if (util.isError(record.message))
    record.message = record.message.message || record.message.toString();

  var date = new Date();
  var millis = logRecord.getMillis();
  if (millis && (typeof millis === "number"))
    date.setTime(millis);
  record.date = date;

  var loggerName = logRecord.getLoggerName();
  if (loggerName && typeof loggerName == "string")
    record.name = loggerName;

  var level = logRecord.getLevel();
  if (level)
    record.level = {name: level.getName(), value: level.intValue()};

  var parameters = logRecord.getParameters();
  if (parameters && parameters instanceof Array && parameters.length > 0)
    record.parameters = parameters;

  // FIXME: dumping [stack-location]: {stack-location} makes YAML dumper recurse
  // var stack = logRecord.getSourceStackFrame();
  // if (stack)
  //   record.stack = stack;

  var thrown = logRecord.getThrown();
  if (thrown && util.isError(thrown))
    record.thrown = {message: thrown.message, stack: thrown.stack};

  return yaml.safeDump([record]);
};

module.exports = YAMLFormatter;
});

// Monkey-patches

define('logging/logger-patch',['require','exports','module','util-logging/logger','util-logging/logrecord','util-logging/level'],function (require, exports, module) {


var Logger = require("util-logging/logger");

/**
 * Re-log the given {@link LogRecord} (with the original time stamp)
 * @param {LogRecord} record LogRecord to relog
 *
 * Used to reload a saved log.
 *
 * @returns {Logger}
 */
Logger.prototype.relog = function(record) {
  this.getHandlers().forEach(function(handler) {
    if (record.getLevel() >= this.getLevel())
      handler.publish(record);
  }, this);
  return this;
};

var LogRecord = require("util-logging/logrecord");
var Level = require("util-logging/level");

LogRecord.prototype.fromObject = function (obj) {
  obj.level = new Level(obj.level);
  obj.millis = Date.parse(obj.date);
  return new LogRecord(obj);
};

Level.DEBUG = new Level({name: "DEBUG", value: 3});

Logger.prototype.debug = function() {
  return this._log(Level.DEBUG, arguments);
};

});

/**
 * Copyright (c) 2011, Lasse Fister lasse@graphicore.de, http://graphicore.de
 * 
 * You should have received a copy of the MIT License along with this program.
 * If not, see http://www.opensource.org/licenses/mit-license.php
 * 
 */
 
define('ufojs/errors',[],function() {
    
    //ufojs errors
    var errors = {}
    
    /**
     * safe three lines of coding for each error with this factory
     * 
     * and observe that extending Error is uncool
     */
    var makeError = function(name, Constructor, prototype, namespace)
    {
        if(prototype === undefined)
            var prototype = new Error;
        
        if(Constructor === undefined) {
            var Constructor = function(message, stack) {
                if(message !== undefined) {
                    this.name = name;
                    this.message = message || "(no error message)";
                    stack = stack || (new Error).stack || '(no stack available)'
                    this.stack = [name, ' Error: ', this.message, '\n'
                                                       , stack].join('');
                }
            };
        };
        Constructor.prototype = prototype;
        Constructor.prototype.constructor = Constructor;
        if(namespace === undefined)
            var namespace = errors
        namespace[name] = Constructor;
    }
    errors.makeError = makeError;
    /**
     * here the definitions go
     */
    makeError('Error');
    makeError('NotImplemented', undefined , new errors.Error);
    makeError('Assertion', undefined , new errors.Error);
    makeError('Value', undefined , new errors.Error);
    makeError('Type', undefined , new TypeError);
    makeError('Dependency', undefined , new errors.Error);
    makeError('Parser', undefined , new errors.Error);
    makeError('IO', undefined , new errors.Error);
    makeError('IONoEntry', undefined, new errors.IO)
    makeError('IOEntryExists', undefined, new errors.IO)
    // the following IO errors are optional for IO implementations
    makeError('IONotDir', undefined, new errors.IO)
    makeError('IOIsDir', undefined, new errors.IO)
    makeError('IONotEmpty', undefined, new errors.IO)
    makeError('NameTranslation', undefined , new errors.Error);
    makeError('GlifLib', undefined , new errors.Error);
    makeError('Key', undefined , new TypeError);
    
    /**
     * if expression is false errors.Assertion is thrown
     * pass a message to explain yourself 
     **/
    errors.assert = function(exp, message) {
        if (!exp) {
            throw new errors.Assertion(message);
        }
    };
    errors.warn = function(message) {
        if(typeof console !== 'undefined' && console.log)
            console.log('WARNING: ' + message);
    };
    
    return errors;
});

define('obtain/Promise',[], function() {
    
    /**
     * This is a module to pull in an Ecmascript 6 compatible Promise
     * implementation for NodeJS. For browsers: only decent/current browsers
     * are supported. Older firefox may have Promise by setting in
     * "dom.promise.enabled" in about:config to true.
     */
    if(typeof window !== 'undefined')
        if(window.Promise)
            return window.Promise
        else
            throw new Error('Your Browser doesn\'t support promises yet')
    else
    // expect node.js and expect the AMD Loader to provide the original node require
        return require.nodeRequire('lie')
});

define('obtain/obtain',['./Promise'], function(Promise) {
    
    function NotImplementedError(){}
    
    function Expectation(name) {
        Object.defineProperty(this, 'name', {
            get: function() {return name;}
        });
    }
    Expectation.prototype = Object.create(Error.prototype)
    Expectation.prototype.toString = function expectationString() {
        return '<Expectation ' + this.name +'>'
    }

    
    function Argument(value) {
        Object.defineProperty(this, 'value', {
            get: function() { return value; }
        });
    }
    Argument.prototype.toString = function argumentString() {
        return '<Argument ' + this.value +'>'
    }
    
    /**
     * 
     * args may be an empty list, if this is the definition of an callerArgument.
     * That is a dependency that gets injected when calling the method.
     * 
     */
    function Dependency(name, async,
                        args/* [argumentNames, ... , function getter] */) {
        var args = args.slice(0) // make a copy and so don't change the outer world
          , getter = args.pop()
          , dependencies = []
          , skip = async ? {_callback: null, _errback: null} : {}
          , i = 0
          ;
        
        // Dependencies of this Dependency (Expectations) are everything
        // where typeof x === 'string' e.G. strings created with the string
        // literal. To pass a string as string argument use: new String('value')
        // So typeof x will be 'object' or use the Argument constructor of
        // this package: new Argument('value')
        
        // Exclude all args that are no Expectations but the value to be
        // passed itself.
        
        
        // dependencies are cleaned args: no doubles, no specials,
        // no curried values. Specials are '_callback' and '_errback',
        // although this api may change soon!
        for(;i<args.length; i++) {
            // this is a "curried" argument, not an Expectation
            if(typeof args[i] !== 'string' || args[i] in skip)
                continue;
            skip[args[i]] = null
            dependencies.push(args[i])
        }
        
        Object.defineProperty(this, 'name', {
            get: function() { return name; }
        });
        
        Object.defineProperty(this, 'async', {
            get: function() { return !!async; }
        });
        
        Object.defineProperty(this, 'getter', {
            get: function() { return getter; }
        });
        
        Object.defineProperty(this, 'args', {
            get: function() { return args.slice(0); }
        });
        
        Object.defineProperty(this, 'hasDependencies', {
            get: function() { return !!dependencies.length; }
        });
        
        Object.defineProperty(this, 'dependencyCount', {
            get: function() { return dependencies.length; }
        });
        
        Object.defineProperty(this, 'dependencies', {
            get: function() { return dependencies.slice(0); }
        });
    }
    var _Dp = Dependency.prototype;
    
    _Dp.toString = function dependencyString() {
        return '<Dependency ' + this.name +'>'
    }
    
    _Dp._getArg = function(getValue, item) {
        if(typeof item === 'string')
            // may throw an Expectation
            return getValue(item);
        return item instanceof Argument ? item.value : item;
    }
    
    _Dp.getArgs = function(getValue/* a function*/,
            callback /* if this.async */, errback /* if this.async */) {
        
        // depending on the arguments and callback style of this method
        // we need to figure out how to call it:
        var i=0
          , args = this.args
          , values = []
          , specialIndexes = {_callback: [], _errback: []}
          , unified_callback
          ;
        
        if(!this.async) {
            for(;i<args.length;i++)
                values.push(this._getArg(getValue, args[i]))
        }
        else {
            
            for(;i<args.length;i++) {
                if(args[i] in specialIndexes) {
                    specialIndexes[args[i]].push(i)
                    values.push(null) // will be filled below
                }
                else
                    values.push(this._getArg(getValue, args[i]))
            }
            
            // figure out the callback style
            if(!specialIndexes._errback.length)
                // define
                unified_callback = function(error, result) {
                    if(error !== null && error !== undefined)
                        errback(error)
                    else
                        callback(result);
                };
            else
                for(i=0; i<specialIndexes._errback.length; i++)
                    values[specialIndexes._errback[i]] = errback;
            
            for(i=0; i<specialIndexes._callback.length; i++)
                values[specialIndexes._callback[i]] = unified_callback || callback;
            // if neither _callback nor _errback where defined it's still
            // possible for the method to return a promise
        }
        return values
    }
    

    function DependencyFrame(dependency) {
        this.name = dependency.name;
        this.visitDependencies = dependency.hasDependencies;
        this.dependency = dependency;
        this.dependencyCount = dependency.dependencyCount;
    }

    function AsyncExecutionException(){}
    
    function AssertionFailed(message) {
        this.message = message;
        this.name = "AssertionFailed";
        if(typeof Error.captureStackTrace === 'function')
            Error.captureStackTrace(this, AssertionFailed);
        else
            this.stack = new Error().stack
    }
    AssertionFailed.prototype = Object.create(Error.prototype)
    
    function assert(test, message) {
        if(!test)
            throw new AssertionFailed(message);
    }
    
    function DependencyGraphError(message) {
        this.message = message;
        this.name = "DependencyGraphError";
        if(typeof Error.captureStackTrace === 'function')
            Error.captureStackTrace(this, AssertionFailed);
        else
            this.stack = new Error().stack
    }
    DependencyGraphError.prototype = Object.create(Error.prototype)
    
    function DependencyGraph(
            syncGetters, asyncGetters, callerArguments, job) {
        this.asyncGetters = asyncGetters;
        this.syncGetters = syncGetters;
        
        this._cache = {
          // caches the results of getDependency
            _asyncDependencies: {}
          , _syncDependencies: {}
          , _callerArgumentsDependencies: {}
          // caches the results of _getEvaluationOrder
          , asyncEvaluation: {}
          , syncEvaluation: {}
        }
        
        // list of argument names of the 'job'
        this.callerArguments = callerArguments instanceof Array
            ? callerArguments
            : [];
        
        this.job = job;
    }
    
    var _DGp = DependencyGraph.prototype;
    
    _DGp._nameIsCallerArg = function(name) {
        var i=0;
        for(;i<this.callerArguments.length;i++)
            if(this.callerArguments[i] === name)
                return true;
        return false;
    }
    
    /**
     * Get the Dependency instance for name.
     * If mayBeAsync is true and an asyncGetter for name is defined,
     * the Dependency will resolve asynchronous. Otherwise it will be
     * synchronous.
     * 
     * caches created Dependency instances, these are reuseable
     */
    _DGp.getDependency = function(mayBeAsync, name) {
        var isAsync = false
          , isArgument = false
          , cache
          , getterDef
          , nameIsCallerArg
          , i=0
          ;
        if(this._nameIsCallerArg(name)) {
            // caller arguments are sync, one could say
            isArgument = true
            cache = this._cache._callerArgumentsDependencies
        }
        else if(mayBeAsync && name in this.asyncGetters) {
            isAsync = true;
            cache = this._cache._asyncDependencies;
        }
        else if(!(name in this.syncGetters))
            throw new DependencyGraphError(['Name "',name, '" not found '
                                      +'in DependencyGraph.'].join(''));
        else
            cache = this._cache._syncDependencies;
        
        if(!(name in cache)) {
            getterDef = !isArgument
                // pick the right implementation
                ? (isAsync ? this.asyncGetters : this.syncGetters)[name]
                // an argument has no definition
                : [];
            
            cache[name] = new Dependency(name, isAsync, getterDef)
        }
        return cache[name];
    }
    
    /**
     * prepare evaluation
     */
    _DGp._getEvaluationOrder = function (async, startNode) {
        var stack = []
        , dependencyCount = {} // return value
        , dependents = {} // return value
        , visiting = {} // detect circles
        , visited = {} // detect circles
        , path = [] // only needed for good error reporting
        , frame, length, i, dependency, getFrame
        ;
        
        // factory and currying the async away
        getFrame = function(name) {
            return new DependencyFrame(this.getDependency(async, name));
        }.bind(this);
        
        stack.push(getFrame(startNode));
        dependents[startNode] = [];
        while(stack.length) {
            frame = stack[stack.length-1];
            
            if(frame.name in visited) {
                stack.pop(); // clear frame
                continue;
            }
            
            if(frame.visitDependencies && (frame.name in visiting))
                // I think a direct error is better here. However, we could
                // collect all found strongly connected components and return
                // these. That might ease debugging or make it harder.
                throw new DependencyGraphError(['Circle detected but the '
                            , 'graph must be acyclic!'
                            , 'Current frame.name:', frame.name
                            , 'Path:', path.join('->')
                            , 'strongly connected component:'
                            , path.slice(path.indexOf(frame.name)).concat([frame.name]).join('->')
                            ].join(' '));
            
            // path is only used for the error message above
            path.push(frame.name);
            
            dependencyCount[frame.name] = frame.dependencyCount;
            if(frame.visitDependencies) {
                // entering the frames dependencies
                visiting[frame.name] = null;
                frame.visitDependencies = false;
                
                for(i=0; i<frame.dependencyCount; i++) {
                    dependency = frame.dependency.dependencies[i];
                    
                    // create the transpose graph
                    if(!(dependency in dependents))
                        dependents[dependency] = [];
                    // frame.name is a dependent of dependency
                    dependents[dependency].push(frame.name);
                    
                    if(dependency in visited)
                        // shortcut: this will be detected at the beginning of
                        // the while loop anyways, so we save us from creating,
                        // pushing and then popping the frame
                        continue;
                    
                    // create a new frame
                    // Frame.visitDependencies is true when the dependency has any dependencies
                    stack.push(getFrame(dependency));
                }
            }
            else {
                // leaving the frame
                visited[frame.name] = null;
                path.pop();
                stack.pop();
            }
        }
        return [dependencyCount, dependents]
    }
    
    /**
     * Return the result of _getEvaluationOrder (with underscore).
     * The result will be cached for later possible executions.
     */
    _DGp.getEvaluationOrder = function(async, startNode) {
        var cache = async
            ? this._cache.asyncEvaluation
            : this._cache.syncEvaluation
          , cacheItem
          , copy = [{}, {}]
          , k
          ;
        if(!(startNode in cache))
            cache[startNode] = this._getEvaluationOrder(async, startNode)
        cacheItem = cache[startNode];
        for(k in cacheItem[0])
            copy[0][k] = cacheItem[0][k];
        for(k in cacheItem[1])
            copy[1][k] = cacheItem[1][k].slice();
        return copy;
    }
    
    function State(host, graph /* instanceof DependencyGraph */,
            args /* array: [async [, arguments ... ]] */) {
        var i=0, callbackPromise;
                
        this._host = host;
        this._graph = graph;
        
        this._async = args[0];
        this._args = args.slice(1);
        
        if(!this._async) {
            this.promise = undefined;
            this._resolvePromise = undefined;
            this._rejectPromise = undefined;
        }
        else {
            // just store these methods, to resolve or reject later
            this.promise = new Promise(function(resolve, reject) {
                this._resolvePromise = resolve;
                this._rejectPromise = reject;
            }.bind(this))
            // The user can opt-in to use callback and errback or a unified callback
            if(typeof this._async === 'object') {
                // we allow unfied style and callback/errback style at the
                // same time, although it's not really useful
                if(this._async.unified)
                    // unified style: unified_callback(error, result)
                    // convert it to divided style
                    callbackPromise = this.promise.then(
                        function(result){ this.unified(undefined, result)}.bind(this._async)
                      , function(error){ this.unified(error)}.bind(this._async)
                    )
                if(this._async.callback || this._async.errback)
                    callbackPromise = this.promise.then(this._async.callback || undefined,
                                      this._async.errback || undefined)
                
                if(callbackPromise) {
                    // Handle errors inside of the callbacks.
                    // FIXME: is there a better way to handle errors that
                    // happen inside of the callbacks?
                    // How to react on an error within an errorhandler,
                    // when the calling code has no way to get noticed? :-(
                    callbackPromise.then(undefined, function(err) {
                        console.log('unhandled error in callback', err, err.stack)
                        throw err;
                    })
                    callbackPromise = this.promise;
                }
            }
        }
        
        this._obtained = {};
        
        // callerArguments are already obtained
        for(;i<this._graph.callerArguments.length; i++)
            this._obtained[this._graph.callerArguments[i]] = this._args[i];
        this._args.unshift(this._obtainAPI.bind(this));
        
        this._waitingFor = {}
        this._waitingCount = 0
        
        this._dependencyCounters = null;
        this._dependents = null;
        
        this._isShutDown = false
    }
    
    // State.prototype = Object.create(null);
    var p = State.prototype;
    
    /**
     * keep track of tasks we are waiting for
     */
    p.addWaitingAsync = function(dependency) {
        assert(!(dependency in this._waitingFor), 'Already waiting for '
                                                  + dependency)
        // Useful? Add a time when waiting started, or a setTimeout for
        // timeout control or such?
        this._waitingFor[dependency] = null;
        this._waitingCount += 1;
        return this._waitingCount
    }
    
    /**
     * clean up when the task finishes
     */
    p.removeWaitingAsync = function(dependency) {
        assert(dependency in this._waitingFor, 'Not waiting for '
                                                  + dependency)
        delete this._waitingFor[dependency];
        this._waitingCount -= 1;
        return this._waitingCount;
    }
    
    Object.defineProperty(p, 'waitingAsyncCount', {
        get: function() { return this._waitingCount; }
    });
    
    p.getDependency = function(name) {
        return this._graph.getDependency(this._async, name);
    }
    
    p._removeDependency = function(dependency) {
        var dependents = this._dependents[dependency.name] || []
          , dependencyCounters = this._dependencyCounters
          , i=0
          , cleaned = []
          , dependent
          ;
        // substract 1 from each  dependencyCounters[dependent] (because
        // dependency is resolved)
        // if a dependencyCounter is 0 the dependent can be executed
        for(;i<dependents.length;i++) {
            dependent = this.getDependency(dependents[i])
            dependencyCounters[dependent.name] -= 1;
            if (dependencyCounters[dependent.name] === 0)
                cleaned.push(dependent)
        }
        return cleaned;
    }
    
    p.getValue = function(name) {
        if(!(name in this._obtained))
            throw new Expectation(name)
        return this._obtained[name]
    }
    
    /**
     * use: this._dependencyCallback.bind(this, dependency)
     */
    p._dependencyCallback = function(dependency, result) {
        var cleaned;
        if(this._isShutDown)
            // FIXME: start logging or provide a status otherwise
            return;
        this.removeWaitingAsync(dependency)
        this._obtained[dependency.name] = result
        cleaned = this._removeDependency(dependency)
        try {
            this._resolve.apply(this, cleaned)
        }
        catch (error) {
            this._errorShutdown();
            this._rejectPromise(error);
            return;
        }
        if(!this.waitingAsyncCount)
            // that's it, nothing to do anymore
            this.execute();
    }
    
    p._errorShutdown = function() {
        this._isShutDown = true;
        // TODO: log all dependencies that callback or errback after shutdown
        // TODO: .abort() all async dependencies we are waiting for
        // and don't execute()/_resolve() further!
        // see: https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest#abort%28%29
        // as an example abort API
    }
    
    /**
     * use: this._dependencyErrback.bind(this, dependency)
     */
    p._dependencyErrback = function(dependency, error) {
        if(this._isShutDown)
            // FIXME: start logging or provide a status otherwise
            return;
        this.removeWaitingAsync(dependency);
        this._errorShutdown()
        this._rejectPromise(error)
    }
    
    
    p._call = function(dependency) {
        var namedArgs = {}
          , i=0
          , args
          , getValue = this.getValue.bind(this)
          , callback, errback, promise
          ;
        if(dependency.async) {
            callback = this._dependencyCallback.bind(this, dependency);
            errback = this._dependencyErrback.bind(this, dependency);
            args = dependency.getArgs(getValue, callback, errback)
            
            this.addWaitingAsync(dependency)
            promise = dependency.getter.apply(this._host, args)
            // ducktyping
            if(promise && typeof promise.then === 'function')
                // from: https://developer.mozilla.org/en-US/docs/Mozilla/JavaScript_code_modules/Promise.jsm/Promise
                // Note: If the onFulfill callback throws an exception,
                // the onReject callback is not invoked. You can register
                // a rejection callback on the returned promise instead,
                // to process any exception occurred in either of the callbacks
                // registered on this promise.
                promise.then(callback).then(null, errback)
            
        }
        else {
            args = dependency.getArgs(getValue)
            return dependency.getter.apply(this._host, args)
        }
    }
    
    /**
     * Executes all dependencies given by the arguments.
     * First execute all asynchronous dependencies, as these probably
     * dispatch to a server or such and run nonblocking (hopefully,
     * where is the point otherwise?)
     */
    p._resolve = function(/* dependency, ... */) {
        var resolved = Array.prototype.slice.call(arguments)
          , sosd = [] // stack of synchconous dependencies
          , dependency
          , cleaned
          ;
        
        
        // IMPORTANT! The logical or || will execute dependency = sosd.pop()
        // only if the first expression returns something false.
        // so we first we _call all async dependencies and then the sync
        // ones. This is done, because we wan't to dispatch the async requests
        // ASAP.
        while((dependency = resolved.pop()) || (dependency = sosd.pop())) {
            if(dependency.name in this._obtained)
                continue
            else if(dependency.async)
                this._call(dependency)
            else if(resolved.length !== 0)
                // execute after all async dependencies have been called
                sosd.push(dependency)
            else {
                // execute the sync dependency
                this._obtained[dependency.name] = this._call(dependency);
                cleaned = this._removeDependency(dependency)
                resolved.push.apply(resolved, cleaned)
            }
        }
    }
    
    p._obtain =  function _obtain(key) {
        assert(!(key in this._obtained), 'Key "'+ key +'" must not be '
                                        + 'in this._obtained, but it is.')
        
        // order is a topological sorting as a starting point
        var order = this._graph.getEvaluationOrder(this._async, key)
          , resolved = []
          , k
          , dependencyCounters = this._dependencyCounters = order[0]
          , dependents = this._dependents = order[1]
        ;
        // Some values are already known, from callerArguments or previous
        // calls to _obtainAPI
        for(k in this._obtained)
            // Don't use the return value here, as the next step covers that.
            this._removeDependency(this.getDependency(k))
        // Every dependency with a count of 0 can be executed now
        for(k in dependencyCounters) {
            if (dependencyCounters[k] === 0)
                resolved.push(this.getDependency(k));
        }
        
        this._resolve.apply(this, resolved)
        if(this.waitingAsyncCount)
            // interrupt here, the callback will restart the thread
            throw new AsyncExecutionException()
        // if there wasn't any async dependency we should have a result
        // it has to be in this._obtained at this point
        
        assert(key in this._obtained, 'Key "'+ key +'" must be in '
                                    + 'this._obtained, but it isn\'t.')
    }
    
    p._obtainAPI = function _obtainAPI(key) {
        if (!(key in this._obtained))
            // will raise AsyncExecutionException when needed
            this._obtain(key);
        // This will only be executed when the value is already there.
        // If we have to wait AsyncExecutionException did interrupt already.
        return this._obtained[key];
    }
    
    p.execute = function execute () {
        var result;
        try {
            // job is expected to call _obtainAPI zero or more times
            result = this._graph.job.apply(this._host, this._args);
        }
        catch(e) {
            if(e instanceof AsyncExecutionException) {
                // the receiver will call execute again
                return;
            }
            
            if(!this._async){
                throw e;
            }
            this._errorShutdown();
            this._rejectPromise(e);
            return;
        }
        
        // got a result
        if(!this._async)
            return result;
        this._resolvePromise(result);
    }
    
    function executionEnvironmentFactory(syncGetters, asyncGetters,
            callerArguments, job) {
        var graph = new DependencyGraph(syncGetters, asyncGetters,
                                        callerArguments, job);
        return function runner( /* async, [ ... arguments, ]*/) {
            // 'this' is the host
            var state = new State(this, graph, Array.prototype.slice.call(arguments))
              , async = arguments[0]
              ;
            // There needs to be an assurance that an async job is
            // deferred (asynchronously) at least once! Theoretically,
            // since a developer might not expect stuff like an immediate
            // execution when calling an async method and since we have
            // side effects in javascript ASAP is just right.
            // Without side effects it would be better to wait and see
            // if an extra decoupling is needed (when there was no async
            // execution after resolving)
            // FIXME: Think about doing this smarter.
            if (!async)
                return state.execute();
            setTimeout(state.execute.bind(state), 0)
            return state.promise;
        }
    }
    return {
        factory: executionEnvironmentFactory
      , Argument: Argument
      , DependencyGraphError: DependencyGraphError
    }
});

/**
 * Copyright (c) 2011, Lasse Fister lasse@graphicore.de, http://graphicore.de
 *
 * You should have received a copy of the MIT License along with this program.
 * If not, see http://www.opensource.org/licenses/mit-license.php
 *
 */

define('ufojs/main',['./errors'], function(errors) {
    
    var ValueError = errors.Value,
        TypeError = errors.Type;

    /**
     * enhance helps with class building
     * FIXME: put description in here
     */
    var enhance =  function(constructor, blueprint)
    {
        for(var i in blueprint)
        {
            //TODO:
            // use Object.getOwnPropertyDescriptor and Object.defineProperty
            // instead of __lookup(S/G)etter__ and __define(S/G)etter__
            // its the future
            var getter = blueprint.__lookupGetter__(i),
                setter = blueprint.__lookupSetter__(i);
            if ( getter || setter ) {
                if ( getter )
                    constructor.prototype.__defineGetter__(i, getter);
                if ( setter )
                    constructor.prototype.__defineSetter__(i, setter);
            } else
                constructor.prototype[i] = blueprint[i];
        };
    };

    /**
     * check whether val is a number and not NaN
     */
    function isNumber(n) {
        return typeof n === 'number' && isFinite(n);
    };

    /**
     * check whether val is an integer
     */
    function isInt (n) {
        // n === n NaN will return false
        // n|0 rounds
        return typeof n === 'number' && n === n && n === (n|0);
    }

    /**
     * check whether val is a float
     */
    function isFloat (n) {
        // n === n NaN will return false
        // n|0 rounds
        return typeof n === 'number' && isFinite(n) && n !== (n|0);
    }

    /**
     * check whether the string is made out of digits only
     */
    var _isDigitsTest = /^[0-9]+$/;
    function isDigits(str){
        if( typeof str != 'string') return false;
        return _isDigitsTest.test(str);
    }
    /**
     * check whether the string is formatted like a propper int
     */
    var _isIntStringTest = /^[+-]?[0-9]+$/;
    function isIntString(str){
        if( typeof str != 'string') return false;
        return _isIntStringTest.test(str);
    }

    /**
     * check whether the string is formatted like a propper float
     */
    var _isFloatStringTest = /^([+-]?(((\d+(\.)?)|(\d*\.\d+))([eE][+-]?\d+)?))$/;
    function isFloatString(str) {
        if( typeof str != 'string') return false;
        return _isFloatStringTest.test(str);
    }


   /**
    * this is used like the python range method
    *
    * examples:
    * for(var i in range(10)){
    *     console.log(i)
    *     //0 1 2 3 4 5 6 7 8 9
    * }
    * for(var i in range(10)){
    *     console.log(i)
    *     //0 1 2 3 4 5 6 7 8 9
    * }
    * for(var i in range(5, 15, 3)) {
    *     console.log(i)
    *     //5 8 11 14
    * }
    **/
    var range = function (/*[start], stop, [step]*/)
    {
        //here comes alot of input validation
        //to mimic what python does
        var start = 0,
            step = 1,
            stop, condition;
        if (arguments.length < 1) {
            throw new TypeError(
                'range() expected at least 1 arguments, got 0 '
                + arguments.length
            );
        } else if (arguments.length > 3) {
            throw new TypeError(
                'range() expected at most 3 arguments, got '
                + arguments.length
            );
        } else if (arguments.length == 1) {
            stop = arguments[0];
        } else if(arguments.length >= 2 ) {
            start = arguments[0];
            stop = arguments[1];
            if(arguments.length == 3)
                step = arguments[2];
        }
        var vals = [ ['start', start], ['stop', stop], ['step', step] ];
        for (var i in vals) {
            var val = vals[i];
            if (!isInt(val[1])) {
                var type = typeof val[1];
                if(type === 'number') type = 'float';
                throw new TypeError(
                    'range() integer ' + val[0]
                    + ' argument expected, got ' + type);
            }
        }
        if(step === 0)
            throw new ValueError('range() step argument must not be zero');

        //now the important stuff
        if (step > 0)
            condition = function(i) { return i < stop };
        else
            condition = function(i) { return i > stop };

        var list = {};//list is an object because the array prototype might be extended
        for (var i = start; condition(i); i += step) {
            //yield i;//oh future looking forward to hearing from you
            list[i] = i;
        }
        return list;
    }

    /**
     * Decimal adjustment of a number.
     *
     * @param   {String}    type    The type of adjustment: "round" | "ceil" | "floor"
     * @param   {Number}    value   The number.
     * @param   {Integer}   exp     The exponent (the 10 logarithm of the adjustment base).
     * @returns {Number}            The adjusted value.
     *
     * Note: to have a precision of 2 decimal places exp should be -2
     *
     * This is the implementation of decimal rounding found at mdn:
     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/round#Example%3a_Decimal_rounding
     */
    function decimalAdjust(type, value, exp) {
        // If the exp is undefined or zero...
        if (typeof exp === 'undefined' || +exp === 0) {
            return Math[type](value);
        }
        value = +value;
        exp = +exp;
        // If the value is not a number or the exp is not an integer...
        if (isNaN(value) || !(typeof exp === 'number' && exp % 1 === 0)) {
            return NaN;
        }
        // Shift
        value = value.toString().split('e');
        value = Math[type](+(value[0] + 'e' + (value[1] ? (+value[1] - exp) : -exp)));
        // Shift back
        value = value.toString().split('e');
        return +(value[0] + 'e' + (value[1] ? (+value[1] + exp) : exp));
    }

    // Decimal round
    /**
     * Rounds val.
     *
     * Use the 'decimalPlaces' argument to round to a specific decimal
     * position. To have a precision of 2 decimal places decimalPlaces
     * should be 2
     *
     * Fontforge defines a similar method.
     * Its good to compare values that potentially have some floating
     * point rounding errors
     */
    function round(value, decimalPlaces) {
        return decimalAdjust('round', value,
            typeof decimalPlaces === 'number'
                ? -decimalPlaces
                : decimalPlaces
        );
    };

    // Decimal floor
    /**
     * Rounds val down.
     *
     * Use the 'decimalPlaces' argument to round to a specific decimal
     * position. To have a precision of 2 decimal places decimalPlaces
     * should be 2
     */
    function floor(value, decimalPlaces) {
        return decimalAdjust('floor', value,
            typeof decimalPlaces === 'number'
                ? -decimalPlaces
                : decimalPlaces
        );
    };

    // Decimal ceil
    /**
     * Rounds val up.
     *
     * Use the 'decimalPlaces' argument to round to a specific decimal
     * position. To have a precision of 2 decimal places decimalPlaces
     * should be 2
     */
    function ceil(value, decimalPlaces) {
        return decimalAdjust('ceil', value,
            typeof decimalPlaces === 'number'
                ? -decimalPlaces
                : decimalPlaces
        );
    };

    /**
     * Returns a function that rounds to a decimal precision recursively
     * all items of type number in all items that are instances of array
     * and returns the result
     *
     * Use the 'decimalPlaces' argument to round to a specific decimal
     * position. To have a precision of 2 decimal places decimalPlaces
     * should be 2
     */
    var roundRecursiveFunc = function(decimalPlaces) {
        // the function existing in this closure is important, so the
        // function can call itself. just saying that we can't return the
        // function directly
        var roundRecursive = function(item) {
            if(item instanceof Array)
                return item.map(roundRecursive);
            if(typeof item === 'number')
                return round(item, decimalPlaces);
            return item;
        };
        return roundRecursive;
    }

    /**
     * Rounds to a decimal precision recursively all items of type
     * number in all items that are instances of array and returns the
     * result.
     *
     * Use the 'decimalPlaces' argument to round to a specific decimal
     * position. To have a precision of 2 decimal places decimalPlaces
     * should be 2
     */
    var roundRecursive = function(item, decimalPlaces) {
        var roundRecursive = roundRecursiveFunc(decimalPlaces);
        return roundRecursive(item);
    };


    /**
    * parseDate came with the following header. I just tailored it in here.
    * it returns a timestamp indicating the milliseconds since the Unix Epoch
    *
    * Date.parse with progressive enhancement for ISO 8601 <https://github.com/csnover/js-iso8601>
    *  2011 Colin Snover <http://zetafleet.com>
    * Released under MIT license.
    */
    var origParse = Date.parse, numericKeys = [ 1, 4, 5, 6, 7, 10, 11 ],
        parseDate = function (date) {
        var timestamp, struct, minutesOffset = 0;
        // ES5 15.9.4.2 states that the string should attempt to be parsed as a Date Time String Format string
        // before falling back to any implementation-specific date parsing, so thats what we do, even if native
        // implementations could be faster
        // 1 YYYY 2 MM 3 DD 4 HH 5 mm 6 ss 7 msec 8 Z 9  10 tzHH 11 tzmm
        if ((struct = /^(\d{4}|[+\-]\d{6})(?:-(\d{2})(?:-(\d{2}))?)?(?:T(\d{2}):(\d{2})(?::(\d{2})(?:\.(\d{3}))?)?(?:(Z)|([+\-])(\d{2})(?::(\d{2}))?)?)?$/.exec(date))) {
            // avoid NaN timestamps caused by undefined values being passed to Date.UTC
            for (var i = 0, k; (k = numericKeys[i]); ++i) {
                struct[k] = +struct[k] || 0;
            }

            // allow undefined days and months
            struct[2] = (+struct[2] || 1) - 1;
            struct[3] = +struct[3] || 1;

            if (struct[8] !== 'Z' && struct[9] !== undefined) {
                minutesOffset = struct[10] * 60 + struct[11];

                if (struct[9] === '+') {
                    minutesOffset = 0 - minutesOffset;
                }
            }

            timestamp = Date.UTC(struct[1], struct[2], struct[3], struct[4], struct[5] + minutesOffset, struct[6], struct[7]);
        } else {
            timestamp = origParse ? origParse(date) : NaN;
        }

        return timestamp;
    };

    /**
     * This is a wrapper around typeof and instanceof
     * it's there to make me type less and loosely inspired by the python
     * builtin instanceof.
     */
    var isInstance = function(
        value,
        types /* function or typeof string or a list of these */
    ) {
        if(arguments.length < 2)
            throw new TypeError(
                'isInstance() expects 2 arguments, got ' + arguments.length
            );
        var types = (types instanceof Array) ? types : [types],
            typeOfType, i;
        for(i = 0; i < types.length; i++) {
            typeOfType = typeof types[i];
            if( typeOfType === 'function' && value instanceof types[i]
                || types[i] === 'int' && isInt(value)
                || types[i] === 'float' && isFloat(value)
                || types[i] === 'NaN' && value !== value
                || types[i] === 'null' && value === null
                || types[i] === 'Infinity' && value === Number.POSITIVE_INFINITY
                || types[i] === '-Infinity' && value === Number.NEGATIVE_INFINITY
                // this will test strings like 'number', 'undefined', string
                || typeOfType === 'string'
                    && typeof value === types[i]
                    && value === value /*not true for NaN*/
            )
                return true;
        }
        return false;
    };


    /**
     * String.prototype.charCodeAt is broken , so mdn provides fixes.
     * https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/String/charCodeAt
     *
     * Example 2: Fixing charCodeAt to handle non-Basic-Multilingual-Plane
     * characters if their presence earlier in the string is unknown
     *
     * this version might be used in for loops and the like when it is
     * unknown whether non-BMP characters exist before the specified index
     * position.
     */
    function fixedCharCodeAt (str, idx) {
        // ex. fixedCharCodeAt ('\uD800\uDC00', 0); // 65536
        // ex. fixedCharCodeAt ('\uD800\uDC00', 1); // 65536
        idx = idx || 0;
        var code = str.charCodeAt(idx);
        var hi, low;
        if (0xD800 <= code && code <= 0xDBFF) { // High surrogate (could change last hex to 0xDB7F to treat high private surrogates as single characters)
            hi = code;
            low = str.charCodeAt(idx+1);
            if (isNaN(low)) {
                throw 'High surrogate not followed by low surrogate in fixedCharCodeAt()';
            }
            return ((hi - 0xD800) * 0x400) + (low - 0xDC00) + 0x10000;
        }
        if (0xDC00 <= code && code <= 0xDFFF) { // Low surrogate
            // We return false to allow loops to skip this iteration since should have already handled high surrogate above in the previous iteration
            return false;
            /*hi = str.charCodeAt(idx-1);
            low = code;
            return ((hi - 0xD800) * 0x400) + (low - 0xDC00) + 0x10000;*/
        }
        return code;
    }

    // make out of a list of strings an object with those strings as keys
    // for easy membership testing with the "in" keyword
    function setLike(list, fill /* default true*/) {
        if(fill === undefined) fill = true;
        var setLike = {};
        for(var i=0; i<list.length; i++)
            setLike[list[i]] = fill;
        return setLike;
    }


    return {
        enhance: enhance,
        range: range,
        round: round,
        roundRecursiveFunc: roundRecursiveFunc,
        roundRecursive: roundRecursive,
        isNumber: isNumber,
        isInt: isInt,
        isFloat: isFloat,
        isDigits: isDigits,
        isIntString: isIntString,
        isFloatString: isFloatString,
        parseDate: parseDate,
        isInstance: isInstance,
        fixedCharCodeAt: fixedCharCodeAt,
        setLike: setLike
    }
});

/**
 * Copyright (c) 2011, Lasse Fister lasse@graphicore.de, http://graphicore.de
 * 
 * You should have received a copy of the MIT License along with this program.
 * If not, see http://www.opensource.org/licenses/mit-license.php
 * 
 * This returns the browsers xml tools or if in nodejs a mapping to the
 * libxmljs api so that it can be used like the w3c tools.
 * 
 * IMPORTANT for nodejs with libxmljs: As the need of this project regarding
 * xml tools is not so big, there will likely be no full DOM w3c api
 * available. Thus, things like running jQuery on a libxmljs element won't
 * work.
 * As it appears the jsdom people are making exactly that possible, so the
 * notice above might become outdated.
 */

define('ufojs/xml/main',[
    'ufojs/errors'
], function(
    errors
) {
    
    var DependencyError = errors.Dependency
      , TypeError = errors.Type
      , NotImplementedError = errors.NotImplemented
      , ParserError = errors.Parser
      , xmlDeclaration = '<?xml version="1.0" encoding="UTF-8"?>'
      , xml, implementation
      , Node
      ;
    
    // from https://developer.mozilla.org/en-US/docs/Using_XPath
    // Evaluate an XPath expression aExpression against a given DOM node
    // or Document object (aNode), returning the results as an array
    function evaluateXPath(aNode, aExpr) {
        var xpe = new xml.XPathEvaluator()
          , nsResolver = xpe.createNSResolver(
                aNode.ownerDocument == null
                    ? aNode.documentElement
                    : aNode.ownerDocument.documentElement
            )
          , result = xpe.evaluate(aExpr, aNode, nsResolver, 0, null)
          , found = []
          , res
          ;
        while (res = result.iterateNext())
            found.push(res);
        return found;
    }
    
    if(typeof DOMParser !== 'undefined') {
        
        var Parser = function() {
                this._parser = new DOMParser();
            }
          , Serializer = function() {
                this._serializer = new XMLSerializer();
            }
          ;
        implementation = 'w3c';
        Node = window.Node;
        //this is straightforward, we just map the apis that are there
        xml = {
            xmlDeclaration: xmlDeclaration,
            get implementation() {
                return implementation;
            },
            /**
             * This strange sort of extending is done because:
             * a) native objects can't be extended by the ussual prototype
             *    mechanism.
             * b) The browser parsers fail at throwing Errors when parsing
             *    fails, and we need a common api.
             */
            Parser: Parser,
            Serializer: Serializer,
            XPathEvaluator: XPathEvaluator,
            XPathResult: XPathResult,
        // XPathException is undefined in Firefox
        //    XPathException: XPathException,
            XSLTProcessor: XSLTProcessor,
            Node: Node,
            createDocument: function() {
                var args = [].slice.call(arguments)
                  , defaults = [null, null, null];
                
                if(args.length !== defaults.length)
                    args.push.apply(args, defaults.slice(args.length))
                return document.implementation.createDocument.apply(
                    document.implementation, args);
            },
            createDocumentType: function() {
                var args = [].slice.call(arguments);
                return document.implementation.createDocumentType.apply(
                    document.implementation, args);
            },
            parseXMLString: function(string) {
                var parser = new Parser();
                return parser.parseFromString(string, 'text/xml');
            },
            toString: function(doc) {
                return (new Serializer()).serializeToString(doc)
            },
            evaluateXPath: evaluateXPath
        }
        
        //TODO: implement more of the parser interfaces if needed
        Parser.prototype.parseFromString = function(markup, type) {
            var result = this._parser.parseFromString(markup, type);
            
            // in case of an error chrome returns an html document where
            // somwhere is a <parsererror> element embedded: 
            // <html xmlns="http://www.w3.org/1999/xhtml"><body><parsererror style=" ... "><h3> ...
            // sometimes its not html :/
            //
            // firefox returns a document like this:
            // <?xml-stylesheet href="chrome://global/locale/intl.css" type="text/css"?>
            // <parsererror xmlns="http://www.mozilla.org/newlayout/xml/parsererror.xml">
            // ...
            
            if(result.documentElement.tagName === 'parsererror')
                // this works in firefox
                throw new ParserError('XML DOMParser: ' + result.documentElement.textContent);
            // maybe, if we're going to parse xhtml we should try to find
            // more indicators. Right now html as root element is just fine,
            // because there is no other case for an html result in ufoJS.
            // cmon, sometimes its not html in webkit :-|
            // else if(result.documentElement.tagName === 'html') {
            else {
               // handle the webkit error if it is there
               // this is from: https://bugs.webkit.org/show_bug.cgi?id=13057
                   
                var nsResolverWebkit = function (prefix) {
                        if (prefix == "x")
                            return "http://www.w3.org/1999/xhtml";
                        return null;
                    }
                  , expression = "//x:parsererror//x:div"
                  , errorNode = (new XPathEvaluator())
                        .evaluate(expression, result, nsResolverWebkit, 0, null)
                        .iterateNext()
                  ;
               if (errorNode)
                   throw new ParserError('XML DOMParser: ' + errorNode.textContent);
            }
            return result;
        }
        
        Serializer.prototype.serializeToString = function(node) {
            var result = this._serializer.serializeToString(node);
            
            if(Node.DOCUMENT_NODE === node.nodeType
                        && result.indexOf('<?xml') !== 0)
                result = [xmlDeclaration, result].join('\n')
            return result;
        };
    }
    else {
        /**
        * this is for the nodejs environment
        * 
        * The impementation is not complete but enough for my purposes.
        * If there is a better W3C DOM environment for nodeJS please let me
        * know.
        * caveats:
        * The sax parser does not mention things that would be interesting
        * for xsl/xslt/dtd parsing
        * especially the Doctype of your document won't be recognized
        * 
        * The Serializer throws NotImplementedError on:
        * ENTITY_REFERENCE_NODE, ENTITY_NODE, NOTATION_NODE
        */
        
        
        // the files libs are loaded syncronously with requireJS handing over
        // the call to nodes commomJS require mechanism
        
        // jsdom is available via nodes npm or http://jsdom.org
        var r = require.nodeRequire
          , path = r('path')
          , dom = r('jsdom').dom.level3.core
            //dunno why i need to force node like this to load the files
          , jsdomPath = path.dirname(r.resolve('jsdom')) + '/jsdom/'
          , encodeHTML = r(jsdomPath + 'browser/htmlencoding.js').HTMLEncode
            // https://github.com/polotek/libxmljs
            // another sax parser is https://github.com/robrighter/node-xml 
          , xmlparser = r('libxmljs')
          , Parser = function(){}
          , Serializer = function(){}
          ;
        if(!dom)
            throw new DependencyError('No XML api available.');
        
        
        implementation = 'jsdom';
        Node  = dom.Node;
        xml = {
            xmlDeclaration: xmlDeclaration,
            Parser: Parser,
            Serializer: Serializer,
            XPathEvaluator: dom.XPathEvaluator,
            XPathResult: dom.XPathResult,
        //    XPathException: dom.XPathException,
            Node: Node,
            createDocument: function() {
                var args = [].slice.call(arguments),
                    implementation = new dom.DOMImplementation();
                return implementation.createDocument.apply(implementation, args);
            },
            createDocumentType: function() {
                var args = [].slice.call(arguments),
                    implementation = new dom.DOMImplementation();
                return implementation.createDocumentType.apply(implementation, args);
            },
            get implementation() {
                return implementation;
            },
            parseXMLString: function(string) {
                var parser = new Parser();
                return parser.parseFromString(string, 'text/xml');
            },
            toString: function(doc) {
                return (new xml.Serializer()).serializeToString(doc);
            },
            evaluateXPath: evaluateXPath
        };
        //FIXME: How would we get the doctype for our document?
        Parser.prototype.parseFromString = function(string, mimeType) {
            if(!(mimeType in {'text/xml': true, 'application/xml': true}))
                //so it's clear that we don't support html here
                throw new TypeError('MIME-Type must be an XML type like '
                    + '"text/xml" or "application/xml".');
            
            var options = {contentType: mimeType},
                doc = new dom.Document(options),
                currentElement = doc,
                totalElements = 0,
                parser,
                error;
            
            parser = new xmlparser.SaxParser({
                endDocument: function() {
                    var counted = doc.getElementsByTagName("*").length;
                    //errors.assert(
                    //    doc.getElementsByTagName("*").length === totalElements,
                    //    ['Expected', totalElements,
                    //        'elements but found', counted].join(' ')
                    //);
                },
                startElementNS: function(elem, attrs, prefix, uri, namespaces) {
                    totalElements++;
                    var element;
                    if(uri)
                        element = doc.createElementNS(uri, prefix+':'+elem);
                    else
                        element = doc.createElement(elem);
                    //attrs - an array of arrays: [[key, prefix, uri, value]]
                    attrs.map(function(attr){
                        var key = attr[0],
                            prefix = attr[1],
                            uri = attr[2],
                            value = attr[3];
                        if(uri)
                            element.setAttributeNS(
                                uri,
                                (prefix) ? prefix + ':' + key : key,
                                value
                            );
                        else
                            element.setAttribute(key, value);
                    });
                    namespaces.map(function(attr){
                        var name = attr[0],
                            value = attr[1];
                        element.setAttribute('xmlns:' + name, value || '');
                    });
                    
                    currentElement.appendChild(element);
                    currentElement = element;
                },
                endElementNS: function(elem, prefix, uri) {
                    currentElement = currentElement.parentNode;
                },
                characters: function(chars) {
                    var node = doc.createTextNode(chars);
                    currentElement.appendChild(node);
                },
                cdata: function(cdata) {
                    var node = doc.createCDATASection(cdata);
                    currentElement.appendChild(node);
                },
                comment: function(comment) {
                    var node = doc.createComment(comment);
                    currentElement.appendChild(node);
                },
                warning: function(message) {
                    errors.warn('XML SAX2 Parser: ' + message);
                },
                error: function(message) {
                    error = new ParserError('XML SAX2 Parser: ' + message);
                }
            });
            parser.parseString(string);
            if(error)
                throw error
            return doc;
        };
        
        var _serializer = {
            dispatch: function(node) {
                _serializer.renderer[node.nodeType].call(this, node);
            },
            renderer: {}
        };
        _serializer.renderer[dom.Node.ELEMENT_NODE] = function(node) {
            var empty = (node.childNodes.length === 0)
                , attributes = []
                , children = []
                , end = empty
                    ? ['/>']
                    : ['</', node.tagName, '>']
                ;
            
            this.push('<', node.tagName);
            Array.prototype.slice.call(node.attributes)
                                    .map(_serializer.dispatch, this);
            
            if(node.childNodes.length) {
                this.push('>');
                Array.prototype.slice.call(node.childNodes)
                                        .map(_serializer.dispatch, this);
                this.push('</', node.tagName, '>');
            }
            else
                this.push('/>');
        };
        _serializer.renderer[dom.Node.ATTRIBUTE_NODE] = function(node){
            //prepending a space before every attribute
            this.push(' ', node.name, '="', encodeHTML(node.nodeValue, true), '"');
        };
        _serializer.renderer[dom.Node.TEXT_NODE] = function(node){
            this.push(encodeHTML(node.nodeValue));
        };
        _serializer.renderer[dom.Node.CDATA_SECTION_NODE] = function(node) {
            this.push('<![CDATA[', node.nodeValue, ']]>');
        };
        _serializer.renderer[dom.Node.ENTITY_REFERENCE_NODE] = function(node) {
            throw new NotImplementedError('Rendering the node type ENTITY_REFERENCE_NODE.');
        };
        _serializer.renderer[dom.Node.ENTITY_NODE] = function(node) {
            throw new NotImplementedError('Rendering the node type ENTITY_NODE.');
        };
        _serializer.renderer[dom.Node.PROCESSING_INSTRUCTION_NODE] = function(node){
            this.push('<?', node.target, ' ', node.nodeValue,'?>');
        };
        _serializer.renderer[dom.Node.COMMENT_NODE] = function(node) {
            this.push('<!--', node.nodeValue, '-->');
        };
        _serializer.renderer[dom.Node.DOCUMENT_NODE] = function(node) {
            Array.prototype.slice.call(node.childNodes).map(_serializer.dispatch, this);
        };
        _serializer.renderer[dom.Node.DOCUMENT_TYPE_NODE] = function(node) {
            var quote;
                
            this.push('<!DOCTYPE ', node.name);
                
            if (node.publicId)
                // Public ID may never contain double quotes, so this is always safe.
                this.push(' PUBLIC "', node.publicId,'" ');
            if (node.systemId) {
                if (!node.publicId)
                    this.push(' SYSTEM ');
                // System ID may contain double quotes OR single quotes, never both.
                quote = (node.systemId.indexOf('"') > -1)
                    ? '\''
                    : '"';
                this.push(quote, node.systemId, quote);
            }
            this.push('>');
        };
        _serializer.renderer[dom.Node.DOCUMENT_FRAGMENT_NODE] = function(node) {
            return Array.prototype.slice.call(node.childNodes)
                                        .map(_serializer.dispatch, this);
        };
        _serializer.renderer[dom.Node.NOTATION_NODE] = function(node) {
            throw new NotImplementedError('Rendering the node type NOTATION_NODE.');
        };
        
        Serializer.prototype.serializeToString = function(node) {
            var tokens = [];
            if(Node.DOCUMENT_NODE === node.nodeType)
                tokens.push(xmlDeclaration, '\n')
            _serializer.dispatch.call(tokens, node);
            return tokens.join('');
        };
    }
    return xml;
});

/**
 * Copyright (c) 2011, Lasse Fister lasse@graphicore.de, http://graphicore.de
 * 
 * You should have received a copy of the MIT License along with this program.
 * If not, see http://www.opensource.org/licenses/mit-license.php
 * 
 * This Object is to store the "data" object of a plist file.
 * 
 * Since there is currently no case where I need the decoding/encoding
 * feature and since the window.btoa/atob are not available everywhere
 * this object is nothing more than a marker that the data came-from/should-end-in
 * a "data" Object of a plist file. Handling of decoding encoding is delayed.
 * See the commented out code if is helpful for the task.
 */
define('ufojs/plistLib/DataObject',[],function() {
    
    function DataObject(data) {
        this._data = data;
    }
    DataObject.prototype.valueOf = DataObject.prototype.toString = function(){return this._data;};
    return DataObject;
   /**
    * Do we need base64 encode/decode here?
    * 
    * This uses window.btoa and window.atob which are not available everywhere
    * so a common interface to this tasks would be nice.
    * from: https://developer.mozilla.org/en/DOM/window.btoa#Unicode_Strings
    *    "Unicode Strings:
    *     In most browsers, calling window.btoa on a Unicode string will
    *     cause a Character Out Of Range exception."
    * anyways, there is a workaround in the same article encoding strings to
    * utf-8
    
    function DataObject(base64Encoded){
        this.data = window.atob(base64Encoded);
    }
    
    enhance(DataObject, {
        toString: function(){
            return window.btoa(this.data)
        }
    });
    */
});

/**
 * Copyright (c) 2011, Lasse Fister lasse@graphicore.de, http://graphicore.de
 * 
 * You should have received a copy of the MIT License along with this program.
 * If not, see http://www.opensource.org/licenses/mit-license.php
 * 
 * This Object is to store the "integer" object of a plist file. Its needed
 * because the number object of javascript is always like a float.
 * 
 * note that doing things like
 * var i = IntObject(12);
 * i++;
 * makes it a number, no longer an IntObject
 */
define('ufojs/plistLib/IntObject',[],function() {
    
    
    function IntObject(val) {
        this.value = parseInt(val, 10);
    }
    
    IntObject.prototype = new Number();
    IntObject.prototype.valueOf = function(){ return parseInt(this.value, 10); };
    IntObject.prototype.toString = function(){ return this-0; };
    
    IntObject.constructor = IntObject;
    return IntObject;
});

/**
 * Copyright (c) 2011, Lasse Fister lasse@graphicore.de, http://graphicore.de
 * 
 * You should have received a copy of the MIT License along with this program.
 * If not, see http://www.opensource.org/licenses/mit-license.php
 * 
 * just in case your need the definition of a plist and your internet died,
 * this are the contents of http://www.apple.com/DTDs/PropertyList-1.0.dtd:
<!ENTITY % plistObject "(array | data | date | dict | real | integer | string | true | false )" >
<!ELEMENT plist %plistObject;>
<!ATTLIST plist version CDATA "1.0" >

<!-- Collections -->
<!ELEMENT array (%plistObject;)*>
<!ELEMENT dict (key, %plistObject;)*>
<!ELEMENT key (#PCDATA)>

<!--- Primitive types -->
<!ELEMENT string (#PCDATA)>
<!ELEMENT data (#PCDATA)> <!-- Contents interpreted as Base-64 encoded -->
<!ELEMENT date (#PCDATA)> <!-- Contents should conform to a subset of ISO 8601 (in particular, YYYY '-' MM '-' DD 'T' HH ':' MM ':' SS 'Z'.  Smaller units may be omitted with a loss of precision) -->

<!-- Numerical primitives -->
<!ELEMENT true EMPTY>  <!-- Boolean constant true -->
<!ELEMENT false EMPTY> <!-- Boolean constant false -->
<!ELEMENT real (#PCDATA)> <!-- Contents should represent a floating point number matching ("+" | "-")? d+ ("."d*)? ("E" ("+" | "-") d+)? where d is a digit 0-9.  -->
<!ELEMENT integer (#PCDATA)> <!-- Contents should represent a (possibly signed) integer number in base 10 -->
 */

define('ufojs/plistLib/main',[
    'ufojs/main'
  , 'ufojs/errors'
  , 'ufojs/xml/main'
  , './DataObject'
  , './IntObject'
], function(
    main
  , errors
  , xml
  , DataObject
  , IntObject
) {
    
    //shortcuts
    var TypeError = errors.Type,
        ValueError = errors.Value,
        parseDate = main.parseDate;
    
    var PlistQualifiedNameStr = 'plist',//this is going to be the documentElement
        PlistPublicId = '-//Apple//DTD PLIST 1.0//EN',
        PlistSystemId = 'http://www.apple.com/DTDs/PropertyList-1.0.dtd';
    
    /*definition*/
    var plistLib = {
        types: {
            Data: DataObject,
            Int: IntObject
        },
        readPlistFromString: function(plistString) {
            var plistDoc = xml.parseXMLString(plistString);
            return plistLib.readPlistFromDocument(plistDoc);
        },
        readPlistFromDocument: function(plistDoc) {
            var root = plistDoc.documentElement;
            if(root.nodeName !== 'plist')
                throw new TypeError('The documentElement is expected to be '
                    + '"plist", but it is "' + root.nodeName + '"');
            // A plist has exactly one child element.
            // .children[0] is a synonym for .firstElementChild supported by
            // jsdom, used for environments without native DOM.
            // Chromium/Google Chrome has no children list :-/
            if(!root.firstElementChild && !root.children.length)
                return null;
            return plistLib.readPlistElement(root.firstElementChild || root.children[0]);
        },
        createPlistDocument: function(value) {
            var doc = plistLib._createPlistDOMDocument();
            var child = this.createPlistElement(doc, value);
            if(!child)
                return false;
            doc.documentElement.appendChild(child);
            return doc;
        },
        createPlistElement: function(doc /* DOM Document */, value) {
            return plistLib._createElement(doc, value) || false;
        },
        /**
         * returns a value serialized as plist xml string.
         * 
         * This seems to work so far, but the browsers have still some
         * quirks, especially if you are looking for pretty printed xml.
         * For further processing the output is ok.
         */
        createPlistString: function(value) {
            var doc = plistLib.createPlistDocument(value),
                returnString,
                serializer;
            /* maybe useful when pretty printing gets interesting,
             * now it seems that browsers do not really make the xslt part
             * good. firefox 7 had problems with the indent="yes" part,
             * what makes the xslt solution half baked. Chromium, however,
             * did well.
            if(prettyPrint) {
                var xslt = xml.parseXMLString([
                    '<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform">',
                        '<xsl:output method="xml" indent="yes" doctype-public="' + PlistPublicId + '" doctype-system="'+PlistSystemId+'"/>',
                        '<xsl:template match="node()|@*">',
                            '<xsl:copy>',
                            '<xsl:apply-templates select="node()|@*"/>',
                            '</xsl:copy>',
                        '</xsl:template>',
                    '</xsl:stylesheet>'].join(''), 'text/xml'),
                    processor = new xml.XSLTProcessor();
                processor.importStylesheet(xslt);
                var doc = processor.transformToDocument(doc); 
            }
            */
            return xml.toString(doc);
        },
        _createPlistDOMDocument: function() {
            var namespaceURI = null,
                documentType = xml.createDocumentType(
                    PlistQualifiedNameStr, PlistPublicId, PlistSystemId),
                doc = xml.createDocument(
                    namespaceURI, PlistQualifiedNameStr, documentType);
            doc.documentElement.setAttribute('version', '1.0');
            return doc;
        },
        getType: function(value) {
            if(value instanceof IntObject)
                return 'integer';
            else if(value instanceof Number || typeof value === 'number')
                return 'real';
            else if(value instanceof Date)
                return 'date'
            else if(value instanceof DataObject)
                return 'data';
            else if(value instanceof Array)
                return 'array';
            else if(value instanceof Boolean || typeof value === 'boolean')
                return value ? 'true' : 'false';
            else if(value instanceof String || typeof value === 'string')
                return 'string';
            else if(value instanceof Object)
                return 'dict';
            else
                return false;
        },
        _createElement: function(doc, value) {
            var type, element, content;
            type = plistLib.getType(value);
            if(!type) return false;
            element = doc.createElement(type);
            content = plistLib._plistElementWriters[type](doc, value);
            if(content !== null)
                element.appendChild(content);
            return element;
        },
        readPlistElement: function(plistElement) {
            var type = plistElement.nodeName;
            if(!(type in plistLib._plistElementReaders))
                throw new TypeError(['A PlistElement of type "' , type, '" is not supported.'].join(''));
            return plistLib._plistElementReaders[type](plistElement);
        },
         /**
         * return a list of childNodes that are DOM-elements discard the others
         */
        _getChildElements: function(elem) {
            var list =
                // make a real array out of the nodeList
                [].slice.call(elem.childNodes)
                // remove all nodes that are not elements -- textnodes
                // (for formatting) and comments etc.
                .filter(function(node){return node.nodeType === node.ELEMENT_NODE});
            return list;
        },
        _getText: function(elem) {
            return elem.textContent
        },
        _plistElementReaders: {
            array: function(elem){
                return plistLib._getChildElements(elem)
                    //read the values of the elements
                    .map(plistLib.readPlistElement);
            },
            data: function(elem) {
                return new DataObject(plistLib._getText(elem));
            },
            date: function(elem){
                return new Date(parseDate(plistLib._getText(elem)));
            },
            /**
             * It seems like the robofab plistParser would just ignore
             * subsequent key elements, always the last key is the one
             * that will be used (once of course). But when there is no
             * key for a value, the parser will fail. I'm doing the same
             * here. However, the dtd forces one plistObject after each key
             * <!ELEMENT dict (key, %plistObject;)*>
             **/
            dict: function(elem) {
                var dict = {},
                    childElements = plistLib._getChildElements(elem),
                    key;
                for(var i=0; i<childElements.length; i++) {
                    if(childElements[i].nodeName === 'key') {
                        //if key !== undefined this is an error, but we skip this
                        key = plistLib._getText(childElements[i]);
                    } else if(key === undefined || key === null) {
                        throw new ValueError('Dict has a value without a key.');
                    } else {
                        dict[key] = plistLib.readPlistElement(childElements[i]);
                        key = undefined;
                    };
                }
                return dict;
            },
            real: function(elem) {
                return parseFloat(plistLib._getText(elem));
            },
            integer: function(elem) {
                return new IntObject(plistLib._getText(elem));
            },
            string: function(elem) {
                return plistLib._getText(elem);
            },
            'true': function(elem) {
                return true
            },
            'false': function(elem) {
                return false
            }
        },
        _plistElementWriters: {
            array: function(doc, list) {
                var fragment = doc.createDocumentFragment(),
                    elem;
                for(var i=0; i<list.length; i++) {
                    elem = plistLib._createElement(doc, list[i]);
                    if(!elem) continue;
                    fragment.appendChild(elem);
                }
                return fragment;
            },
            data: function(doc, elem) {
                return doc.createTextNode(elem);
            },
            date: function(doc, date) {
                return doc.createTextNode(date.toISOString());
            },
            dict: function(doc, dict) {
                var fragment = doc.createDocumentFragment(),
                    key, value, keyElement;
                for(key in dict) { 
                    if(!dict.hasOwnProperty(key) || dict[key] === undefined || dict[key] === null)
                        //there is no notation for empty things in plist
                        continue;
                    value = plistLib._createElement(doc, dict[key]);
                    if(!value) continue;
                    keyElement = doc.createElement('key');
                    keyElement.appendChild(doc.createTextNode(key));
                    fragment.appendChild(keyElement);
                    fragment.appendChild(value);
                }
                return fragment;
            },
            real: function(doc, number) {
                return doc.createTextNode(number.toString());
            },
            integer: function(doc, number) {
                return doc.createTextNode(number);
            },
            string: function(doc, string) {
                return doc.createTextNode(string)
            },
            'true': function(doc, elem) {
                return null
            },
            'false': function(doc, elem) {
                return null
            }
        },
        /**
         * this method is a Tool considered for testing the plist parsing
         * and thus not 'public'.
         * When there's a real need for this thing we should make a
         * specification for it. There is a lot of stuff to take into account
         * when figuring out whether two javascript objects look the same.
         * 
         * This does not check if the keys of a and b are in the same order.
         * I consider plist dicts as 'unordered'. That means their value
         * doesn't change when changing just the order of key-value pairs.
         **/
        _comparePlists: function(a, b, verbose) {
            var compare = function(a, b, path, recursive) {
                if(a === b) return true;//allows syncronous recursion i.e the same object is a an b
                if(typeof a !== 'object') return false;//this is the point, we want to compare similar objects
                if(a instanceof Date)
                   return b instanceof Date && a.getTime()===b.getTime();
                for(var i=0; i<recursive.length; i++) {
                    if(recursive[i] === a)
                        throw new ValueError([path.join('.'),'async recursion detected'].join(' '));
                }
                recursive.push(a);
                for(var key in a) {
                    path.push(key);
                    if(!(key in b)) return false;
                    if(!a.hasOwnProperty(key)) {
                        if(b.hasOwnProperty(key)) return false;
                        //don't walk down the prototype
                        if(a[key] === b[key]) continue;
                        return false;
                    }
                    if(!compare(a[key], b[key], path, recursive)) return false;
                    path.pop();
                }
                for(var key in b)//maybe b had more keys than a
                    if(!(key in a)) return false;
                recursive.pop();
                return true;
            }, path = ['root>>'], recursive = [];
            if(!compare(a, b, path, recursive)) {
                if(verbose) console.log(path.join('.'), 'looks not the same ');
                return false;
            }
            return true;
        }
    }
    return plistLib;
});

define('metapolator/models/_BaseModel',[

],
function()
{
    
    // All models will share some basics
    function _BaseModel() {

    }
    var _p = _BaseModel.prototype;

    return _BaseModel;
});

if(typeof Proxy === 'function')
    define('es6/Proxy', [], function() {return Proxy;});
else // typeof Proxy === 'object' => the old Proxy Proposal
    // mockup module, Proxy must be global
    // es6/Reflect patches it only
    define('es6/Proxy', ['es6/Reflect'], function(require) {return Proxy;});

define('metapolator/models/CPS/whitelistProxies',[
    'metapolator/errors'
  , 'es6/Proxy'
  , 'ufojs/main'
], function(
    errors
  , Proxy
  , ufoJSUtils
) {
    

    var CPSError = errors.CPS
      , KeyError = errors.Key
      , isInt = ufoJSUtils.isInt
      , isIntString = ufoJSUtils.isIntString
      ;


    function _handlerFactory(target, whitelist) {
        /* jshint validthis: true */
        return new Proxy(target, new this(whitelist));
    }

    function _get(target, name, receiver) {
        /* jshint validthis: true */
        var result = this._validate(target, name);
        if(!result[0])
            throw new KeyError(result[1]);

        return target[result[1]];
    }

    function _set(target, name) {
        throw new CPSError('Can\'t set "'+name+'". It\'s not allowed '
                                        +'to set values on this object.');
    }

    function _has (target, name, receiver) {
        /* jshint validthis: true */
        return this._validate(target, name)[0];
    }

    /**
     * "whitelist" is an object where the keys are the public names
     * and the values are the names on the target.
     * In the most cases key and value will equal. But this is also a
     * mechanism to create mappings to properties with other names.
     */
    function GenericHandler(whitelist) {
        this._whitelist = whitelist;
        this.get = _get;
        this.has = _has;
        this.set = _set;
    }

    GenericHandler.prototype._validate = function(target, name) {
        if(typeof name !== 'string')
            return [false, 'name must be string but it is: '+ typeof name];

        if(!this._whitelist.hasOwnProperty(name))
            return [false ,'Name "'+ name +'" is not whitelisted '
                            + 'for item "'+ target +'" '
                            + Object.keys(this._whitelist).join(', ')];
        return [true, this._whitelist[name]];

    };

    function ArrayHandler() {
        this.get = _get;
        this.has = _has;
        this.set = _set;
    }

    ArrayHandler.prototype._validate = function(target, key) {
        var processedKey;
        if(isIntString(key))
            key = parseInt(key, 10);
        if(key === 'length')
            return [true, key];
        else if(!isInt(key))
            return [false, 'Key must be "length" or an integer but it is: '
                                            + key + ' '+ typeof key];
        else if(key<0)
            processedKey = target.length + key;
        else
            processedKey = key;

        if(processedKey<0 || processedKey>=target.length)
             throw new KeyError('The index "'+ key +'" is not in the array. '
                                        + 'Length: ' + target.length);
        return [true, processedKey];
    };

    return {
        generic: _handlerFactory.bind(GenericHandler)
      , array: _handlerFactory.bind(ArrayHandler)
    };
});

define('metapolator/models/emitterMixin',[
    'metapolator/errors'
], function(
    errors
) {
    
    var EmitterError = errors.Emitter;
    /**
     * usage:
     *
     * ```
     * var emitterSetup = {
     *     stateProperty: '_channel'
     *   , onAPI: 'on'
     *   , offAPI: 'off'
     *   , triggerAPI: '_trigger'
     * };
     *
     * function Emitter() {
     *     // sets the this._channel property
     *     emitterMixin.init(this, emitterSetup);
     * }
     * var _p = Emitter.prototype;
     * emitterMixin(_p, emitterSetup);
     * ```
     * API:
     *
     * ```
     * var e = new Emitter();
     * ```
     *
     * *************
     * subscribe default name: on
     * on(channelName, callback, subscriberData {optional})
     * returns subscriptionID
     *
     * ```
     * var subscriberData = 'data the subscriber will get back ...';
     * // note 'hello' is the channel name
     * var subscriptionID = e.on('hello', callback, subscriberData);
     *```
     *
     * *************
     * a callback should have the following signature:
     * `function(subscriberData, channelName, eventData)`
     *
     * The `callback` argument of `on` may have one of two forms
     *   - a function
     *   - [instance, 'methodName']
     *
     * subscriberData is set by the subscriber when calling `e.on`
     * eventData can be sent by the caller of `e.trigger` but is optional.
     *           This is part of the contract that a subscriber makes with
     *           the sender.
     * *************
     *
     * trigger default name: trigger
     * trigger(channelName, eventData {optional} )
     * ```
     * eventData = {any: 'value'};
     * e.trigger('hello', eventData);
     *
     * // a callback will be called like this: callback(subscriberData, eventData);
     * // or, like this callback[0][callback[1]](subscriberData, eventData);
     *
     * ************
     * unsubscribe default name: off
     * off(subscriptionID);
     * ```
     * e.off(subscriptionID);
     * ```
     *
     * *************
     *
     * the state property that is created has the following structure and adress:
     *
     * this[stateProperty] = {}
     * this[stateProperty][ channelName ] = a subscribers object
     *
     *  the subscribers object is created in _getChannel:
     * ```
     *  {
     *      idCounter: number
     *      subscriberId: [
     *             callback // a function of an array of [object, 'string methodname']
     *           , data // <= anything, will the first argument for callback
     *      ]
     *    , subscriberId: [callback, data]
     *    , ...
     *  }
     * ```
     */
    function emitterMixin(host, _setup) {
        var setup = _setup || {}
          , stateProperty = setup && setup.stateProperty || '_channel'
          , onAPI = setup && setup.onAPI || 'on'
          , offAPI = setup && setup.offAPI || 'off'
          , triggerAPI = setup && setup.triggerAPI || '_trigger'
          ;
        if(host.hasOwnProperty(onAPI))
            throw new EmitterError('The property name "' + onAPI
                    + '" is already used by this host object (' + host.constructor.name + ').');
        host[onAPI] = _mixinOn(stateProperty);
        if(host.hasOwnProperty(offAPI))
            throw new EmitterError('The property name "' + offAPI
                    + '" is already used by this host object (' + host.constructor.name + ').');
        host[offAPI] = _mixinOff(stateProperty);
        if(host.hasOwnProperty(triggerAPI))
            throw new EmitterError('The property name "' + triggerAPI
                    + '" is already used by this host object (' + host.constructor.name + ').');
        host[triggerAPI] = _mixinTrigger(stateProperty);
    }

    function init(thisVal, _setup) {
        var setup = _setup || {}
          , stateProperty = setup.stateProperty || '_channel'
          ;
        if(thisVal.hasOwnProperty(stateProperty))
            throw new EmitterError('The property name "' + stateProperty
                    + '" is already used by this object (' + thisVal.constructor.name + ': ' + thisVal+').');
        Object.defineProperty(thisVal, stateProperty, {
            value: Object.create(null)
          , writable: false
          , enumerable: true
        });
    }
    emitterMixin.init = init;

    function _getChannel(state, channelKey) {
        var channel = state[channelKey];
        if(!channel) {
            channel = state[channelKey] = Object.create(null);
            Object.defineProperty(channel, 'idCounter', {
                value: 0
              , writable: true
              , enumerable: false
              , configurable: false
            });
        }
        return channel;
    }

    function __on(state, channelKey, subscription) {
        var channel = _getChannel(state, channelKey)
          , subscriberID = channel.idCounter++
          ;
        channel[subscriberID] = subscription;
        return subscriberID;
    }
    function __off(state, channelKey, subscriberID) {
        var channel = state[channelKey];
        if(!channel || !channel[subscriberID]){
            console.trace();
            throw new EmitterError('Unsubscription without subscription from channel: '
                    + '"' + channelKey + '" with subscriberID: "' + subscriberID + '".');
            }
        delete channel[subscriberID];
    }
    function __trigger(state, channelKey, eventData) {
        var channel = state[channelKey]
          , subscribers, subscriberID, i, l
          , callback, subscriberData
          ;
        if(!channel) return;
        subscribers = Object.keys(channel);
        for(i=0,l=subscribers.length;i<l;i++) {
            subscriberID = subscribers[i];
            // subscriber may be undefined because of an unsubscription
            // since we copied the subscribers
            if(!(subscriberID in channel)) continue;
            callback = channel[subscriberID][0];
            subscriberData = channel[subscriberID][1];
            if(callback instanceof Function)
                callback(subscriberData, channelKey, eventData);
            else if(callback instanceof Array)
                // callback = [object, 'methodName']
                // this is done to avoid to many new bound functions
                callback[0][callback[1]](subscriberData, channelKey, eventData);
            else
                throw new EmitterError('Unkown callback type: ' + callback);
        }
    }

    function _on(state, channelKey, callback, subscriberData) {
        var subscription = [callback, subscriberData]
          , i, l, results
          ;
        if(channelKey instanceof Array) {
            results = [];
            for(i=0,l=channelKey.length;i<l;i++)
                results.push([channelKey[i], __on(state, channelKey[i], subscription)]);
            return results;
        }
        return [channelKey, __on(state, channelKey, subscription)];
    }
    function _mixinOn(stateProperty) {
        return function on(channelKey, callback, subscriberData) {
            var state = this[stateProperty];
            if(state === undefined)
                throw new EmitterError('state "'+stateProperty+'" is undefined.');
            return _on(state, channelKey, callback, subscriberData);
        };
    }
    function _off(state, subscriberID) {
        var i, l;
        if(subscriberID[0] instanceof Array) {
            for(i=0,l=subscriberID.length;i<l;i++)
                __off(state, subscriberID[i][0], subscriberID[i][1]);
            return;
        }
        __off(state, subscriberID[0], subscriberID[1]);
    }
    function _mixinOff(stateProperty) {
        return function off(subscriberID) {
            var state = this[stateProperty];
            if(state === undefined)
                throw new EmitterError('state "'+stateProperty+'" is undefined.');
            return _off(state, subscriberID);
        };
    }
    function _trigger(host, stateProperty, channelKey, eventData) {
        var i,l, state = host[stateProperty];
        if(state === undefined)
            throw new EmitterError('state "'+stateProperty+'" is undefined.');
        if(channelKey instanceof Array) {
            for(i=0,l=channelKey.length;i<l;i++)
                __trigger(state, channelKey[i], eventData);
            return;
        }
        __trigger(state, channelKey, eventData);
    }
    function _mixinTrigger(stateProperty) {
        return function trigger(channelKey, data) {
            return _trigger(this, stateProperty, channelKey, data);
        };
    }

    return emitterMixin;
});

define('metapolator/models/MOM/_Node',[
    'metapolator/errors'
  , '../_BaseModel'
  , 'metapolator/models/CPS/whitelistProxies'
  , 'metapolator/models/emitterMixin'
], function(
    errors
  , Parent
  , whitelistProxies
  , emitterMixin
) {
    

    var MOMError = errors.MOM;

    var _id_counter = 0
      , emitterMixinSetup
      ;
    function getUniqueID() {
        return _id_counter++;
    }

    emitterMixinSetup = {
          stateProperty: '_channel'
        , onAPI: '_on'
        , offAPI: '_off'
        , triggerAPI: '_trigger'
    };

    /**
     * The MOM is the structure against which we can run the selector queries
     * of CPS. We must be able to answer the the question "is this element
     * selected by that selector" for each item of the MOM.
     *
     * All Elements of the Metpolator Object Model MOM inherit from _Node.
     * This means, that a test like `item instanceof _Node` must return true.
     */
    function _Node() {
        /*jshint validthis:true*/
        Parent.call(this);
        if(this.constructor.prototype === _p)
            throw new MOMError('MOM _Node must not be instantiated directly');
        Object.defineProperty(this, 'nodeID', {value: getUniqueID()});

        this._children = [];
        this._parent = null;
        this._index = null;
        this._id = null;
        this._classes = Object.create(null);
        this.cps_proxy = whitelistProxies.generic(this, this._cps_whitelist);
        this._changeSubscriptions = null;
        emitterMixin.init(this, emitterMixinSetup);

        this._cpsChange = {
            timeoutId: null
          , eventData: []
          , trigger: this._triggerCpsChange.bind(this)
        };
    }
    var _p = _Node.prototype = Object.create(Parent.prototype);
    _p.constructor = _Node;

    _p._cps_whitelist = {
        parent: 'parent'
      , children: 'children'
      , master: 'master'
      , univers: 'univers'
      , multivers: 'multivers'
      , index: 'index'
      , type: 'type'
    };

    _p.clone = function() {
        var clone = new this.constructor(), i,l;
        this._cloneProperties(clone);
        for(i=0,l=this._children.length;i<l;i++)
            clone.add(this._children[i].clone());
        return clone;
    };

    _p._cloneProperties = function(clone) {
        if(this._id)
            clone.id = this._id;
        for(var k in this._classes)
            clone.setClass(k);
    };

    emitterMixin(_p, emitterMixinSetup);

    Object.defineProperty(_p, 'MOMType', {
        get: function(){return 'MOM '+ this.constructor.name ;}
    });

    /**
     * Implement a getter for CPS Type in children of _Node, we need it
     * for the cps selector engine.
     *
     * cpsType should be a simple string, minuses are are ok, don't do
     * anything fancy. Don't use already taken names.
     */
    Object.defineProperty(_p, 'type', {
        get: function() {
            // this should be implemented by items inheriting from _Node
            throw errors.NotImplemented('Implement CPS-Type name!');
        }
    });

    Object.defineProperty(_p, 'children', {
        /**
         * returns a copy of this._children so we can't mess around
         * with the list of children via public interfaces.
         */
        get: function(){ return this._children.slice(); }
    });

    Object.defineProperty(_p, 'id', {
        /**
         * The Mechanism how id's are verified etc. need to be defined,
         * probably on a per MOM-Element base. And probably always the
         * parent is responsible for id checking and setting. At the
         * moment, I need id's to write the selector engine, and for that,
         * I don't need propper checked IDs
         */
        set: function(id){ this._id = id; }
      , get: function(){ return this._id; }
    });

    /***
     * get the univers element of this node.
     *
     * a univers element itself has no univers!
     */
    Object.defineProperty(_p, 'univers', {
        get: function() {
            if(!this._parent)
                return null;
            if(this._parent.MOMType === 'MOM Univers')
                return this._parent;
            return this._parent.univers;
        }
    });

    /***
     * get the multivers element of this node.
     *
     * a multivers element itself has no multivers!
     */
    Object.defineProperty(_p, 'multivers', {
        get: function() {
            if(!this._parent)
                return null;
            if(this._parent.MOMType === 'MOM Multivers')
                return this._parent;
            return this._parent.multivers;
        }
    });

    /***
     * get the master element of this node or null if this node has no master
     *
     * neither multivers nor univers have a master
     */
    Object.defineProperty(_p, 'master', {
        get: function() {
            if(!this._parent)
                return null;
            if(this._parent.MOMType === 'MOM Master')
                return this._parent;
            return this._parent.master;
        }
    });

    Object.defineProperty(_p, 'glyph', {
        get: function() {
            return this._parent && this._parent.glyph;
        }
    });

    /**
     * returns a selector for this element, currently it is used for
     * display puposes, so the additionial information "(no parent) "
     * is prepended if the item has no parent
     */
    Object.defineProperty(_p, 'particulars', {
        get: function() {
            return [
                    this._parent ? this._parent.particulars : '(no parent)'
                  , ' '
                  , this.type
                  , (this.id ? '#' + this.id : '')
                  , (this._parent
                        ? ':i(' + this._parent.find(this) + ')'
                        : '')
                ].join('');
        }
    });

    _p.setClass = function(name) {
        this._classes[name] = null;
    };

    _p.removeClass = function(name) {
        delete this._classes[name];
    };

    _p.hasClass = function(name) {
        return name in this._classes;
    };

    _p.toString = function() { return ['<', this.MOMType, '>'].join('');};

    _p.isMOMNode = function(item) {
        return item instanceof _Node;
    };

    /**
     *  enhance this list with accepted children Constructors
     */
    _p._acceptedChildren = [];


    _p.qualifiesAsChild = function(item) {
        var i=0;
        if(!this.isMOMNode(item) || item === this)
            return false;

        for(;i<this._acceptedChildren.length; i++)
            if(item instanceof this._acceptedChildren[i])
                return true;
        return false;
    };

    /**
     * Note: this is currently running very often when adding or deleting
     * children, I wonder if we need to come up with some tricky shortcut
     * to make the search faster.
     * On thing I already made is searching from back to front, because
     * a child node will call parent.find(this) exactly after beeing
     * added to the parent, to verify that it is indeed entitled to change
     * it's parent property. In that case searching from back to front is
     * the faster path.
     *
     */
    _p.find = function(item) {
        var i=this._children.length-1;
        for(;i>=0; i--)
            if(item === this._children[i])
                return i;
        return false;
    };

    Object.defineProperty(_p, 'index', {
        get: function(){ return this._index;}
    });

    Object.defineProperty(_p, 'parent', {
        /**
         * Use parent for reading only.
         *
         * Setting the parent property performs some checks if the new
         * property is indeed valid. The Parent is authoritative in this
         * case.
         *
         * In short: We made it hard to set the parent property because
         * we want you to use the 'add' method of the parent.
         */
        set: function(parent) {
            if(parent === null) {
                if(this._parent === null)
                    // already done
                    return;
                if(this._parent.find(this) !== false)
                    throw new MOMError('Can\'t unset the parent property '
                        +'when the parent still has this Node as a child');
                this._parent = null;
                this._index = null;
                return;
            }
            else if(this._parent !== null)
                throw new MOMError([this, 'is still a child of a', this._parent
                  , 'you can\'t set a new parent Node. Use "newParent.add(child)"'
                  , 'to move the child to another parent'].join(' '));
            else if (!this.isMOMNode(parent))
                throw new MOMError('The parent property must be a MOM Node, '
                    +'but it is: "' + parent + '" typeof: ' + typeof parent);
            else if(parent.find(this) === false)
                throw new MOMError('A MOM Node must already be a child '
                    + 'of its parent when trying to set its parent property. '
                    + 'Use "parent.add(child)" instead.');
            this._parent = parent;
            this._index = this._parent.find(this);
        }
      , get: function(){ return this._parent; }
    });

    _p.remove = function(item) {
        if(Object.isFrozen(this._children))
            throw new MOMError('Removing children is not allowed in this element.');
        var i = this.find(item);
        if(i === false)
            throw new MOMError([this, 'can\'t remove', item ,'because',
                                'it is not a child.'].join(' '));
        this._children.splice(i, 1);
        item.parent = null;
        return true;
    };

    _p.add = function(item) {
        if(Object.isFrozen(this._children))
            throw new MOMError('Adding children is not allowed in this element.');
        if(!this.qualifiesAsChild(item))
            throw new MOMError([this, 'doesn\'t accept', item
                                        , 'as a child object.'].join(' '));
        if(item.parent !== null)
            item.parent.remove(item);
        this._children.push(item);
        item.parent = this;
    };

    _p.query = function(selector) {
        return this.multivers.query(selector, this);
    };

    _p.queryAll = function(selector) {
        return this.multivers.queryAll(selector, this);
    };

    _p.getComputedStyle = function() {
        return this.multivers.getComputedStyleFor(this);
    };

    _p._triggerCpsChange = function(){
       clearTimeout(this._cpsChange.timeoutId);
       var eventData = this._cpsChange.eventData;
       this._cpsChange.timeoutId = null;
       this._cpsChange.eventData = [];
       this._trigger('CPS-change', eventData);
    };

    _p._cpsChangeHandler = function(subscriberData, channelKey, eventData) {
        // The styledicts are already debounced so that they fire only
        // once after all sync tasks are done. Debouncing here could still
        // be useful to create less events, however, the subscriber will
        // have to debounce as well. Maybe, we could try to shift the
        // StyleDict debouncing to here then also changes of this item's
        // children will be held back (but they do the same, so a propper
        // waiting time for 10 ms in the subscriber is maybe best)
        if(eventData)
            this._cpsChange.eventData.push(eventData);
        if(this._cpsChange.timeoutId)
            return;
            // Now an event is scheduled, so there's no need for a further
            // action. In the future, we may pass a promise around to trigger
            // when the current task has finished. Similar considerations
            // are in StyleDict.js at Styledict.prototype._nextTrigger
            //clearTimeout(this._cpsChange.timeoutId);
        this._cpsChange.timeoutId = setTimeout(this._cpsChange.trigger, 0);
    };

    /**
     * When there is a listener for CPS-change the first time, this will
     * subscribe to all it's children and to its computedStyle to get the
     * message. The children will subscribe themselve to all their children.
     *
     * NOTE: currently we only register changes from StyleDict, that means
     * the CPS model, we don't know about changes in the MOM.
     */
    _p._initCPSChangeEvent = function() {
        var callback
          , changeSubscriptions = this._changeSubscriptions
          , style
          , children, i, l, child
          ;
        if(changeSubscriptions === null) {
            // only if this is the first subscription:
            changeSubscriptions = this._changeSubscriptions = Object.create(null);
            Object.defineProperty(changeSubscriptions, 'counter', {
                value: 0
              , writable: true
              , enumerable: false
            });

            callback = [this, '_cpsChangeHandler'];
            style = this.getComputedStyle();
            // FIXME: do I wan't this to hold an actual reference to its
            // StyleDict??? this was managed solely by models/Controller previously.
            changeSubscriptions._styleDict_ = [style, style.on('change', callback)];
            children = this._children;
            for(i=0,l=children.length;i<l;i++) {
                child = children[i];
                changeSubscriptions[child.nodeID] = [child, child.on('CPS-change', callback)];
            }
        }
        changeSubscriptions.counter += 1;
    };

    _p._deinitCPSChangeEvent = function(subscriberID) {
        var k, subscription
          , changeSubscriptions = this._changeSubscriptions
          ;
        if(!changeSubscriptions)
            return;
        changeSubscriptions.counter -= 1;
        if(changeSubscriptions.counter === 0) {
            delete changeSubscriptions._styleDict_;
            for(k in changeSubscriptions) {
                subscription = changeSubscriptions[k];
                subscription[0].off(subscription[1]);
            }
        }
        this._changeSubscriptions = null;
    };

    /**
     * Use "CPS-change" this as an indicator to schedule a redraw;
     */
    _p.on = function(channel, subscriberCallback, subscriberData) {
        // TODO: a beforeOnHook('change', method) would be nice here
        // See also the comment in _p.off
        var i,l;
        if(channel instanceof Array) {
            for(i=0,l=channel.length;i<l;i++)
                if(channel[i] === 'CPS-change')
                    this._initCPSChangeEvent();
        }
        else if(channel === 'CPS-change')
            this._initCPSChangeEvent();

        return this._on(channel, subscriberCallback, subscriberData);
    };

    _p.off = function(subscriberID) {
        // will raise if not subscribed, so it happen before _deinitChangeEvent
        var result = this._off(subscriberID), i,l;
        // TODO: this requires knowledge of the structure of emitterMixin
        // subscriberIDs! That is a bit unfortunate.
        // A solution would be a afterOffHook('change', method) here.
        // I consider that overengineering for the moment.
        if(subscriberID[0] instanceof Array)
            for(i=0,l=subscriberID.length;i<l;i++)
                if(subscriberID[0] === 'CPS-change')
                    this._deinitCPSChangeEvent();
        else if(subscriberID[0] === 'CPS-change')
            this._deinitCPSChangeEvent();

        return result;// usually undefined
    };

    return _Node;
});

define('metapolator/models/MOM/_Contour',[
    './_Node'
], function(
    Parent
) {
    
    /**
     * All children of a MOM Glyph have to inherit from MOM _Contour.
     */
    function _Contour() {
        /*jshint validthis:true*/
        Parent.call(this);
        if(this.constructor.prototype === _p)
            throw new MOMError('MOM _Contour must not be instantiated '
                +'directly');
    }
    var _p = _Contour.prototype = Object.create(Parent.prototype);
    _p.constructor = _Contour;

    Object.defineProperty(_p, 'glyph', {
        get: function() {
            return this._parent;
        }
    });

    return _Contour;
});

define('metapolator/models/MOM/Glyph',[
    './_Node'
  , './_Contour'
  , 'metapolator/models/CPS/whitelistProxies'
], function(
    Parent
  , _Contour
  , whitelistProxies
) {
    
    /*jshint sub:true*/
    /**
     * This Element is the container of all contours of a glyph.
     * It will have some metadata and contain children of type MOM _Contour.
     *
     * Possible candiates for other children would be everything else
     * found in a UFO-Glyph. But, we can make properties about that stuff,
     * too. Guidelines would make a good candidate for further children,
     * because we might actually want to access these via CPS.
     *
     * In the first version we the only child of MOM _Contour is
     * MOM PenStroke.
     */
    function Glyph() {
        Parent.call(this);
        // FIXME: make a GlyphData Object, similar like PointData
        // use that for advanceWidth/advanceHeight and everything setUFOData
        // probably, remove _p.setUFOData in favor of a common interface
        // for all MOM elements
        this._advanceWidth  = 0;
        this._advanceHeight = 0;
        this._ufoData = {};
        this.cps_proxy = whitelistProxies.generic(this, this._cps_whitelist);
    }
    var _p = Glyph.prototype = Object.create(Parent.prototype);
    _p.constructor = Glyph;

    _p._cps_whitelist = {
        originalAdvanceWidth:  '_advanceWidth'
      , originalAdvanceHeight: '_advanceHeight'
    };
    //inherit from parent
    (function(source) {
        for(var k in source) if(!this.hasOwnProperty(k)) this[k] = source[k];
    }).call(_p._cps_whitelist, Parent.prototype._cps_whitelist);

    _p._cloneProperties = function(clone) {
        Parent.prototype._cloneProperties.call(this, clone);
        clone.setUFOData(this.getUFOData());
    };

    Object.defineProperty(_p, 'MOMType', {
        value: 'MOM Glyph'
    });

    Object.defineProperty(_p, 'type', {
        /* this is used for CPS selectors */
        value: 'glyph'
    });

    _p.setUFOData = function(ufoGlyph) {
        var i=0, keys = Object.keys(ufoGlyph);
        for(;i<keys.length;i++)
            this._ufoData[keys[i]] = ufoGlyph[keys[i]];
        if( ufoGlyph['width'] ) {
            this._advanceWidth = ufoGlyph['width'];
        }
        if( ufoGlyph['height'] ) {
            this._advanceHeight = ufoGlyph['height'];
        }
    };

    /**
     * Return value is a copy of the UFO data for the Glyph.
     *
     * Should be immutable or a copy, but we would have to make
     * a deep copy for this, because we don't want the contents to
     * be changed without us knowing, either.
     *
     * We might also invent more interfaces for UFO data for a glyph
     * in the future.
     **/
    _p.getUFOData = function() {
        var ret = {}, i=0, keys = Object.keys(this._ufoData);
        for(;i<keys.length;i++) {
            ret[keys[i]] = this._ufoData[keys[i]];
        }

        ret['width']  = this._advanceWidth;
        ret['height'] = this._advanceHeight;
        return ret;
    };

    /**
     * Convert the UFO key to the key you should use for CPS. For example,
     * convertUFOtoCPSKey('width') returns 'advanceWidth'
     **/
    function convertUFOtoCPSKey( ufokey ) {
        var UFOtoCPSKeyMap = {   'width': 'advanceWidth'
                               , 'height': 'advanceHeight'
                             };

        if(UFOtoCPSKeyMap[ufokey])
            return UFOtoCPSKeyMap[ufokey];
        return ufokey;
    }
    Glyph.convertUFOtoCPSKey = convertUFOtoCPSKey;
    _p._acceptedChildren = [_Contour];

    return Glyph;
});

define('metapolator/models/MOM/Master',[
    './_Node'
  , './Glyph'
], function(
    Parent
  , Glyph
) {
    
    /**
     * This Element is the container of all glyphs of a master.
     * It will have some metadata and contain children of type MOM Glyph.
     */
    function Master(fontinfo) {
        Parent.call(this);
        // FIXME: the data of fontinfo should be available via CPS
        // this can be done similar to PointData
        // MAYBE >> import fontinfo as CPS ???
        // some concepts are still unclear :-/
        Object.defineProperty(this, 'fontinfo', {
            value: fontinfo
        });
    }
    var _p = Master.prototype = Object.create(Parent.prototype);
    _p.constructor = Master;

    _p.clone = function() {
        var clone = new this.constructor(this.fontinfo), i,l;
        this._cloneProperties(clone);
        for(i=0,l=this._children.length;i<l;i++)
            clone.add(this._children[i].clone());
        return clone;
    };

    Object.defineProperty(_p, 'MOMType', {
        value: 'MOM Master'
    });

    Object.defineProperty(_p, 'type', {
        /* this is used for CPS selectors*/
        value: 'master'
    });

    /**
     * TODO: make indexed lookup for _Node.id
     */
    _p.findGlyph = function( glyphName ) {
        var col = this.children
        , i = 0
        , glyph
        ;
        for( i=0; i<col.length; i++ ) {
            glyph = col[i];
            if( glyph.id == glyphName ) {
                return glyph;
            }
        }
        return null;
    };

     /**
     * As long as there is just one univers, we don't need to display
     * the multivers and univers selectors
     */
    Object.defineProperty(_p, 'particulars', {
        get: function() {
            return [
                    this._parent ? '' : '(no parent)'
                  , ' '
                  , this.type
                  , (this.id ? '#' + this.id : '')
                  , (this._parent
                        ? ':i(' + this._parent.find(this) + ')'
                        : '')
                ].join('');
        }
    });

    _p._acceptedChildren = [Glyph];

    return Master;
});

/**
 * Copyright (c) 2011, Lasse Fister lasse@graphicore.de, http://graphicore.de
 * 
 * You should have received a copy of the MIT License along with this program.
 * If not, see http://www.opensource.org/licenses/mit-license.php
 * 
 * This is a translation of AbstractPointPen defined in robofab/pens/pointPen.py
 * The svn revision of the source file in trunk/Lib/ was 67 from 2008-03-11 10:18:32 +0100
 * Ther very same pen is to be found in robofab/branches/ufo3k/Lib/ufoLib/pointPen.py
 * revision 517 2011-12-07 18:17:40 +0100 (Wed, 07 Dec 2011)
 * 
 * I even copied the docstrings and comments! (These may still refer to the Python code)
 * 
 * 
 * =========
 * PointPens
 * =========
 * 
 * Where **SegmentPens** have an intuitive approach to drawing
 * (if you're familiar with postscript anyway), the **PointPen**
 * is geared towards accessing all the data in the contours of
 * the glyph. A PointsPen has a very simple interface, it just
 * steps through all the points in a call from glyph.drawPoints().
 * This allows the caller to provide more data for each point.
 * For instance, whether or not a point is smooth, and its name.
 */

define('ufojs/tools/pens/AbstractPointPen',['ufojs/main', 'ufojs/errors'], function(main, errors) {
    
    var enhance = main.enhance;
    //shortcuts
    var NotImplementedError = errors.NotImplemented;
    
    /*constructor*/
    /**
     * Baseclass for all PointPens.
     */
    function AbstractPointPen(){};

    /*inheritance*/
    //pass

    /*definition*/
    enhance(AbstractPointPen, {
        /**
         * Start a new sub path.
         */
        beginPath: function(kwargs/*optional, dict*/)
        {
            throw new NotImplementedError(
                'AbstractPointPen has not implemented'
                +' beginPath');
        },
        /**
         * End the current sub path.
         */
        endPath: function()
        {
            throw new NotImplementedError(
                'AbstractPointPen has not implemented'
                +' endPath');
        },
        /**
         * Add a point to the current sub path.
         */
        addPoint: function(
            pt,
            segmentType /* default null */,
            smooth /* default false */,
            name /* default null */,
            kwargs /* default an object, javascript has no **kwargs syntax */
        ) {
            segmentType = (segmentType === undefined) ? null : segmentType;
            smooth = (smooth || false);
            name = (name === undefined) ? null : name;
            kwargs = (kwargs || {});//an "options" object
            throw new NotImplementedError(
                'AbstractPointPen has not implemented'
                +' addPoint');
        },
        /**
         * Add a sub glyph.
         */
        addComponent: function(baseGlyphName, transformation)
        {
            throw new NotImplementedError(
                'AbstractPointPen has not implemented'
                +' addComponent');
        }
    });
    return AbstractPointPen;
});

define('metapolator/models/MOM/PointData',[
    'metapolator/models/CPS/whitelistProxies'
], function(
    whitelistProxies
) {
    

    /**
     * Used to set the skeleton point coordinates to MOM Point and OutlinePoint
     * elements.
     */
    function PointData(obj) {
        for(var k in obj) this[k] = obj[k];
        this.cps_proxy = whitelistProxies.generic(this, this._cps_whitelist);
    }

    PointData.prototype._cps_whitelist = {
        on: 'on'
      , in: 'in'
      , out: 'out'
    };

    // NOTE: when changing these values is implemented, the according
    // onPropertyChange/offPropertyChange methods nned to be implemented as well
    // see: models/emitterMixin.js for this

    return PointData;
});

define('metapolator/models/MOM/_PenStrokePointChild',[
    './_Node'
], function(
    Parent
) {
    
    /**
     * This Element represents a child of a of a MoM PenStrokePoint
     */
    function _PenStrokePointChild() {
        /*jshint validthis:true*/
        Parent.call(this);
    }
    var _p = _PenStrokePointChild.prototype = Object.create(Parent.prototype);
    _p.constructor = _PenStrokePointChild;

    return _PenStrokePointChild;
});

define('metapolator/models/MOM/PenStrokePointLeft',[
    './_PenStrokePointChild'
], function(
    Parent
) {
    
    function PenStrokePointLeft() {
        Parent.call(this);
    }
    var _p = PenStrokePointLeft.prototype = Object.create(Parent.prototype);
    _p.constructor = PenStrokePointLeft;

    Object.defineProperty(_p, 'MOMType', {
        value: 'MOM PenStrokePointLeft'
    });

    Object.defineProperty(_p, 'type', {
        /* this is used for CPS selectors */
        value: 'left'
    });

    return PenStrokePointLeft;
});

define('metapolator/models/MOM/PenStrokePointCenter',[
    './_PenStrokePointChild'
], function(
    Parent
) {
    
    function PenStrokePointCenter() {
        Parent.call(this);
    }
    var _p = PenStrokePointCenter.prototype = Object.create(Parent.prototype);
    _p.constructor = PenStrokePointCenter;

    Object.defineProperty(_p, 'MOMType', {
        value: 'MOM PenStrokePointCenter'
    });

    Object.defineProperty(_p, 'type', {
        /* this is used for CPS selectors */
        value: 'center'
    });

    return PenStrokePointCenter;
});

define('metapolator/models/MOM/PenStrokePointRight',[
    './_PenStrokePointChild'
], function(
    Parent
) {
    
    function PenStrokePointRight() {
        Parent.call(this);
    }
    var _p = PenStrokePointRight.prototype = Object.create(Parent.prototype);
    _p.constructor = PenStrokePointRight;

    Object.defineProperty(_p, 'MOMType', {
        value: 'MOM PenStrokePointRight'
    });

    Object.defineProperty(_p, 'type', {
        /* this is used for CPS selectors */
        value: 'right'
    });

    return PenStrokePointRight;
});

define('metapolator/models/MOM/PenStrokePoint',[
    './_Node'
  , './PointData'
  , './_PenStrokePointChild'
  , './PenStrokePointLeft'
  , './PenStrokePointCenter'
  , './PenStrokePointRight'
  , 'metapolator/models/CPS/whitelistProxies'
], function(
    Parent
  , PointData
  , _PenStrokePointChild
  , PenStrokePointLeft
  , PenStrokePointCenter
  , PenStrokePointRight
  , whitelistProxies
) {
    
    /**
     * This Element represents a point of a of a MoM PenStroke contour.
     * Its properties are the absolute coordinates of an on-curve point
     * of the centerline of a contour.
     *
     * Eventually it may have a name and an identifier etc.
     *
     * It has three children, in order: left, center, right
     * It doesn't accept add or removal of children.
     *
     * pointData is expected to be a PointData instance with three readable keys:
     * {
     *      in: Vector || undefined
     *    , on: Vector // must be set
     *    , out: Vector || undefined
     * }
     * These are the absolute coordinates of the skeleton.
     *
     */
    function PenStrokePoint(pointData) {
        Parent.call(this);
        if(!(pointData) instanceof PointData)
            throw new TypeError('Expected an instance of PointData.');
        this._skeleton = pointData;

        this.add(new PenStrokePointLeft());  // 0
        this.add(new PenStrokePointCenter());// 1
        this.add(new PenStrokePointRight()); // 2
        Object.freeze(this._children);
    }
    var _p = PenStrokePoint.prototype = Object.create(Parent.prototype);
    _p.constructor = PenStrokePoint;

    //inherit from parent
    _p._cps_whitelist = {
        skeleton: 'skeleton'
      , left: 'left'
      , center: 'center'
      , right: 'right'
    };
    //inherit from parent
    (function(source) {
        for(var k in source) if(!this.hasOwnProperty(k)) this[k] = source[k];
    }).call(_p._cps_whitelist, Parent.prototype._cps_whitelist);

    _p.clone = function() {
        var clone = new this.constructor(new PointData(this._skeleton));
        this._cloneProperties(clone);
        return clone;
    };

    Object.defineProperty(_p, 'MOMType', {
        value: 'MOM PenStrokePoint'
    });

    Object.defineProperty(_p, 'type', {
        /* this is used for CPS selectors */
        value: 'point'
    });

    /**
     * This is the on curve point of the skeleton.
     * I thought about calling it origin, maybe.
     */
    Object.defineProperty(_p, 'skeleton', {
        get: function() {
            return this._skeleton;
        }
    });

    Object.defineProperty(_p, 'left', {
        get: function() {
            return this._children[0];
        }
    });

    Object.defineProperty(_p, 'center', {
        get: function() {
            return this._children[1];
        }
    });

    Object.defineProperty(_p, 'right', {
        get: function() {
            return this._children[2];
        }
    });

    _p._acceptedChildren = [_PenStrokePointChild];

    return PenStrokePoint;
});

define('metapolator/models/MOM/PenStroke',[
    './_Contour'
  , './PenStrokePoint'
], function(
    Parent
  , PenStrokePoint
) {
    
    /**
     * This Element is the container of all points of a pen stroke contour.
     * It may have some metadata (like an identifier) and contain children
     * of type MOM PenStrokePoint.
     */
    function PenStroke() {
        Parent.call(this);
    }
    var _p = PenStroke.prototype = Object.create(Parent.prototype);
    _p.constructor = PenStroke;

    Object.defineProperty(_p, 'MOMType', {
        value: 'MOM PenStroke'
    });

    Object.defineProperty(_p, 'type', {
        /* this is used for CPS selectors*/
        value: 'penstroke'
    });

    _p._acceptedChildren = [PenStrokePoint];

    return PenStroke;
});


define('metapolator/models/MOM/ContourPoint',[
    './_Node'
  , './PointData'
  , 'metapolator/models/CPS/whitelistProxies'
], function(
    Parent
  , PointData
  , whitelistProxies
) {
    
    /**
     * This Element represents a point of a of a MoM Contour (outline).
     * Its properties are the absolute coordinates of an on-curve point
     * of the outline of a contour.
     *
     * It doesn't accept add or removal of children.
     *
     * pointData is expected to be a PointData instance with three readable keys:
     * {
     *      in: Vector // must be set
     *    , on: Vector // must be set
     *    , out: Vector // must be set
     * }
     *
     * These are the absolute coordinates of the skeleton.
     *
     */
    function ContourPoint(pointData) {
        Parent.call(this);
        if(!(pointData) instanceof PointData)
            throw new TypeError('Expected an instance of PointData.');
        this._skeleton = pointData;
        Object.freeze(this._children);
    }
    var _p = ContourPoint.prototype = Object.create(Parent.prototype);
    _p.constructor = ContourPoint;

    //inherit from parent
    _p._cps_whitelist = {
        skeleton: 'skeleton'
    };//inherit from parent
    (function(source) {
        for(var k in source) if(!this.hasOwnProperty(k)) this[k] = source[k];
    }).call(_p._cps_whitelist, Parent.prototype._cps_whitelist);


    _p.clone = function() {
        var clone = new this.constructor(new PointData(this._skeleton));
        this._cloneProperties(clone);
        return clone;
    };

    Object.defineProperty(_p, 'MOMType', {
        value: 'MOM ContourPoint'
    });

    Object.defineProperty(_p, 'type', {
        /* this is used for CPS selectors */
        value: 'p'
    });

    /**
     * This is the Original data from the glif-file
     * I thought about calling it origin, maybe.
     */
    Object.defineProperty(_p, 'skeleton', {
        get: function() {
            return this._skeleton;
        }
    });

    _p._acceptedChildren = [];

    return ContourPoint;
});

define('metapolator/models/MOM/Contour',[
    './_Contour'
  , './ContourPoint'
], function(
    Parent
  , ContourPoint
) {
    
    /**
     * This Element is the container of all points of a outline contour.
     * It may have some metadata (like an identifier) and contain children
     * of type MOM ContourPoint.
     */
    function Contour() {
        Parent.call(this);
    }
    var _p = Contour.prototype = Object.create(Parent.prototype);
    _p.constructor = Contour;

    Object.defineProperty(_p, 'MOMType', {
        value: 'MOM Contour'
    });

    Object.defineProperty(_p, 'type', {
        /* this is used for CPS selectors*/
        value: 'contour'
    });

    _p._acceptedChildren = [ContourPoint];

    return Contour;
});


/*
 * Don't edit this file by hand!
 * This file was generated from a npm-package using gulp. 
 * For more information see gulpfile.js in the project root
 */
define('complex/Complex',['require','exports','module'],function (require, exports, module) {
var Complex = function(real, imag){
	Object.defineProperty(this, 'real', {
		value: real !== undefined ? real : 0
		, writable: false
	})
	
	Object.defineProperty(this, 'imag', {
		value: imag !== undefined ? imag : 0
		, writable: false
	})
};

var prototype = Complex.prototype = {
	constructor: Complex,
	fromRect: function(a, b) {
		return new this.constructor(a, b)
	},

	fromPolar: function(r, phi){
		if (typeof r == 'string'){
			var parts = r.split(' ');
			r = parts[0];
			phi = parts[1];
		}
		return new this.constructor(
			r * Math.cos(phi),
			r * Math.sin(phi)
		);
	},

	toPrecision: function(k){
		return new this.constructor(
			this.real.toPrecision(k),
			this.imag.toPrecision(k)
		);
	},

	toFixed: function(k){
		return new this.constructor(
			this.real.toFixed(k),
			this.imag.toFixed(k)
		);
	},

	magnitude: function(){
		var a = this.real, b = this.imag;
		return Math.sqrt(a * a + b * b);
	},

	angle: function(){
		return Math.atan2(this.imag, this.real);
	},

	conjugate: function(){
		return new this.constructor(this.real, -this.imag);
	},

	negate: function(){
		return new this.constructor(-this.real, -this.imag);
	},

	multiply: function(z){
		z = this.constructor.from(z);
		var a = this.real, b = this.imag;
		return new this.constructor(
			z.real * a - z.imag * b,
			b * z.real + z.imag * a
		);
	},

	divide: function(z){
		z = this.constructor.from(z);
		var divident = (Math.pow(z.real, 2) + Math.pow(z.imag, 2)),
			a = this.real, b = this.imag;
		return new this.constructor(
			(a * z.real + b * z.imag) / divident,
			(b * z.real - a * z.imag) / divident
		);
	},

	add: function(z){
		z = this.constructor.from(z);
		return new this.constructor(this.real + z.real, this.imag + z.imag);
	},

	subtract: function(z){
		z = this.constructor.from(z);
		return new this.constructor(this.real - z.real, this.imag - z.imag);
	},

	pow: function(z){
		z = this.constructor.from(z);
		var result = z.multiply(this.clone().log()).exp(); // z^w = e^(w*log(z))
		return new this.constructor(result.real, result.imag);
	},

	sqrt: function(){
		var abs = this.magnitude(),
			sgn = this.imag < 0 ? -1 : 1;
		return new this.constructor(
			Math.sqrt((abs + this.real) / 2),
			sgn * Math.sqrt((abs - this.real) / 2)
		);
	},

	log: function(k){
		if (!k) k = 0;
		return new this.constructor(
			Math.log(this.magnitude()),
			this.angle() + k * 2 * Math.PI
		);
	},

	exp: function(){
		return this.fromPolar(
			Math.exp(this.real),
			this.imag
		);
	},

	sin: function(){
		var a = this.real, b = this.imag;
		return new this.constructor(
			Math.sin(a) * cosh(b),
			Math.cos(a) * sinh(b)
		);
	},

	cos: function(){
		var a = this.real, b = this.imag;
		return new this.constructor(
			Math.cos(a) * cosh(b),
			Math.sin(a) * sinh(b) * -1
		);
	},

	tan: function(){
		var a = this.real, b = this.imag,
			divident = Math.cos(2 * a) + cosh(2 * b);
		return new this.constructor(
			Math.sin(2 * a) / divident,
			sinh(2 * b) / divident
		);
	},

	sinh: function(){
		var a = this.real, b = this.imag;
		return new this.constructor(
			sinh(a) * Math.cos(b),
			cosh(a) * Math.sin(b)
		);
	},

	cosh: function(){
		var a = this.real, b = this.imag;
		return new this.constructor(
			cosh(a) * Math.cos(b),
			sinh(a) * Math.sin(b)
		);
	},

	tanh: function(){
		var a = this.real, b = this.imag,
			divident = cosh(2 * a) + Math.cos(2 * b);
		return new this.constructor(
			sinh(2 * a) / divident,
			Math.sin(2 * b) / divident
		);
	},

	clone: function(){
		return new this.constructor(this.real, this.imag);
	},

	toString: function(polar){
		if (polar) return this.magnitude() + ' ' + this.angle();

		var ret = '', a = this.real, b = this.imag;
		if (a) ret += a;
		if (a && b || b < 0) ret += b < 0 ? '-' : '+';
		if (b){
			var absIm = Math.abs(b);
			if (absIm != 1) ret += absIm;
			ret += 'i';
		}
		return ret || '0';
	},

	equals: function(z) {
		z = this.constructor.from(z);
		return (z.real == this.real && z.imag == this.imag);
	}

};

var alias = {
	abs: 'magnitude'
  , arg: 'angle'
  , phase: 'angle'
  , conj: 'conjugate'
  , '**': 'pow'
  , mult: 'multiply'
  , '*':  'multiply'
  , dev: 'divide'
  , '/': 'divide'
  , '+': 'add'
  , sub: 'subtract'
  , '-': 'subtract'
  , '=': 'equals'
};

for (var a in alias) prototype[a] = prototype[alias[a]];

// factories and constants
var extend = {

	from: function(real, im) {
		if (real instanceof Complex) return new Complex(real.real, real.imag);
		return new Complex(real, im);
	},

	fromString: function(str) {
		var match, real, im;
		if (str == 'i') str = '0+1i';
		match = str.match(/(\d+)?([\+\-]\d*)[ij]/);
		if (match) {
			real = match[1];
			im = (match[2] == '+' || match[2] == '-')
				? match[2] + '1'
				: match[2];
		}
		return new Complex(+real, +im);
	},

	fromPolar: function(r, phi) {
		return new Complex(1, 1).fromPolar(r, phi);
	},

	i: new Complex(0, 1),

	one: new Complex(1, 0)

};

for (var e in extend) Complex[e] = extend[e];

var sinh = function(x){
	return (Math.pow(Math.E, x) - Math.pow(Math.E, -x)) / 2;
};

var cosh = function(x){
	return (Math.pow(Math.E, x) + Math.pow(Math.E, -x)) / 2;
};

module.exports = Complex;


});

define('metapolator/math/Vector',[
    'complex/Complex'
  , 'metapolator/models/CPS/whitelistProxies'
], function(
    Parent
  , whitelistProxies
) {
    

    /**
     * Add access with geometry names "x" and "y" and a minimal
     * array interface with length (== 2), 0, 1;
     */
    function Vector(x, y) {
        Parent.call(this, x, y);
        this.cps_proxy = whitelistProxies.generic(this, this._cps_whitelist);
    }
    var _p = Vector.prototype = Object.create(Parent.prototype);
    _p.constructor = Vector;

    _p._cps_whitelist = {
        x: 'x'
      , y: 'y'
      , length: 'len'
      , angle: 'rad'
    };


    Vector.fromArray = function(arr) {
        return new _p.constructor(arr[0], arr[1]);
    };

    function _getReal() {
        /*jshint validthis:true*/
        return this.real;
    }

    function _getImaginary() {
        /*jshint validthis:true*/
        return this.imag;
    }

    Object.defineProperty(_p, 'x', {get: _getReal});
    Object.defineProperty(_p, 'y', {get: _getImaginary});

    // array interface
    Object.defineProperty(_p, 'length', {
        value: 2
      , writable: false
      , enumerable: true
    });
    Object.defineProperty(_p, '0', {get: _getReal});
    Object.defineProperty(_p, '1', {get: _getImaginary});

    _p.valueOf = function() {
        return Array.prototype.slice.call(this);
    };

    _p.toString = function() {
        return '<Vector ' + this.valueOf() +'>';
    };

    // factories and constants
    Vector.i = new Vector(0, 1);
    Vector.one = new Vector(1, 0);

    Vector.from = function(x, y) {
        // just map to Parent and then convert
        var complex = Parent.from(x, y);
        return new Vector(complex.real, complex.imag);
    };

    Vector.fromPolar = function(r, phi) {
        return new Vector(1, 1).fromPolar(r, phi);
    };


    // Some getters, so we can use these easily with CPS. At the moment
    // CPS doesn't provide facilities to call external methods, i.e.
    // methods that are not defined as operators but properties of the
    // element at hand. I think this would make more problems than it
    // would solve, so getters is the way.

    /**
     * A getter for the "length" of the vector, however "length" is already
     * used for an array like interface of Vector. So "len" it is, because
     * its short and often used to abbreviate "length".
     */
    Object.defineProperty(_p, 'len', {
        get: Parent.prototype.magnitude
    });

    /**
     * A getter for the angle of the vector in radians.
     */
    Object.defineProperty(_p, 'rad', {
        get: Parent.prototype.angle
    });

    return Vector;
});

define('metapolator/models/MOM/Component',[
    './_Contour'
  , 'metapolator/models/CPS/whitelistProxies'
], function(
    Parent
  , whitelistProxies
) {
    
    /**
     * This is a UFO component reference.
     */
    function Component( baseGlyphName, transformation ) {
        Parent.call(this);
        this._baseGlyphName  = baseGlyphName;
        this._transformation = transformation;
        Object.freeze(this._children);
        this.cps_proxy = whitelistProxies.generic(this, this._cps_whitelist);
    }
    var _p = Component.prototype = Object.create(Parent.prototype);
    _p.constructor = Component;

    _p._cps_whitelist = {
        baseGlyphName:           '_baseGlyphName'
      , originalTransformation:  '_transformation'
    };
    //inherit from parent
    (function(source) {
        for(var k in source) if(!this.hasOwnProperty(k)) this[k] = source[k];
    }).call(_p._cps_whitelist, Parent.prototype._cps_whitelist);

    _p.clone = function() {
        var clone = new this.constructor(this._baseGlyphName, this._transformation);
        this._cloneProperties(clone);
        return clone;
    };

    Object.defineProperty(_p, 'baseGlyphName', {
        get: function() {
            return this._baseGlyphName;
        }
    });
    Object.defineProperty(_p, 'transformation', {
        get: function() {
            return this._transformation;
        }
    });

    Object.defineProperty(_p, 'MOMType', {
        value: 'MOM Component'
    });

    Object.defineProperty(_p, 'type', {
        /* this is used for CPS selectors*/
        value: 'component'
    });

    _p._acceptedChildren = [];

    return Component;
});


/**
 * Copyright (c) 2011, Lasse Fister lasse@graphicore.de, http://graphicore.de
 * 
 * You should have received a copy of the MIT License along with this program.
 * If not, see http://www.opensource.org/licenses/mit-license.php
 * 
 * This is a translation of the contents of fontTools/misc/transform.py
 * The svn revision of the source file in trunk/Lib/  was 588 from 2011-03-28 12:18:27 +0200 
 * 
 * Some cool python features do not work on this thing but I put in some
 * efforts to mimic the python implementation. The future will show whether
 * the direction is good
 *
 * I even copied the docstrings and comments! (These may still refer to
 * the Python code)
 * 
 * Affine 2D transformation matrix class.
 * 
 * The Transform class implements various transformation matrix operations,
 * both on the matrix itself, as well as on 2D coordinates.
 * 
 * This module exports the following symbols:
 * 
 *     Transform -- this is the main class
 *     Identity  -- Transform instance set to the identity transformation
 *     Offset    -- Convenience function that returns a translating transformation
 *     Scale     -- Convenience function that returns a scaling transformation
 * 
 * Examples: //still in python
 * 
 *     >>> t = Transform(2, 0, 0, 3, 0, 0)
 *     >>> t.transformPoint((100, 100))
 *     (200, 300)
 *     >>> t = Scale(2, 3)
 *     >>> t.transformPoint((100, 100))
 *     (200, 300)
 *     >>> t.transformPoint((0, 0))
 *     (0, 0)
 *     >>> t = Offset(2, 3)
 *     >>> t.transformPoint((100, 100))
 *     (102, 103)
 *     >>> t.transformPoint((0, 0))
 *     (2, 3)
 *     >>> t2 = t.scale(0.5)
 *     >>> t2.transformPoint((100, 100))
 *     (52.0, 53.0)
 *     >>> import math
 *     >>> t3 = t2.rotate(math.pi / 2)
 *     >>> t3.transformPoint((0, 0))
 *     (2.0, 3.0)
 *     >>> t3.transformPoint((100, 100))
 *     (-48.0, 53.0)
 *     >>> t = Identity.scale(0.5).translate(100, 200).skew(0.1, 0.2)
 *     >>> t.transformPoints([(0, 0), (1, 1), (100, 100)])
 *     [(50.0, 100.0), (50.550167336042726, 100.60135501775433), (105.01673360427253, 160.13550177543362)]
 *     >>>
 */

define(
    'ufojs/tools/misc/transform',['ufojs/main', 'ufojs/errors'],
    function(main, errors)
{
    
    /*shortcuts*/
    var enhance = main.enhance;
    
    /*constants*/
    var EPSILON = 1e-15,
        ONE_EPSILON = 1 - EPSILON,
        MINUS_ONE_EPSILON = -1 + EPSILON;
    
    /*helpers*/
    function _normSinCos(v)
    {
        if (Math.abs(v) < EPSILON)
            v = 0;
        else if (v > ONE_EPSILON)
            v = 1;
        else if (v < MINUS_ONE_EPSILON)
            v = -1;
        return v
    }
    
    /*constructor*/
    /**
    * 2x2 transformation matrix plus offset, a.k.a. Affine transform.
    * All transforming methods, eg. rotate(), return a new Transform instance.
    * 
    * Examples: //in python still
    *    >>> t = Transform()
    *    >>> t
    *    <Transform [1 0 0 1 0 0]>
    *    >>> t.scale(2)
    *    <Transform [2 0 0 2 0 0]>
    *    >>> t.scale(2.5, 5.5)
    *    <Transform [2.5 0.0 0.0 5.5 0 0]>
    *    >>>
    *    >>> t.scale(2, 3).transformPoint((100, 100))
    *    (200, 300)
    */
    function Transform(transformation /* [xx=1, xy=0, yx=0, yy=1, dx=0, dy=0] */) {
        //can't change easily after creation
        var affine = [1, 0, 0, 1, 0, 0];
        
        /**
         * the next two methods are just accessors to the local affine value
         **/
        this.__get = function (key)
        {
            if(affine[key] === undefined)
                throw new errors.Key('The key ' + key + 'does not exist in' + this);
            return affine[key];
        }
        this.__affine = function()
        {
            //return a copy
            return affine.slice(0);
        }
        
        
        
        if(transformation === undefined)
            return;
        for(var i = 0; i < 6; i++) {
            if(transformation[i] === undefined || transformation[i] === null)
                continue;
            affine[i] = transformation[i];
        }
    }
    
    /*definition*/
    enhance(Transform, {
        /**
         * Transform a point.
         *
         *  Example:
         *      >>> t = Transform()
         *      >>> t = t.scale(2.5, 5.5)
         *      >>> t.transformPoint((100, 100))
         *      (250.0, 550.0)
         */
        transformPoint: function( pt )
        {
            var xx = this[0],
                xy = this[1],
                yx = this[2],
                yy = this[3],
                dx = this[4],
                dy = this[5],
                x = pt[0],
                y = pt[1];
            return [xx*x + yx*y + dx, xy*x + yy*y + dy];
        },
        /**
         * Transform a list of points.
         * 
         * Example: //in python
         *      >>> t = Scale(2, 3)
         *      >>> t.transformPoints([(0, 0), (0, 100), (100, 100), (100, 0)])
         *      [(0, 0), (0, 300), (200, 300), (200, 0)]
         *      >>>
         */
        transformPoints: function(points)
        {
            return points.map(this.transformPoint, this);
        },
        /**
         * Return a new transformation, translated (offset) by x, y.
         * 
         * Example:
         *      >>> t = Transform()
         *      >>> t.translate(20, 30)
         *      <Transform [1 0 0 1 20 30]>
         *      >>>
         */
        translate: function(x, y)
        {
            x = x || 0;
            y = y || 0;
            return this.transform([1, 0, 0, 1, x, y ]);
        },
        /**
         * Return a new transformation, scaled by x, y. The 'y' argument
         * may be undefined, which implies to use the x value for y as well.
         * 
         * Example:
         *      >>> t = Transform()
         *      >>> t.scale(5)
         *      <Transform [5 0 0 5 0 0]>
         *      >>> t.scale(5, 6)
         *      <Transform [5 0 0 6 0 0]>
         *      >>>
         */
        scale: function(x, y)
        {
            if(x === undefined)
                x = 1;
            if(y === undefined || y === null)
                y = x;
            return this.transform([x, 0, 0, y, 0, 0]);
        },
        /**
         * Return a new transformation, rotated by 'angle' (radians).
         * 
         * Example: //python
         *      >>> import math
         *      >>> t = Transform()
         *      >>> t.rotate(math.pi / 2)
         *      <Transform [0 1 -1 0 0 0]>
         *      >>>
         */
        rotate: function(angle)
        {
            var c = _normSinCos(Math.cos(angle)),
                s = _normSinCos(Math.sin(angle));
            return this.transform([c, s, -s, c, 0, 0]);
        },
        /**
         * Return a new transformation, skewed by x and y.
         * 
         * Example:
         *      >>> import math
         *      >>> t = Transform()
         *      >>> t.skew(math.pi / 4)
         *      <Transform [1.0 0.0 1.0 1.0 0 0]>
         *      >>>
         */
        skew: function(x, y)
        {
            x = x || 0;
            y = y || 0;
            return this.transform([1, Math.tan(y), Math.tan(x), 1, 0, 0]);
        },
        /**
         * Return a new transformation, transformed by another
         * transformation.
         * 
         * Example:
         *      >>> t = Transform(2, 0, 0, 3, 1, 6)
         *      >>> t.transform((4, 3, 2, 1, 5, 6))
         *      <Transform [8 9 4 3 11 24]>
         *      >>>
         */
        transform: function(other)
        {
            var xx1 = other[0],
                xy1 = other[1],
                yx1 = other[2],
                yy1 = other[3],
                dx1 = other[4],
                dy1 = other[5],
                xx2 = this[0],
                xy2 = this[1],
                yx2 = this[2],
                yy2 = this[3],
                dx2 = this[4],
                dy2 = this[5];
            return new Transform([
                xx1*xx2 + xy1*yx2,
                xx1*xy2 + xy1*yy2,
                yx1*xx2 + yy1*yx2,
                yx1*xy2 + yy1*yy2,
                xx2*dx1 + yx2*dy1 + dx2,
                xy2*dx1 + yy2*dy1 + dy2
            ]);
        },
        /**
         * Return a new transformation, which is the other transformation
         * transformed by self. self.reverseTransform(other) is equivalent to
         * other.transform(self).
         * 
         * Example:
         *      >>> t = Transform(2, 0, 0, 3, 1, 6)
         *      >>> t.reverseTransform((4, 3, 2, 1, 5, 6))
         *      <Transform [8 6 6 3 21 15]>
         *      >>> Transform(4, 3, 2, 1, 5, 6).transform((2, 0, 0, 3, 1, 6))
         *      <Transform [8 6 6 3 21 15]>
         *      >>>
         */
        reverseTransform: function(other)
        {
            var xx1 = this[0],
                xy1 = this[1],
                yx1 = this[2],
                yy1 = this[3],
                dx1 = this[4],
                dy1 = this[5],
                xx2 = other[0],
                xy2 = other[1],
                yx2 = other[2],
                yy2 = other[3],
                dx2 = other[4],
                dy2 = other[5];
            return new Transform([
                xx1*xx2 + xy1*yx2,
                xx1*xy2 + xy1*yy2,
                yx1*xx2 + yy1*yx2,
                yx1*xy2 + yy1*yy2,
                xx2*dx1 + yx2*dy1 + dx2,
                xy2*dx1 + yy2*dy1 + dy2
            ]);
        },
        /**
         * Return the inverse transformation.
         * 
         * Example:
         *     >>> t = Identity.translate(2, 3).scale(4, 5)
         *     >>> t.transformPoint((10, 20))
         *     (42, 103)
         *     >>> it = t.inverse()
         *     >>> it.transformPoint((42, 103))
         *     (10.0, 20.0)
         *     >>>
         */
        inverse: function()
        {
            if( this.cmp(Identity) )
                return this;
            var XX = this[0],
                XY = this[1],
                YX = this[2],
                YY = this[3],
                DX = this[4],
                DY = this[5],
                det = XX*YY - YX*XY,
                xx = YY/det,
                xy = -XY/det,
                yx = -YX/det,
                yy = XX/det,
                dx = -xx*DX - yx*DY,
                dy = -xy*DX - yy*DY;
            return new Transform([xx, xy, yx, yy, dx, dy]);
        },
        /**
         * Return a PostScript representation:
         *  >>> t = Identity.scale(2, 3).translate(4, 5)
         *  >>> t.toPS()
         *  '[2 0 0 3 8 15]'
         *  >>>
         */
        toPS: function()
        {
            return ['[', this.__affine().join(' '),']'].join('');
        },
        /*compare*/
        cmp: function(other)
        {
            return (
               other[0] === this[0]
            && other[1] === this[1]
            && other[2] === this[2]
            && other[3] === this[3]
            && other[4] === this[4]
            && other[5] === this[5]
            )
        },
        valueOf: function()
        {
            return ['<Transform ', this.toPS(), '>'].join('');
        },
        toString: function()
        {
            return this.__affine().join(' ');
        },
        /**
         * Transform instances also behave like a list of length 6:
         */
        get length()
        {
            return 6;
        },
        /**
         * Transform instances also behave like sequences and even support
         * slicing...
         */
        slice: function(start, len)
        {
            return this.__affine().slice(start, len);
        },
        /**
         * Transform is usable kind of like an array
         * var t = new Transform();
         * echo t[0]; //1
         */
        get 0()
        {
            return this.__get(0);
        },
        get 1()
        {
            return this.__get(1);
        },
        get 2()
        {
            return this.__get(2);
        },
        get 3()
        {
            return this.__get(3);
        },
        get 4()
        {
            return this.__get(4);
        },
        get 5()
        {
            return this.__get(5);
        }
    });
    /**
    * Return the identity transformation offset by x, y.
    * 
    * Example:
    *      >>> offset(2, 3)
    *      <Transform [2 0 0 3 0 0]>
    *      >>>
    */
    var Offset= function(x, y) {
        x = x || 0;
        y = y || 0;
        return new Transform([1, 0, 0, 1, x, y]);
    }
    
    /**
     * Return the identity transformation scaled by x, y. The 'y' argument
     * may be None, which implies to use the x value for y as well.
     * 
     * Example:
     *  >>> Scale(2, 3)
     *  <Transform [2 0 0 3 0 0]>
     *  >>>
     */
    var Scale = function(x, y) {
        if(y === undefined || y === null)
            y = x;
        return new Transform([x, 0, 0, y, 0, 0]);
    }
    
    var Identity = new Transform();
    
    return {
        Transform: Transform,
        Identity: Identity,
        Offset: Offset,
        Scale: Scale
    }
});

define('metapolator/project/MOMPointPen',[
    'metapolator/errors'
  , 'ufojs/main'
  , 'ufojs/tools/pens/AbstractPointPen'
  , 'metapolator/models/MOM/PenStroke'
  , 'metapolator/models/MOM/PenStrokePoint'
  , 'metapolator/models/MOM/Contour'
  , 'metapolator/models/MOM/ContourPoint'
  , 'metapolator/math/Vector'
  , 'metapolator/models/MOM/Component'
  , 'metapolator/models/MOM/PointData'
  , 'ufojs/tools/misc/transform'
], function(
    errors
  , ufoJSUtils
  , Parent
  , PenStroke
  , PenStrokePoint
  , Contour
  , ContourPoint
  , Vector
  , Component
  , PointData
  , transform
) {
    

    var PointPenError = errors.PointPen
      , isNumber = ufoJSUtils.isNumber
      , Transformation = transform.Transform
      ;


    /**
     * Point Pen to draw a Skeleton outline into a MOM glyph, thus creating
     * the MOM Tree beyond glyph level
     *
     * This copies a lot of the validation logic of
     * ufojs/ufoLib/glifLib/GLIFPointPen
     *
     */
    function MOMPointPen(glyph) {
        Parent.call(this);
        this._glyph = glyph;
        this._contour = null;
        this._prevOffCurveCount = 0;
        this._prevPointTypes = [];
    }

    var _p = MOMPointPen.prototype = Object.create(Parent.prototype);
    _p.constructor = MOMPointPen;

    _p.beginPath = function(kwargs/*optional, dict*/) {
        kwargs = kwargs || {};
        if(this._contour)
            throw new PointPenError('Called beginPath but there is an open '
                    + 'path. Call endPath first.');
        this._contour = [];
        this._contour.element = this._makeContour(kwargs);

        this._prevOffCurveCount = 0;
        this._prevPointTypes = [];
    };

    var contourIndicator = 'C:';
    _p._isContourPath = function(identifier) {
        if(!identifier) return false;
        return identifier
            ? (identifier.slice(0, contourIndicator.length) === contourIndicator)
            : false// no identifier => penstroke
            ;
    };

    _p._makeContour =  function(kwargs) {
        var isContour = this._isContourPath(kwargs.identifier)
          , element = isContour ? new Contour() : new PenStroke()
          ;
        if(kwargs.identifier !== undefined)
            // MOM will have to check validity and uniqueness
            element.id = (isContour)
                 ? kwargs.identifier.slice(contourIndicator.length)
                 : kwargs.identifier
                 ;
        return element;
    };

    /**
     * End the current sub path.
     */
    _p.endPath = function() {
        if(!this._contour)
            throw new PointPenError('Called endPath but no path was open. '
                    +' Call beginPath first.');
        if(this._prevPointTypes.length
                        && this._prevPointTypes[0] === 'move'
                        && this._prevPointTypes.slice(-1)[0] == 'offcurve')
            throw new PointPenError('open contour has loose offcurve point');
        // seal the last point data element, it is complete


        if(this._contour.element instanceof Contour) {
            // rotate, so that the list is like so: [in, on, out, in, on, out, ...]
            // the first on point must stay the first on point:
            // [in, on, ...] nothing to do
            // [on, ..., out, in] pop in and unshift it to the start
            // [out, in, on, ...] shift out and push it to the end
            // it's enough to find the first on point:
            if(this._contour[0][0] instanceof ContourPoint)
                this._contour.unshift(this._contour.pop());
            else if((this._contour[2][0] instanceof ContourPoint))
                this._contour.push(this._contour.shift());
        }

        var i, pointData;
        for(i=0;i<this._contour.length;i++) {
            if(this._contour[i][0] === undefined)
                // the first item of off-curve points is undefined
                continue;
            pointData =  this._contour[i][1];
            if(i>0)
                // the moveTo at the beginning of a penstroke has no
                // incoming control-point
                pointData['in'] = this._contour[i-1][1];
            if(this._contour[i+1])
                pointData.out = this._contour[i+1][1];
            Object.seal(pointData);
            this._contour.element.add(this._contour[i][0]);
        }

        this._glyph.add(this._contour.element);
        this._contour = null;
    };

    /**
     * Add a point to the current sub path.
     */
    _p.addPoint = function(
        pt,
        segmentType /* default null */,
        smooth /* default false */,
        name /* default null */,
        kwargs /* default an object, javascript has no **kwargs syntax */
    ) {
        segmentType = (segmentType === undefined) ? null : segmentType;
        smooth = !!smooth;
        name = (name === undefined) ? null : name;
        kwargs = (kwargs || {});//an "options" object
        var vector, point, pointData, lastVector;

        if(!this._contour)
            throw new PointPenError('Called addPoint but there is no open. '
                    +' path. Call beginPath first.');
            // coordinates
        if(pt === undefined)
            throw new PointPenError('Missing point argument');
        if(pt.filter(isNumber).length < 2)
            throw new PointPenError('coordinates must be int or float');

        vector = Vector.fromArray(pt.map(parseFloat));

        // segment type
        if(this._contour.element instanceof PenStroke
                    && segmentType !== 'move'
                    && this._prevPointTypes.length === 0)
            throw new PointPenError('MOMPointPen expects only open contours '
                        + 'for PenStroke elements. '
                        + 'This are contours that begin with a "move" point. '
                        + 'This contour begins with "'+segmentType+'"');
        else if (segmentType === 'offcurve')
            segmentType = null;
        else if(this._contour.element instanceof Contour
                    && segmentType !== 'curve'
                    && segmentType !== null)
            throw new PointPenError('MOMPointPen expects only the segment '
                        + 'type "curve" for on-curve points of Contour elements. '
                        + 'This point is a "'+segmentType+'"');
        else if(segmentType === 'move' && this._prevPointTypes.length)
            throw new PointPenError('move occurs after a point has '
                                    +'already been added to the contour.');
        else if(segmentType === 'line'
                    && this._prevPointTypes.length
                    && this._prevPointTypes.slice(-1)[0] === 'offcurve')
            throw new PointPenError('offcurve occurs before line point.');
        else if (segmentType === 'curve' && this._prevOffCurveCount > 2)
            throw new PointPenError('too many offcurve points before '
                                                        + 'curve point.');
        this._prevPointTypes.push(segmentType || 'offcurve');

        if (segmentType === null) {
            // off curve
            this._prevOffCurveCount += 1;
            this._contour.push([undefined, vector]);
            return;
        }
        // If we get here, this is an on-curve point.
        this._prevOffCurveCount = 0;
        pointData = new PointData({
            'in': undefined
          , on: vector
          , out: undefined
        });
        point = this._contour.element instanceof Contour
                    ? new ContourPoint(pointData)
                    : new PenStrokePoint(pointData)
                    ;
        // we translate names into classes, because they dont have to be
        // unique
        if (name !== null)
            (name.match(/\S+/g) || [])
                    .filter(function(item){ return !!item.length;})
                    .forEach(point.setClass, point);
        if(kwargs.identifier !== undefined)
            // MOM will have to check validity and uniqueness
            point.id = kwargs.identifier;
        this._contour.push([point, pointData]);
    };

    /**
     * Add a sub glyph.
     */
    _p.addComponent = function(baseGlyphName, transformation) {
        var transMatrix, component;

        transMatrix = new Transformation( transformation );
        component = new Component( baseGlyphName, transMatrix );
        this._glyph.add(component);
    };

    return MOMPointPen;
});

define('metapolator/project/ProjectMaster',[
    'metapolator/errors'
  , 'metapolator/models/MOM/Master'
  , 'metapolator/models/MOM/Glyph'
  , './MOMPointPen'
], function(
    errors
  , Master
  , Glyph
  , MOMPointPen
) {
    

    function ProjectMaster(io, project, name, glyphSetDir, cpsFile) {
        this._io = io;
        this._project = project;
        this._name = name;
        this._glyphSetDir = glyphSetDir;
        this._cpsFile = cpsFile;
        this._glyphSet = undefined;
    }

    var _p = ProjectMaster.prototype;
    _p.constructor = ProjectMaster;

    Object.defineProperty(_p, 'glyphSet', {
        get: function() {
            if(!this._glyphSet)
                this._glyphSet = this._project.getNewGlyphSet(
                                            false, this._glyphSetDir);
            return this._glyphSet;
        }
    });

    _p.saveCPS = function(filename, cps) {
        this._io.writeFile(false, this._project.cpsDir+'/'+filename, cps);
    };

    _p.deleteCPS = function(filename) {
        this._io.unlink(false, this._project.cpsDir+'/'+filename);
    };

    _p.loadMOM = function() {
        // create a MOM Master use this.glyphSet to create glyphs, penstrokes and points
        var fontinfo = this._project.getFontinfo()
          , master = new Master(fontinfo)
          , glyphNames = this.glyphSet.keys()
          , glyphName
          , ufoGlyph
          , glyph
          , i=0
          , classes
          ;
        if(glyphNames.length)
            classes = this._project.getGlyphClassesReverseLookup();
        for(;i<glyphNames.length;i++) {
            glyphName = glyphNames[i];
            ufoGlyph = this.glyphSet.get(glyphName);
            glyph = new Glyph();// FIXME do the stuff of setUFOData here!
            glyph.id = glyphName;
            if(glyphName in classes)
                classes[glyphName].forEach(glyph.setClass, glyph);
            // fetch glyph data and draw the glyph to the MOM
            ufoGlyph.drawPoints(false, new MOMPointPen(glyph));
            // FIXME: if possible remove all usages of `setUFOData`.
            // This can happen in the Constructor.
            // maybe, when event propagation for this stuf is built, we
            // can use this method again
            glyph.setUFOData(ufoGlyph);
            master.add(glyph);
        }
        return master;
    };

    return ProjectMaster;
});

define('metapolator/models/CPS/dataTypes/_FormulaeValue',[
    'metapolator/errors'
], function(
    errors
) {
    

    var NotImplementedError = errors.NotImplemented;

    function _FormulaeValue(getAPI, stack) {
        /*jshint validthis:true */
        this._getAPI = getAPI;
        this._stack = stack;
    }

    var _p = _FormulaeValue.prototype;
    _p.constructor = _FormulaeValue;

    _p.getValue = function() {
        throw new NotImplementedError('The getValue Interface must be '
                        +'implemented by the children of _FormulaeValue');
    };

    _p.toString = function() {
        return '<' + this.constructor.name
             + ' with stack "' + this._stack + '">';
    };

    return _FormulaeValue;
});

define('metapolator/models/CPS/dataTypes/formulae/parsing/_Token',[
    'metapolator/errors'
], function(
    errors
) {
    

    var CPSFormulaError = errors.CPSFormula;

    /**
     * An abstract item that is an element of a formula Stack.
     *
     * This is the base for formulae/parsing/OperatorToken and formulae/parsing/_ValueToken
     */
    function _Token(literal, preConsumes, postConsumes) {
        /*jshint validthis:true */
        this._literal = literal;
        this._setConsumption(preConsumes, postConsumes);
    }

    var _p = _Token.prototype;
    _p.constructor = _Token;
    _p.toString = function() {
        return ['<', this.constructor.name, ': ', this.literal, '>'].join('');
    };

    // Currently every _Token is expected to leave exactly one
    // value on the stack after execution, this will probably not
    // change soon
    Object.defineProperty(_p, '_ejects', {
        value: 1
      , writable: false
    });

    _p._setConsumption = function(preConsumes, postConsumes){
        if(typeof preConsumes !== 'number')
            throw new CPSFormulaError('preConsumes must be a number, but is "'
                                + preConsumes +'" typeof: '+ typeof preConsumes);
        this._preConsumes = preConsumes;
        if(typeof postConsumes !== 'number')
            throw new CPSFormulaError('postConsumes must be a number, but is "'
                                + postConsumes +'" typeof: '+ typeof postConsumes);
        this._postConsumes = postConsumes;
    };

    /**
     * Return a child object which has `this` as prototype. The child
     * overides the values for preConsumes, postConsumes.
     *
     * Because operator instances are reused in all parsed formula,
     * it is not possile to fix the consumption values of an operator
     * directly where it appers. This would change the values everywhere
     * where it appears. Instead, we uitilize prototypical inheritance
     * and set the fixed values for the child.
     *
     * We use this behavior when an operator consumes 'Infinity' items
     * from the stack. This is needed for a list (Array) constructor.
     * The actually consumed amount of items can be determined when
     * parsing. Then the operator gets replaced with a version that
     * consumes a fixed amount of items, created by this method.
     */
    _p.fixedConsumptionFactory = function(preConsumes, postConsumes) {
        var child = Object.create(this);
        child._setConsumption(preConsumes, postConsumes);
        return child;
    };

    Object.defineProperty(_p, 'literal', {
        get: function(){ return this._literal; }
    });
    Object.defineProperty(_p, 'preConsumes', {
        get: function(){ return this._preConsumes;}
    });
    Object.defineProperty(_p, 'postConsumes', {
        get: function(){ return this._postConsumes;}
    });

     Object.defineProperty(_p, 'consumes', {
        get: function() {
            if(this.preConsumes === Infinity || this.postConsumes === Infinity)
                throw new CPSFormulaError('This item '+ this + ' '
                    + 'pre- or post-consumes "Infinity" items from the '
                    + 'stack, it is impossible to calculate the exact amount'
                    + 'of items in this method. See this.fixedConsumptionFactory '
                    + 'and its usage in the parser, where an exact amount '
                    + 'of consumption can be calculated.'
                );
            return this.preConsumes + this.postConsumes;
        }
    });

    Object.defineProperty(_p, 'ejects', {
        get: function(){ return this._ejects; }
    });

    return _Token;
});

define('metapolator/models/CPS/dataTypes/formulae/parsing/_ValueToken',[
    'metapolator/errors'
  , './_Token'
], function(
    errors
  , Parent
) {
    

    function _ValueToken(literal) {
        /*jshint validthis:true */
        Parent.call(this, literal, 0, 0);
    }
    var _p = _ValueToken.prototype = Object.create(Parent.prototype);
    _p.constructor = _ValueToken;

    /**
     * Implement this method for children of this class
     */
    _p.getValue = function() {
        throw new errors.NotImplementedError('The getValue interface needs '
                        + ' implementation in child classes of _ValueToken.');
    };

    return _ValueToken;
});

define('metapolator/models/CPS/dataTypes/formulae/parsing/NameToken',[
    'metapolator/errors'
  , './_ValueToken'
], function(
    errors
  , Parent
) {
    

    function NameToken(literal) {
        Parent.call(this, literal, 0, 0);
    }

    /**
     * Literal is a string representing a name/key.
     * Value is looked up using the get method of the StyleDict of the
     * host element or in the context of another host element value may
     * be looked up differntly.
     */
    var _p = NameToken.prototype = Object.create(Parent.prototype);
    _p.constructor = NameToken;

    _p.getValue = function() {
        return this.literal;
    };

    return NameToken;
});

define('metapolator/models/CPS/dataTypes/formulae/parsing/OperatorToken',[
     'metapolator/errors'
   , './_Token'
   , './NameToken'
   , 'ufojs/main'
], function(
    errors
  , Parent
  , NameToken
  , ufoJSUtils
) {
    

    var CPSFormulaError = errors.CPSFormula
      , ValueError = errors.Value
      , isInstance = ufoJSUtils.isInstance
      , stringify = JSON.stringify
      ;

    /**
     * literal:     string, the name of the operator, like: + - Vector etc.
     *              there are some operator literals that are expected by
     *              Parser.tokenize
     *
     * splitting:   defines an operator as splitting, which instructs the
     *              tokenizer to end parsing of the token when it appears.
     *              if an operator is not splitting, it must be followed by
     *              a splitting token. None splitting tokens can be part of
     *              Names
     *
     * precedence: the precedence is used to implement the order of operations.
     *             precedence can be a finite Number and -Infinity for lowest
     *             precedence +Infinity for highest precedence
     *
     * preConsumes,
     * preConsumes: How many tokens this operator consumes
     *              before or after its appearance. This allows the creation
     *              of infix operators.
     *              Infinity is allowed as a value, this makes the creation
     *              of i.e. list constructing operators possible. A Infinity
     *              value will consumes the amount of Items that are corruently
     *              in the stack.
     *
     * methods:     See this._setMethods for a description of the methods argument.
     */
    function OperatorToken(literal, splitting, precedence, preConsumes
                                             , postConsumes, methods) {
        Parent.call(this, literal, preConsumes, postConsumes);
        this._splitting = !!splitting;
        if(typeof precedence !== 'number')
            throw new CPSFormulaError('Precedence must be a number, but is "'
                                + precedence +'" typeof: '+ typeof precedence);
        this._precedence = precedence;
        this._methods = [];
        this._setMethods(methods);

        // need these for access from the compiled functions
        this.CPSFormulaError = CPSFormulaError;
        this.NameToken = NameToken;

        // NOTE: List has a variable argument length, so may others too!
        // The stack compiler will take care of that, but we'll have to
        // wait with compiling
        if(isFinite(this.preConsumes) && isFinite(this.postConsumes))
            this.execute = this.compile();
    }

    var _p = OperatorToken.prototype = Object.create(Parent.prototype);
    _p.constructor = OperatorToken;


    Object.defineProperty(_p, 'precedence', {
        get: function(){ return this._precedence; }
    });

    Object.defineProperty(_p, 'splitting', {
        get: function(){ return this._splitting; }
    });

    /**
     * Methods could be just a function, in which case it would be the
     * single match all implementation for this operator, NameTokens as
     * arguments will be resolved upon invocation.
     *
     * Also, it may be an array of arrays like this:
     *   [
     *        [typename/constructor, [ typename/constructor ...] , method]
     *      , [typename/constructor, [ typename/constructor ...] , method]
     *      , function(){} // optional, match all
     *   ]
     *
     * The first method that matches the actual types of arguments will
     * be used, so an early match all function will shadow later ones.
     *
     * typename/constructor can be everything that is useful with ufoJS/main.isInstance
     * However, the compiled version does not use ufoJS/main.isInstance!
     * That may lead to problems when ufoJS/main.isInstance changes but not
     * the compiling code in here!
     * Usually all Operators will be compiled. Interpreting is still here
     * for legacy reasons, also, the algorithm is easier to read.
     *
     * typename/constructor can have special values:
     *
     * - The string: "*getAPI*", only as very first element:
     *        this does two things:
     *            * it injects the getAPI function as first argument of method
     *            * it doesn't resolve NameToken arguments using getAPI(nameToken.getValue())
     *              so, specifiying *getAPI* means method will handle
     *              NameTokens by itself.
     *        In turn, this means NameToken can be used as a typename/constructor
     *        but it will only ever appear as argument when *getAPI* is requested,
     *        otherwise it will be resolved before invocation.
     *        IMPORTANT: All *getAPI* methods must be defined before the ones without
     *        *getAPI*.
     * - The string "*anything*" which matches anything
     *
     * ufoJS/main.isInstance takes:
     *  - functions which will be checked using "instanceof" or a string
     *  - strings can be everything where typeof actually works, like:
     *                  "number", "string", "undefined", "object"
     *  - strings can be: "int" "float" "NaN" "null" "Infinity" "-Infinity"
     *  - arrays of the above
     */
    _p._setMethods = function(methods) {
        if(typeof methods === 'function')
            this._setMethod(methods);
        else if(methods instanceof Array)
            methods.map(this._setMethod, this);
    };
    /**
     * see _setMethods for an argument description
     */
    _p._setMethod = function(description) {
        var expectedLength;
        if(typeof description === 'function') {
            this._methods.push(description);
            return;
        }
        else if(!(description instanceof Array))
            throw new ValueError('An operator definition should be either '
                + 'a function or an array, see OperatorToken');

        // It is an array

        expectedLength = this.consumes + (
                                description[0] === '*getAPI*' || description[0] === '*unboxed+getAPI*' ? 2 : 1);

        if(description.length !== expectedLength)
            throw new ValueError(this.literal + ': An operator definition array must define '
                + 'the types for all items it consumes plus the method to '
                + 'that is the operator code in the end.'
                + 'This operator should have ' + expectedLength +' '
                + 'items in a definition, but ' + description.length
                + ' was found: ' + description
            );
        else if(typeof description[description.length-1] !== 'function')
            throw new ValueError('The last item of an operator definition '
                + 'must be a type of "function" but this is a "'
                + (typeof description[description.length-1])+'"');
        else if(this._methods.length // this is not the first
                    && description[0] === '*getAPI*' // this is boxed
                    && this._methods[this._methods.length-1][0] !== '*getAPI*')// the previous is unboxed
            throw new ValueError('The previous operator uses "unboxed" NameTokens '
                + 'but this one unboxes itself. (*getAPI* is the  first argument) '
                + 'This is illegal. Operators that unbox themselves  must be '
                + 'defined before operators that expect unboxed values.\n'
                + 'This is because automatic unboxing could cause '
                + 'unpredictable behavior (like a hit where no hit should be) '
                + 'and also errors for not found names. Also, automatic '
                + 'unboxing for a value that doesn\'t need it is bad for '
                + 'performance.'
            );
        // accept it
        // description is an array that suits our expectations
        this._methods.push(description);
    };

    // helper for compile
    function _makeArgNames(length, _prefix, _postfix) {
        var result = [], i, prefix = _prefix || '', postfix = _postfix || '';
        for(i=0;i<length;i++) result.push(prefix + i + postfix);
        return result;
    }

    // helper for compile
    function _makeLocalBoxedNames(body, methods, consumes) {
        var i, l, isBoxed
          , usersOfBoxed = 0
          , args = _makeArgNames(consumes, 'args[', ']')
          , boxedNames
          ;
        for(i=0, l=methods.length;i<l; i++) {
            isBoxed = methods[i][0] === '*getAPI*';
            // The first unboxed user uses the boxed values for unboxing
            // and thus makes also an access to the unboxed values.
            usersOfBoxed += 1;
            // After the first unboxed user, boxed will not be used anymore.
            if(!isBoxed) break;
        }
        if(usersOfBoxed < 2)
            // We don't declare the vars if less than 2 accesses to boxed NameTokens
            // are done. This assumes that declaring locally and two subsequent
            // accesses are cheaper than always accessing the args array;
            return args;
        boxedNames = _makeArgNames(consumes, 'aN');
        for(i=0,l=consumes;i<l;i++)
            body.push('var ' , boxedNames[i] ,' = ', args[i], ';\n');
        return boxedNames;
    }

    // helper for compile
    function _makeLocalUnboxedNames(body, consumes, boxedNames) {
        var i, arg, unboxedNames = _makeArgNames(consumes, 'aV');
        for(i=0;i<consumes;i++) {
            arg = boxedNames[i];
            body.push('var ' , unboxedNames[i] , ' = ' , arg , ' instanceof NameToken '
                    , '? getAPI.get(' , arg , '.getValue()) '
                    , ': ' , arg , ';\n');
        }
        return unboxedNames;
    }

    // helper for compile
    function _makeTypeTest(arg, typeAdress, typeVal, ctors) {
        var typeTest = []
          , typeOfType = typeof typeVal
          , ctorCache
          , ctorName
          ;
        if(typeOfType === 'function') {
            ctorCache = ctors.cache;
            ctorName = ctorCache.get(typeVal);
            if(!ctorName) {
                ctorName = 'c' + (ctors.i++);
                ctors.init.push('var ', ctorName, ' = ', typeAdress,';\n');
                ctorCache.set(typeVal, ctorName);
            }
            typeTest.push( arg, ' instanceof ', ctorName);
        }
        else if (typeOfType === 'string') {
            switch(typeVal) {
                case 'int':
                    typeTest.push('typeof ', arg,' === "number" && '
                            , arg, ' === (',arg,'|0)');
                    break;
                case 'float':
                    typeTest.push('typeof ', arg,' === "number" && '
                            , 'isFinite(', arg, ') && '
                            , arg, ' !== (',arg,'|0)');
                    break;
                case 'number':
                    typeTest.push('typeof ', arg,' === "number" && '
                            , arg, ' === ', arg);
                    break;
                case 'NaN':
                    typeTest.push(arg, ' !== ', arg);
                    break;
                case 'null':
                    typeTest.push(arg, ' === null');
                    break;
                case 'Infinity':
                    typeTest.push(arg, ' === Number.POSITIVE_INFINITY');
                    break;
                case '-Infinity':
                    typeTest.push(arg, ' === Number.NEGATIVE_INFINITY');
                    break;
                default:
                    typeTest.push('typeof ',arg ,' === ', stringify(typeVal));
                    break;
            }
        }
        else
            throw new ValueError('Unkown type for a value-type: ' + typeOfType);

        return typeTest.join('');
    }

    // helper for compile
    function _makeTypeTests(body, typeTests, ctors, name, type, adress) {
        var i
          , l = type instanceof Array ? type.length : 1
          , typeAdress
          , typeVal
          , test
          ;
        for(i=0;i<l;i++) {
            if(i) body.push(' || ');
            if(type instanceof Array) {
                typeAdress = adress + '[' + i + ']';
                typeVal = type[i];
            }
            else {
                typeAdress = adress;
                typeVal = type;
            }
            test = _makeTypeTest(name, typeAdress, typeVal, ctors);
            // Caching the results of identical tests
            // without _cacheTypeTest this would be just: body.push(test);
            _cacheTypeTest(body, typeTests, test);
        }
    }

    // helper for compile
    function _cacheTypeTest(body, typeTests, typeTest) {
        var typeData = typeTests[typeTest];
        if(!typeData) {
            // Rember the body index (bi) for later replacement
            typeTests[typeTest] = {bi: body.length, varName: null};
            body.push(typeTest);
            return;
        }
        // We had this test once! Prepare to save its result when it's
        // executed the first time.
        if(!typeData.varName) {
            typeData.varName = 'tt' + typeTests.__length;
            typeTests.__length++;

            // Initialize the name in the prelude of the function.
            // We can't  do this inline.
            typeTests.__init.push('var ' + typeData.varName + ';\n');

            // The first occurance of the test is replaced to store
            // its result in a name.
            body[typeData.bi] = typeData.varName + ' = (' + typeTest + ')';

        }
        // The current test tries to use the cached version if it was already
        // executed. Otherwise it falls back to initializie the var itself.
        body.push('(', typeData.varName, ' || (', typeData.varName ,' === false ? false'
                ,' : ',typeData.varName ,' = (',typeTest,')))');
    }

    /**
     * compile the Operator description to native JavaScript.
     */
    _p.compile = function () {
        /*jshint evil:true*/
        var body = ['\n']
          , i, j, k, l, ll, description, methodName
          , names, args, type, typeVarsIndex, ctorIndex, isBoxed, hasGetAPI
          , hasMatchAll = false
          , unboxedNameTokens = false
          , typeTests = {
                __length: 0
              , __init: []
            }
          , ctors = {
                i: 0
              , cache: new Map()
              , init: []
            }
          ;
        body.push(
            '//', this.literal, '\n',
            'var NameToken = this.NameToken\n'
          , '  , methods = this._methods\n'
          , '  ;\n'
        );
        names = _makeLocalBoxedNames(body, this._methods, this.consumes);
        args = names.join(', ');

        // a placeholder
        typeVarsIndex = body.length;
        body.push('');

        for(i=0, l=this._methods.length;i<l; i++) {
            description = this._methods[i];
            methodName = 'm' + i;
            body.push('var ',methodName,' = methods[', i ,'];\n');

            isBoxed = description[0] === '*getAPI*';
            hasGetAPI = isBoxed || description[0] === '*unboxed+getAPI*';

            if(unboxedNameTokens && isBoxed)
                // This is a problem in the design of the operator
                // see the lengthy error message in p._setMethod
                throw new ValueError('Found a *getAPI* after names where already unboxed!');
            else if(!unboxedNameTokens && !isBoxed) {
                //unbox NameTokens
                unboxedNameTokens = true;
                names = _makeLocalUnboxedNames(body, this.consumes, names);
                args = names.join(', ');
            }

            if(typeof description === 'function') {
                // That's it! This is a match-all method, no further
                // evaluation is needed.
                hasMatchAll = true;
                body.push('return ',methodName,'(', args, ');');
                break;
            }

            // a placeholder
            ctorIndex = body.length;
            body.push('');

            body.push('if(true');
            // k: start at 1 if the first item is *getAPI*
            for(j=0, k=hasGetAPI?1:0,ll=this.consumes;j<ll;k++,j++) {
                type = description[k];
                // always true
                if(type === '*anything*') continue;
                body.push(' && (');
                _makeTypeTests(body, typeTests, ctors, names[j], type,  methodName + '[' + k +']');
                body.push(')');
            }
            body.push(
                ')\n    '
              , 'return ' ,methodName,'[', description.length-1, '](', (hasGetAPI ? 'getAPI, ' : ''), args, ');\n'
            );

            // write the constructor references
            body[ctorIndex] = ctors.init.join('');
            ctors.init = [];
        }
        // write the type test result var names
        if(typeTests.__init.length)
            body[typeVarsIndex] = typeTests.__init.join('');

        if(!hasMatchAll)
            // raise if we are still here
            body.push(
                'throw new this.CPSFormulaError('
              , stringify('Can\'t find an implementation for the operator '
                    + stringify(this.literal)
                    + ' that matches the given combination of argument types:\n')
              , '\n    '
              , ' + args.map(function(item){\n    '
              , 'return "\\"" + item + "\\" (typeof: " + (typeof item) + ")";}'
              , ').join(", ")'
              , '\n    );'
            );
        return new Function('getAPI', 'args', body.join(''));
    };

    /**
     * Return the index in this._methods of the first matching operator
     * implementation for the given arguments or -1.
     */
    _p._findMethod = function(getAPI, argsObj) {
        var index=0, length=this._methods.length, j, k, type, value, args;

        for(;index<length; index++) {
            // the routine can request as first argument getAPI
            // this however changes how NameToken is processed
            // without *getAPI* the lookup is made for the operator
            // with *getAPI* the operator itself is in charge to
            // look up the names. The latter can happen anywhere, not
            // just with the getAPI.

            // convert from TokenType (container) to the JavaScript Value
            // equivalents, before running the following methods
            if(this._methods[index][0] !== '*getAPI*') {
                j = 0;
                args = argsObj.unboxedNameTokens;
            }
            else {
                j = 1;
                args = argsObj.original;
            }

            if(typeof this._methods[index] === 'function')
                // match all
                return index;

            for(k = 0;k<args.length;j++, k++) {
                type = this._methods[index][j];
                if(type !== "*anything*" && !isInstance(args[k], type))
                    break;
            }
            if(k === args.length)
                // no element broke the loop, thus all where matches;
                return index;
        }
        return -1;
    };

    /**
     * This method interpretes the the Operator description.
     *
     * However, usually the Operator will compile itself into
     * native JavaScript upon initializaiton and override this
     * implementation
     */
    _p.execute = function(getAPI , _args) {
        var argsObj = new Internal_Arguments(_args, getAPI)
          , index
          , args
          , result
          , operator
          , description
          ;
        index = this._findMethod(getAPI ,argsObj);
        if(index === -1) {
            throw new CPSFormulaError('Can\'t find an implementation for the '
                + 'operator "'+this.literal+'" that matches the given '
                + 'combination of argument types: '
                + argsObj.original.map(function(item){
                        return 'type "' + (typeof item)
                                            + '" string "' + item +'"';})
                    .join(', ')
            );
        }
        description = this._methods[index];
        if(typeof description === 'function') {
            operator = description;
            args = argsObj.unboxedNameTokens;
        }
        else {
            operator = description.slice(-1).pop();
            if(description[0] === '*getAPI*') {
                args = [getAPI];
                Array.prototype.push.apply(args, argsObj.original);
            }
            else if(description[0] === '*unboxed+getAPI*') {
                args = [getAPI];
                Array.prototype.push.apply(args, argsObj.unboxedNameTokens);
            }
            else
                args = argsObj.unboxedNameTokens;
        }
        result = operator.apply(this, args);

        // check for NaN and sorts of??
        return result;
    };

    /**
     * Implementation specific Object to create different versions of the
     * arguments array for further processing. This is in place to make
     * the creation of these different versions a) lazy and  b) cached.
     * This object never leaves the OperatorToken internals, so it doesn't
     * need its own module.
     *
     * The two versions of the arguments array are available at the
     * property getters:
     *   - unboxedNameTokens:
     *   - original
     * within unboxedNameTokens NameTokens are converted to the value
     * returned by getAPI(token.getValue())
     */
    function Internal_Arguments(args, getAPI) {
        this.original = args;
        this._getAPI = getAPI;
        this._unboxedNameTokens = null;
    }

    Object.defineProperty(Internal_Arguments.prototype, 'unboxedNameTokens', {
        get: function() {
            if(!this._unboxedNameTokens)
                this._unboxedNameTokens = this.original.map(_unbox, this);
            return this._unboxedNameTokens;
        }
    });

    function _unbox (token) {
         /*jshint validthis:true */
        if(token instanceof NameToken)
            return this._getAPI.get(token.getValue());
        return token;
    }

    return OperatorToken;
});

define('metapolator/models/CPS/dataTypes/formulae/parsing/NumberToken',[
    'metapolator/errors'
  , './_ValueToken'
], function(
    errors
  , Parent
) {
    

    /**
     * Literal is a string representing a number.
     * Value is the result of applying parseFloat on literal.
     *
     * value should never be NaN. If this ever happens I strongly recommend
     * to improve the reqular expression of CPS/dataTypes/formulae/parsing
     */
    function NumberToken(literal) {
        Parent.call(this, literal, 0, 0);
        this._value = parseFloat(this.literal);
    }

    var _p = NumberToken.prototype = Object.create(Parent.prototype);
    _p.constructor = NumberToken;

    _p.getValue = function() {
        return this._value;
    };

    return NumberToken;
});

define('metapolator/models/CPS/dataTypes/formulae/parsing/StringToken',[
    'metapolator/errors'
  , './_ValueToken'
], function(
    errors
  , Parent
) {
    

    /**
     * Literal is a string representing itself as a string.
     * Value equals literal.
     */
    function StringToken(literal) {
        Parent.call(this, literal, 0, 0);
    }

    var _p = StringToken.prototype = Object.create(Parent.prototype);
    _p.constructor = StringToken;

    _p.getValue = function() {
        return this.literal;
    };

    return StringToken;
});

/*
 * Don't edit this file by hand!
 * This file was generated from a npm-package using gulp. 
 * For more information see gulpfile.js in the project root
 */
define('gonzales/gonzales.cssp.node',['require','exports','module'],function (require, exports, module) {var srcToCSSP = (function() {
var TokenType = {
    StringSQ: 'StringSQ',
    StringDQ: 'StringDQ',
    CommentML: 'CommentML',
    CommentSL: 'CommentSL',

    Newline: 'Newline',
    Space: 'Space',
    Tab: 'Tab',

    ExclamationMark: 'ExclamationMark',         // !
    QuotationMark: 'QuotationMark',             // "
    NumberSign: 'NumberSign',                   // #
    DollarSign: 'DollarSign',                   // $
    PercentSign: 'PercentSign',                 // %
    Ampersand: 'Ampersand',                     // &
    Apostrophe: 'Apostrophe',                   // '
    LeftParenthesis: 'LeftParenthesis',         // (
    RightParenthesis: 'RightParenthesis',       // )
    Asterisk: 'Asterisk',                       // *
    PlusSign: 'PlusSign',                       // +
    Comma: 'Comma',                             // ,
    HyphenMinus: 'HyphenMinus',                 // -
    FullStop: 'FullStop',                       // .
    Solidus: 'Solidus',                         // /
    Colon: 'Colon',                             // :
    Semicolon: 'Semicolon',                     // ;
    LessThanSign: 'LessThanSign',               // <
    EqualsSign: 'EqualsSign',                   // =
    GreaterThanSign: 'GreaterThanSign',         // >
    QuestionMark: 'QuestionMark',               // ?
    CommercialAt: 'CommercialAt',               // @
    LeftSquareBracket: 'LeftSquareBracket',     // [
    ReverseSolidus: 'ReverseSolidus',           // \
    RightSquareBracket: 'RightSquareBracket',   // ]
    CircumflexAccent: 'CircumflexAccent',       // ^
    LowLine: 'LowLine',                         // _
    LeftCurlyBracket: 'LeftCurlyBracket',       // {
    VerticalLine: 'VerticalLine',               // |
    RightCurlyBracket: 'RightCurlyBracket',     // }
    Tilde: 'Tilde',                             // ~

    Identifier: 'Identifier',
    DecimalNumber: 'DecimalNumber'
};

var getTokens = (function() {

    var Punctuation,
        urlMode = false,
        blockMode = 0;

    Punctuation = {
        ' ': TokenType.Space,
        '\n': TokenType.Newline,
        '\r': TokenType.Newline,
        '\t': TokenType.Tab,
        '!': TokenType.ExclamationMark,
        '"': TokenType.QuotationMark,
        '#': TokenType.NumberSign,
        '$': TokenType.DollarSign,
        '%': TokenType.PercentSign,
        '&': TokenType.Ampersand,
        '\'': TokenType.Apostrophe,
        '(': TokenType.LeftParenthesis,
        ')': TokenType.RightParenthesis,
        '*': TokenType.Asterisk,
        '+': TokenType.PlusSign,
        ',': TokenType.Comma,
        '-': TokenType.HyphenMinus,
        '.': TokenType.FullStop,
        '/': TokenType.Solidus,
        ':': TokenType.Colon,
        ';': TokenType.Semicolon,
        '<': TokenType.LessThanSign,
        '=': TokenType.EqualsSign,
        '>': TokenType.GreaterThanSign,
        '?': TokenType.QuestionMark,
        '@': TokenType.CommercialAt,
        '[': TokenType.LeftSquareBracket,
    //        '\\': TokenType.ReverseSolidus,
        ']': TokenType.RightSquareBracket,
        '^': TokenType.CircumflexAccent,
        '_': TokenType.LowLine,
        '{': TokenType.LeftCurlyBracket,
        '|': TokenType.VerticalLine,
        '}': TokenType.RightCurlyBracket,
        '~': TokenType.Tilde
    };

    function isDecimalDigit(c) {
        return '0123456789'.indexOf(c) >= 0;
    }

    function throwError(message) {
        throw message;
    }

    var buffer = '',
        tokens = [],
        pos,
        tn = 0,
        ln = 1;

    function _getTokens(s) {
        if (!s) return [];

        tokens = [];
        // hotfix line numbers
        tn = 0;
        ln = 1;

        var c, cn;

        for (pos = 0; pos < s.length; pos++) {
            c = s.charAt(pos);
            cn = s.charAt(pos + 1);

            if (c === '/' && cn === '*') {
                parseMLComment(s);
            } else if (!urlMode && c === '/' && cn === '/') {
                if (blockMode > 0) parseIdentifier(s); 
                else parseSLComment(s);
            } else if (c === '"' || c === "'") {
                parseString(s, c);
            } else if (c === ' ') {
                parseSpaces(s)
            } else if (c in Punctuation) {
                pushToken(Punctuation[c], c);
                if (c === '\n' || c === '\r') ln++;
                if (c === ')') urlMode = false;
                if (c === '{') blockMode++;
                if (c === '}') blockMode--;
            } else if (isDecimalDigit(c)) {
                parseDecimalNumber(s);
            } else {
                parseIdentifier(s);
            }
        }

        mark();

        return tokens;
    }

    function pushToken(type, value) {
        tokens.push({ tn: tn++, ln: ln, type: type, value: value });
    }

    function parseSpaces(s) {
        var start = pos;

        for (; pos < s.length; pos++) {
            if (s.charAt(pos) !== ' ') break;
        }

        pushToken(TokenType.Space, s.substring(start, pos));
        pos--;
    }

    function parseMLComment(s) {
        var start = pos;

        for (pos = pos + 2; pos < s.length; pos++) {
            if (s.charAt(pos) === '*') {
                if (s.charAt(pos + 1) === '/') {
                    pos++;
                    break;
                }
            }
        }

        pushToken(TokenType.CommentML, s.substring(start, pos + 1));
    }

    function parseSLComment(s) {
        var start = pos;

        for (pos = pos + 2; pos < s.length; pos++) {
            if (s.charAt(pos) === '\n' || s.charAt(pos) === '\r') {
                pos++;
                break;
            }
        }

        pushToken(TokenType.CommentSL, s.substring(start, pos));
        pos--;
    }

    function parseString(s, q) {
        var start = pos;

        for (pos = pos + 1; pos < s.length; pos++) {
            if (s.charAt(pos) === '\\') pos++;
            else if (s.charAt(pos) === q) break;
        }

        pushToken(q === '"' ? TokenType.StringDQ : TokenType.StringSQ, s.substring(start, pos + 1));
    }

    function parseDecimalNumber(s) {
        var start = pos;

        for (; pos < s.length; pos++) {
            if (!isDecimalDigit(s.charAt(pos))) break;
        }

        pushToken(TokenType.DecimalNumber, s.substring(start, pos));
        pos--;
    }

    function parseIdentifier(s) {
        var start = pos;

        while (s.charAt(pos) === '/') pos++;

        for (; pos < s.length; pos++) {
            if (s.charAt(pos) === '\\') pos++;
            else if (s.charAt(pos) in Punctuation) break;
        }

        var ident = s.substring(start, pos);

        urlMode = urlMode || ident === 'url';

        pushToken(TokenType.Identifier, ident);
        pos--;
    }

    // ====================================
    // second run
    // ====================================

    function mark() {
        var ps = [], // Parenthesis
            sbs = [], // SquareBracket
            cbs = [], // CurlyBracket
            t;

        for (var i = 0; i < tokens.length; i++) {
            t = tokens[i];
            switch(t.type) {
                case TokenType.LeftParenthesis:
                    ps.push(i);
                    break;
                case TokenType.RightParenthesis:
                    if (ps.length) {
                        t.left = ps.pop();
                        tokens[t.left].right = i;
                    }
                    break;
                case TokenType.LeftSquareBracket:
                    sbs.push(i);
                    break;
                case TokenType.RightSquareBracket:
                    if (sbs.length) {
                        t.left = sbs.pop();
                        tokens[t.left].right = i;
                    }
                    break;
                case TokenType.LeftCurlyBracket:
                    cbs.push(i);
                    break;
                case TokenType.RightCurlyBracket:
                    if (cbs.length) {
                        t.left = cbs.pop();
                        tokens[t.left].right = i;
                    }
                    break;
            }
        }
    }

    return function(s) {
        return _getTokens(s);
    };

}());
// version: 1.0.0

var getCSSPAST = (function() {

    var tokens,
        pos,
        failLN = 0,
        currentBlockLN = 0,
        needInfo = false;

    var CSSPNodeType,
        CSSLevel,
        CSSPRules;

    CSSPNodeType = {
        IdentType: 'ident',
        AtkeywordType: 'atkeyword',
        StringType: 'string',
        ShashType: 'shash',
        VhashType: 'vhash',
        NumberType: 'number',
        PercentageType: 'percentage',
        DimensionType: 'dimension',
        CdoType: 'cdo',
        CdcType: 'cdc',
        DecldelimType: 'decldelim',
        SType: 's',
        AttrselectorType: 'attrselector',
        AttribType: 'attrib',
        NthType: 'nth',
        NthselectorType: 'nthselector',
        NamespaceType: 'namespace',
        ClazzType: 'clazz',
        PseudoeType: 'pseudoe',
        PseudocType: 'pseudoc',
        DelimType: 'delim',
        StylesheetType: 'stylesheet',
        AtrulebType: 'atruleb',
        AtrulesType: 'atrules',
        AtrulerqType: 'atrulerq',
        AtrulersType: 'atrulers',
        AtrulerType: 'atruler',
        BlockType: 'block',
        RulesetType: 'ruleset',
        CombinatorType: 'combinator',
        SimpleselectorType: 'simpleselector',
        SelectorType: 'selector',
        DeclarationType: 'declaration',
        PropertyType: 'property',
        ImportantType: 'important',
        UnaryType: 'unary',
        OperatorType: 'operator',
        BracesType: 'braces',
        ValueType: 'value',
        ProgidType: 'progid',
        FiltervType: 'filterv',
        FilterType: 'filter',
        CommentType: 'comment',
        UriType: 'uri',
        RawType: 'raw',
        FunctionBodyType: 'functionBody',
        FunktionType: 'funktion',
        FunctionExpressionType: 'functionExpression',
        UnknownType: 'unknown'
    };

    CSSPRules = {
        'ident': function() { if (checkIdent(pos)) return getIdent() },
        'atkeyword': function() { if (checkAtkeyword(pos)) return getAtkeyword() },
        'string': function() { if (checkString(pos)) return getString() },
        'shash': function() { if (checkShash(pos)) return getShash() },
        'vhash': function() { if (checkVhash(pos)) return getVhash() },
        'number': function() { if (checkNumber(pos)) return getNumber() },
        'percentage': function() { if (checkPercentage(pos)) return getPercentage() },
        'dimension': function() { if (checkDimension(pos)) return getDimension() },
//        'cdo': function() { if (checkCDO()) return getCDO() },
//        'cdc': function() { if (checkCDC()) return getCDC() },
        'decldelim': function() { if (checkDecldelim(pos)) return getDecldelim() },
        's': function() { if (checkS(pos)) return getS() },
        'attrselector': function() { if (checkAttrselector(pos)) return getAttrselector() },
        'attrib': function() { if (checkAttrib(pos)) return getAttrib() },
        'nth': function() { if (checkNth(pos)) return getNth() },
        'nthselector': function() { if (checkNthselector(pos)) return getNthselector() },
        'namespace': function() { if (checkNamespace(pos)) return getNamespace() },
        'clazz': function() { if (checkClazz(pos)) return getClazz() },
        'pseudoe': function() { if (checkPseudoe(pos)) return getPseudoe() },
        'pseudoc': function() { if (checkPseudoc(pos)) return getPseudoc() },
        'delim': function() { if (checkDelim(pos)) return getDelim() },
        'stylesheet': function() { if (checkStylesheet(pos)) return getStylesheet() },
        'atruleb': function() { if (checkAtruleb(pos)) return getAtruleb() },
        'atrules': function() { if (checkAtrules(pos)) return getAtrules() },
        'atrulerq': function() { if (checkAtrulerq(pos)) return getAtrulerq() },
        'atrulers': function() { if (checkAtrulers(pos)) return getAtrulers() },
        'atruler': function() { if (checkAtruler(pos)) return getAtruler() },
        'block': function() { if (checkBlock(pos)) return getBlock() },
        'ruleset': function() { if (checkRuleset(pos)) return getRuleset() },
        'combinator': function() { if (checkCombinator(pos)) return getCombinator() },
        'simpleselector': function() { if (checkSimpleselector(pos)) return getSimpleSelector() },
        'selector': function() { if (checkSelector(pos)) return getSelector() },
        'declaration': function() { if (checkDeclaration(pos)) return getDeclaration() },
        'property': function() { if (checkProperty(pos)) return getProperty() },
        'important': function() { if (checkImportant(pos)) return getImportant() },
        'unary': function() { if (checkUnary(pos)) return getUnary() },
        'operator': function() { if (checkOperator(pos)) return getOperator() },
        'braces': function() { if (checkBraces(pos)) return getBraces() },
        'value': function() { if (checkValue(pos)) return getValue() },
        'progid': function() { if (checkProgid(pos)) return getProgid() },
        'filterv': function() { if (checkFilterv(pos)) return getFilterv() },
        'filter': function() { if (checkFilter(pos)) return getFilter() },
        'comment': function() { if (checkComment(pos)) return getComment() },
        'uri': function() { if (checkUri(pos)) return getUri() },
        'raw': function() { if (checkRaw(pos)) return getRaw() },
        'funktion': function() { if (checkFunktion(pos)) return getFunktion() },
        'functionExpression': function() { if (checkFunctionExpression(pos)) return getFunctionExpression() },
        'unknown': function() { if (checkUnknown(pos)) return getUnknown() }
    };

    function fail(token) {
        if (token && token.ln > failLN) failLN = token.ln;
    }

    function throwError() {
        throw new Error('Please check the validity of the CSS block starting from the line #' + currentBlockLN);
    }

    function _getAST(_tokens, rule, _needInfo) {
        tokens = _tokens;
        needInfo = _needInfo;
        pos = 0;

        markSC();

        return rule ? CSSPRules[rule]() : CSSPRules['stylesheet']();
    }

//any = braces | string | percentage | dimension | number | uri | functionExpression | funktion | ident | unary
    function checkAny(_i) {
        return checkBraces(_i) ||
               checkString(_i) ||
               checkPercentage(_i) ||
               checkDimension(_i) ||
               checkNumber(_i) ||
               checkUri(_i) ||
               checkFunctionExpression(_i) ||
               checkFunktion(_i) ||
               checkIdent(_i) ||
               checkUnary(_i);
    }

    function getAny() {
        if (checkBraces(pos)) return getBraces();
        else if (checkString(pos)) return getString();
        else if (checkPercentage(pos)) return getPercentage();
        else if (checkDimension(pos)) return getDimension();
        else if (checkNumber(pos)) return getNumber();
        else if (checkUri(pos)) return getUri();
        else if (checkFunctionExpression(pos)) return getFunctionExpression();
        else if (checkFunktion(pos)) return getFunktion();
        else if (checkIdent(pos)) return getIdent();
        else if (checkUnary(pos)) return getUnary();
    }

//atkeyword = '@' ident:x -> [#atkeyword, x]
    function checkAtkeyword(_i) {
        var l;

        if (tokens[_i++].type !== TokenType.CommercialAt) return fail(tokens[_i - 1]);

        if (l = checkIdent(_i)) return l + 1;

        return fail(tokens[_i]);
    }

    function getAtkeyword() {
        var startPos = pos;

        pos++;

        return needInfo?
            [{ ln: tokens[startPos].ln }, CSSPNodeType.AtkeywordType, getIdent()]:
            [CSSPNodeType.AtkeywordType, getIdent()];
    }

//attrib = '[' sc*:s0 ident:x sc*:s1 attrselector:a sc*:s2 (ident | string):y sc*:s3 ']' -> this.concat([#attrib], s0, [x], s1, [a], s2, [y], s3)
//       | '[' sc*:s0 ident:x sc*:s1 ']' -> this.concat([#attrib], s0, [x], s1),
    function checkAttrib(_i) {
        if (tokens[_i].type !== TokenType.LeftSquareBracket) return fail(tokens[_i]);

        if (!tokens[_i].right) return fail(tokens[_i]);

        return tokens[_i].right - _i + 1;
    }

    function checkAttrib1(_i) {
        var start = _i;

        _i++;

        var l = checkSC(_i); // s0

        if (l) _i += l;

        if (l = checkIdent(_i)) _i += l; // x
        else return fail(tokens[_i]);

        if (l = checkSC(_i)) _i += l; // s1

        if (l = checkAttrselector(_i)) _i += l; // a
        else return fail(tokens[_i]);

        if (l = checkSC(_i)) _i += l; // s2

        if ((l = checkIdent(_i)) || (l = checkString(_i))) _i += l; // y
        else return fail(tokens[_i]);

        if (l = checkSC(_i)) _i += l; // s3

        if (tokens[_i].type === TokenType.RightSquareBracket) return _i - start;

        return fail(tokens[_i]);
    }

    function getAttrib1() {
        var startPos = pos;

        pos++;

        var a = (needInfo? [{ ln: tokens[startPos].ln }, CSSPNodeType.AttribType] : [CSSPNodeType.AttribType])
                .concat(getSC())
                .concat([getIdent()])
                .concat(getSC())
                .concat([getAttrselector()])
                .concat(getSC())
                .concat([checkString(pos)? getString() : getIdent()])
                .concat(getSC());

        pos++;

        return a;
    }

    function checkAttrib2(_i) {
        var start = _i;

        _i++;

        var l = checkSC(_i);

        if (l) _i += l;

        if (l = checkIdent(_i)) _i += l;

        if (l = checkSC(_i)) _i += l;

        if (tokens[_i].type === TokenType.RightSquareBracket) return _i - start;

        return fail(tokens[_i]);
    }

    function getAttrib2() {
        var startPos = pos;

        pos++;

        var a = (needInfo? [{ ln: tokens[startPos].ln }, CSSPNodeType.AttribType] : [CSSPNodeType.AttribType])
                .concat(getSC())
                .concat([getIdent()])
                .concat(getSC());

        pos++;

        return a;
    }

    function getAttrib() {
        if (checkAttrib1(pos)) return getAttrib1(); 
        if (checkAttrib2(pos)) return getAttrib2(); 
    }

//attrselector = (seq('=') | seq('~=') | seq('^=') | seq('$=') | seq('*=') | seq('|=')):x -> [#attrselector, x]
    function checkAttrselector(_i) {
        if (tokens[_i].type === TokenType.EqualsSign) return 1;
        if (tokens[_i].type === TokenType.VerticalLine && (!tokens[_i + 1] || tokens[_i + 1].type !== TokenType.EqualsSign)) return 1;

        if (!tokens[_i + 1] || tokens[_i + 1].type !== TokenType.EqualsSign) return fail(tokens[_i]);

        switch(tokens[_i].type) {
            case TokenType.Tilde:
            case TokenType.CircumflexAccent:
            case TokenType.DollarSign:
            case TokenType.Asterisk:
            case TokenType.VerticalLine:
                return 2;
        }

        return fail(tokens[_i]);
    }

    function getAttrselector() {
        var startPos = pos,
            s = tokens[pos++].value;

        if (tokens[pos] && tokens[pos].type === TokenType.EqualsSign) s += tokens[pos++].value;

        return needInfo?
                [{ ln: tokens[startPos].ln }, CSSPNodeType.AttrselectorType, s] :
                [CSSPNodeType.AttrselectorType, s];
    }

//atrule = atruler | atruleb | atrules
    function checkAtrule(_i) {
        var start = _i,
            l;

        if (tokens[start].atrule_l !== undefined) return tokens[start].atrule_l;

        if (l = checkAtruler(_i)) tokens[_i].atrule_type = 1;
        else if (l = checkAtruleb(_i)) tokens[_i].atrule_type = 2;
        else if (l = checkAtrules(_i)) tokens[_i].atrule_type = 3;
        else return fail(tokens[start]);

        tokens[start].atrule_l = l;

        return l;
    }

    function getAtrule() {
        switch (tokens[pos].atrule_type) {
            case 1: return getAtruler();
            case 2: return getAtruleb();
            case 3: return getAtrules();
        }
    }

//atruleb = atkeyword:ak tset*:ap block:b -> this.concat([#atruleb, ak], ap, [b])
    function checkAtruleb(_i) {
        var start = _i,
            l;

        if (l = checkAtkeyword(_i)) _i += l;
        else return fail(tokens[_i]);

        if (l = checkTsets(_i)) _i += l;

        if (l = checkBlock(_i)) _i += l;
        else return fail(tokens[_i]);

        return _i - start;
    }

    function getAtruleb() {
        return (needInfo?
                    [{ ln: tokens[pos].ln }, CSSPNodeType.AtrulebType, getAtkeyword()] :
                    [CSSPNodeType.AtrulebType, getAtkeyword()])
                        .concat(getTsets())
                        .concat([getBlock()]);
    }

//atruler = atkeyword:ak atrulerq:x '{' atrulers:y '}' -> [#atruler, ak, x, y]
    function checkAtruler(_i) {
        var start = _i,
            l;

        if (l = checkAtkeyword(_i)) _i += l;
        else return fail(tokens[_i]);

        if (l = checkAtrulerq(_i)) _i += l;

        if (_i < tokens.length && tokens[_i].type === TokenType.LeftCurlyBracket) _i++;
        else return fail(tokens[_i]);

        if (l = checkAtrulers(_i)) _i += l;

        if (_i < tokens.length && tokens[_i].type === TokenType.RightCurlyBracket) _i++;
        else return fail(tokens[_i]);

        return _i - start;
    }

    function getAtruler() {
        var atruler = needInfo?
                        [{ ln: tokens[pos].ln }, CSSPNodeType.AtrulerType, getAtkeyword(), getAtrulerq()] :
                        [CSSPNodeType.AtrulerType, getAtkeyword(), getAtrulerq()];

        pos++;

        atruler.push(getAtrulers());

        pos++;

        return atruler;
    }

//atrulerq = tset*:ap -> [#atrulerq].concat(ap)
    function checkAtrulerq(_i) {
        return checkTsets(_i);
    }

    function getAtrulerq() {
        return (needInfo? [{ ln: tokens[pos].ln }, CSSPNodeType.AtrulerqType] : [CSSPNodeType.AtrulerqType]).concat(getTsets());
    }

//atrulers = sc*:s0 ruleset*:r sc*:s1 -> this.concat([#atrulers], s0, r, s1)
    function checkAtrulers(_i) {
        var start = _i,
            l;

        if (l = checkSC(_i)) _i += l;

        while ((l = checkRuleset(_i)) || (l = checkAtrule(_i)) || (l = checkSC(_i))) {
            _i += l;
        }

        tokens[_i].atrulers_end = 1;

        if (l = checkSC(_i)) _i += l;

        return _i - start;
    }

    function getAtrulers() {
        var atrulers = (needInfo? [{ ln: tokens[pos].ln }, CSSPNodeType.AtrulersType] : [CSSPNodeType.AtrulersType]).concat(getSC()),
            x;

        while (!tokens[pos].atrulers_end) {
            if (checkSC(pos)) {
                atrulers = atrulers.concat(getSC());
            } else if (checkRuleset(pos)) {
                atrulers.push(getRuleset());
            } else {
                atrulers.push(getAtrule());
            }
        }

        return atrulers.concat(getSC());
    }

//atrules = atkeyword:ak tset*:ap ';' -> this.concat([#atrules, ak], ap)
    function checkAtrules(_i) {
        var start = _i,
            l;

        if (l = checkAtkeyword(_i)) _i += l;
        else return fail(tokens[_i]);

        if (l = checkTsets(_i)) _i += l;

        if (_i >= tokens.length) return _i - start;

        if (tokens[_i].type === TokenType.Semicolon) _i++;
        else return fail(tokens[_i]);

        return _i - start;
    }

    function getAtrules() {
        var atrules = (needInfo? [{ ln: tokens[pos].ln }, CSSPNodeType.AtrulesType, getAtkeyword()] : [CSSPNodeType.AtrulesType, getAtkeyword()]).concat(getTsets());

        pos++;

        return atrules;
    }

//block = '{' blockdecl*:x '}' -> this.concatContent([#block], x)
    function checkBlock(_i) {
        if (_i < tokens.length && tokens[_i].type === TokenType.LeftCurlyBracket) return tokens[_i].right - _i + 1;

        return fail(tokens[_i]);
    }

    function getBlock() {
        var block = needInfo? [{ ln: tokens[pos].ln }, CSSPNodeType.BlockType] : [CSSPNodeType.BlockType],
            end = tokens[pos].right;

        pos++;

        while (pos < end) {
            if (checkBlockdecl(pos)) block = block.concat(getBlockdecl());
            else throwError();
        }

        pos = end + 1;

        return block;
    }

//blockdecl = sc*:s0 (filter | declaration):x decldelim:y sc*:s1 -> this.concat(s0, [x], [y], s1)
//          | sc*:s0 (filter | declaration):x sc*:s1 -> this.concat(s0, [x], s1)
//          | sc*:s0 decldelim:x sc*:s1 -> this.concat(s0, [x], s1)
//          | sc+:s0 -> s0

    function checkBlockdecl(_i) {
        var l;

        if (l = _checkBlockdecl0(_i)) tokens[_i].bd_type = 1;
        else if (l = _checkBlockdecl1(_i)) tokens[_i].bd_type = 2;
        else if (l = _checkBlockdecl2(_i)) tokens[_i].bd_type = 3;
        else if (l = _checkBlockdecl3(_i)) tokens[_i].bd_type = 4;
        else return fail(tokens[_i]);

        return l;
    }

    function getBlockdecl() {
        switch (tokens[pos].bd_type) {
            case 1: return _getBlockdecl0();
            case 2: return _getBlockdecl1();
            case 3: return _getBlockdecl2();
            case 4: return _getBlockdecl3();
        }
    }

    //sc*:s0 (filter | declaration):x decldelim:y sc*:s1 -> this.concat(s0, [x], [y], s1)
    function _checkBlockdecl0(_i) {
        var start = _i,
            l;

        if (l = checkSC(_i)) _i += l;

        if (l = checkFilter(_i)) {
            tokens[_i].bd_filter = 1;
            _i += l;
        } else if (l = checkDeclaration(_i)) {
            tokens[_i].bd_decl = 1;
            _i += l;
        } else return fail(tokens[_i]);

        if (_i < tokens.length && (l = checkDecldelim(_i))) _i += l;
        else return fail(tokens[_i]);

        if (l = checkSC(_i)) _i += l;

        return _i - start;
    }

    function _getBlockdecl0() {
        return getSC()
                .concat([tokens[pos].bd_filter? getFilter() : getDeclaration()])
                .concat([getDecldelim()])
                .concat(getSC());
    }

    //sc*:s0 (filter | declaration):x sc*:s1 -> this.concat(s0, [x], s1)
    function _checkBlockdecl1(_i) {
        var start = _i,
            l;

        if (l = checkSC(_i)) _i += l;

        if (l = checkFilter(_i)) {
            tokens[_i].bd_filter = 1;
            _i += l;
        } else if (l = checkDeclaration(_i)) {
            tokens[_i].bd_decl = 1;
            _i += l;
        } else return fail(tokens[_i]);

        if (l = checkSC(_i)) _i += l;

        return _i - start;
    }

    function _getBlockdecl1() {
        return getSC()
                .concat([tokens[pos].bd_filter? getFilter() : getDeclaration()])
                .concat(getSC());
    }

    //sc*:s0 decldelim:x sc*:s1 -> this.concat(s0, [x], s1)
    function _checkBlockdecl2(_i) {
        var start = _i,
            l;

        if (l = checkSC(_i)) _i += l;

        if (l = checkDecldelim(_i)) _i += l;
        else return fail(tokens[_i]);

        if (l = checkSC(_i)) _i += l;

        return _i - start;
    }

    function _getBlockdecl2() {
        return getSC()
                 .concat([getDecldelim()])
                 .concat(getSC());
    }

    //sc+:s0 -> s0
    function _checkBlockdecl3(_i) {
        return checkSC(_i);
    }

    function _getBlockdecl3() {
        return getSC();
    }

//braces = '(' tset*:x ')' -> this.concat([#braces, '(', ')'], x)
//       | '[' tset*:x ']' -> this.concat([#braces, '[', ']'], x)
    function checkBraces(_i) {
        if (_i >= tokens.length ||
            (tokens[_i].type !== TokenType.LeftParenthesis &&
             tokens[_i].type !== TokenType.LeftSquareBracket)
            ) return fail(tokens[_i]);

        return tokens[_i].right - _i + 1;
    }

    function getBraces() {
        var startPos = pos,
            left = pos,
            right = tokens[pos].right;

        pos++;

        var tsets = getTsets();

        pos++;

        return needInfo?
                [{ ln: tokens[startPos].ln }, CSSPNodeType.BracesType, tokens[left].value, tokens[right].value].concat(tsets) :
                [CSSPNodeType.BracesType, tokens[left].value, tokens[right].value].concat(tsets);
    }

    function checkCDC(_i) {}

    function checkCDO(_i) {}

    // node: Clazz
    function checkClazz(_i) {
        var l;

        if (tokens[_i].clazz_l) return tokens[_i].clazz_l;

        if (tokens[_i].type === TokenType.FullStop) {
            if (l = checkIdent(_i + 1)) {
                tokens[_i].clazz_l = l + 1;
                return l + 1;
            }
        }

        return fail(tokens[_i]);
    }

    function getClazz() {
        var startPos = pos;

        pos++;

        return needInfo?
                [{ ln: tokens[startPos].ln }, CSSPNodeType.ClazzType, getIdent()] :
                [CSSPNodeType.ClazzType, getIdent()];
    }

    // node: Combinator
    function checkCombinator(_i) {
        if (tokens[_i].type === TokenType.PlusSign ||
            tokens[_i].type === TokenType.GreaterThanSign ||
            tokens[_i].type === TokenType.Tilde) return 1;

        return fail(tokens[_i]);
    }

    function getCombinator() {
        return needInfo?
                [{ ln: tokens[pos].ln }, CSSPNodeType.CombinatorType, tokens[pos++].value] :
                [CSSPNodeType.CombinatorType, tokens[pos++].value];
    }

    // node: Comment
    function checkComment(_i) {
        if (tokens[_i].type === TokenType.CommentML) return 1;

        return fail(tokens[_i]);
    }

    function getComment() {
        var startPos = pos,
            s = tokens[pos].value.substring(2),
            l = s.length;

        if (s.charAt(l - 2) === '*' && s.charAt(l - 1) === '/') s = s.substring(0, l - 2);

        pos++;

        return needInfo?
                [{ ln: tokens[startPos].ln }, CSSPNodeType.CommentType, s] :
                [CSSPNodeType.CommentType, s];
    }

    // declaration = property:x ':' value:y -> [#declaration, x, y]
    function checkDeclaration(_i) {
        var start = _i,
            l;

        if (l = checkProperty(_i)) _i += l;
        else return fail(tokens[_i]);

        if (_i < tokens.length && tokens[_i].type === TokenType.Colon) _i++;
        else return fail(tokens[_i]);

        if (l = checkValue(_i)) _i += l;
        else return fail(tokens[_i]);

        return _i - start;
    }

    function getDeclaration() {
        var declaration = needInfo?
                [{ ln: tokens[pos].ln }, CSSPNodeType.DeclarationType, getProperty()] :
                [CSSPNodeType.DeclarationType, getProperty()];

        pos++;

        declaration.push(getValue());

        return declaration;
    }

    // node: Decldelim
    function checkDecldelim(_i) {
        if (_i < tokens.length && tokens[_i].type === TokenType.Semicolon) return 1;

        return fail(tokens[_i]);
    }

    function getDecldelim() {
        var startPos = pos;

        pos++;

        return needInfo?
                [{ ln: tokens[startPos].ln }, CSSPNodeType.DecldelimType] :
                [CSSPNodeType.DecldelimType];
    }

    // node: Delim
    function checkDelim(_i) {
        if (_i < tokens.length && tokens[_i].type === TokenType.Comma) return 1;

        if (_i >= tokens.length) return fail(tokens[tokens.length - 1]);

        return fail(tokens[_i]);
    }

    function getDelim() {
        var startPos = pos;

        pos++;

        return needInfo?
                [{ ln: tokens[startPos].ln }, CSSPNodeType.DelimType] :
                [CSSPNodeType.DelimType];
    }

    // node: Dimension
    function checkDimension(_i) {
        var ln = checkNumber(_i),
            li;

        if (!ln || (ln && _i + ln >= tokens.length)) return fail(tokens[_i]);

        if (li = checkNmName2(_i + ln)) return ln + li;

        return fail(tokens[_i]);
    }

    function getDimension() {
        var startPos = pos,
            n = getNumber(),
            dimension = needInfo ?
                [{ ln: tokens[pos].ln }, CSSPNodeType.IdentType, getNmName2()] :
                [CSSPNodeType.IdentType, getNmName2()];

        return needInfo?
                [{ ln: tokens[startPos].ln }, CSSPNodeType.DimensionType, n, dimension] :
                [CSSPNodeType.DimensionType, n, dimension];
    }

//filter = filterp:x ':' filterv:y -> [#filter, x, y]
    function checkFilter(_i) {
        var start = _i,
            l;

        if (l = checkFilterp(_i)) _i += l;
        else return fail(tokens[_i]);

        if (tokens[_i].type === TokenType.Colon) _i++;
        else return fail(tokens[_i]);

        if (l = checkFilterv(_i)) _i += l;
        else return fail(tokens[_i]);

        return _i - start;
    }

    function getFilter() {
        var filter = needInfo?
                [{ ln: tokens[pos].ln }, CSSPNodeType.FilterType, getFilterp()] :
                [CSSPNodeType.FilterType, getFilterp()];

        pos++;

        filter.push(getFilterv());

        return filter;
    }

//filterp = (seq('-filter') | seq('_filter') | seq('*filter') | seq('-ms-filter') | seq('filter')):t sc*:s0 -> this.concat([#property, [#ident, t]], s0)
    function checkFilterp(_i) {
        var start = _i,
            l,
            x;

        if (_i < tokens.length) {
            if (tokens[_i].value === 'filter') l = 1;
            else {
                x = joinValues2(_i, 2);

                if (x === '-filter' || x === '_filter' || x === '*filter') l = 2;
                else {
                    x = joinValues2(_i, 4);

                    if (x === '-ms-filter') l = 4;
                    else return fail(tokens[_i]);
                }
            }

            tokens[start].filterp_l = l;

            _i += l;

            if (checkSC(_i)) _i += l;

            return _i - start;
        }

        return fail(tokens[_i]);
    }

    function getFilterp() {
        var startPos = pos,
            x = joinValues2(pos, tokens[pos].filterp_l),
            ident = needInfo? [{ ln: tokens[startPos].ln }, CSSPNodeType.IdentType, x] : [CSSPNodeType.IdentType, x];

        pos += tokens[pos].filterp_l;

        return (needInfo? [{ ln: tokens[startPos].ln }, CSSPNodeType.PropertyType, ident] : [CSSPNodeType.PropertyType, ident])
                    .concat(getSC());

    }

//filterv = progid+:x -> [#filterv].concat(x)
    function checkFilterv(_i) {
        var start = _i,
            l;

        if (l = checkProgid(_i)) _i += l;
        else return fail(tokens[_i]);

        while (l = checkProgid(_i)) {
            _i += l;
        }

        tokens[start].last_progid = _i;

        if (_i < tokens.length && (l = checkSC(_i))) _i += l;

        if (_i < tokens.length && (l = checkImportant(_i))) _i += l;

        return _i - start;
    }

    function getFilterv() {
        var filterv = needInfo? [{ ln: tokens[pos].ln }, CSSPNodeType.FiltervType] : [CSSPNodeType.FiltervType],
            last_progid = tokens[pos].last_progid;

        while (pos < last_progid) {
            filterv.push(getProgid());
        }

        filterv = filterv.concat(checkSC(pos) ? getSC() : []);

        if (pos < tokens.length && checkImportant(pos)) filterv.push(getImportant());

        return filterv;
    }

//functionExpression = ``expression('' functionExpressionBody*:x ')' -> [#functionExpression, x.join('')],
    function checkFunctionExpression(_i) {
        var start = _i;

        if (!tokens[_i] || tokens[_i++].value !== 'expression') return fail(tokens[_i - 1]);

        if (!tokens[_i] || tokens[_i].type !== TokenType.LeftParenthesis) return fail(tokens[_i]);

        return tokens[_i].right - start + 1;
    }

    function getFunctionExpression() {
        var startPos = pos;

        pos++;

        var e = joinValues(pos + 1, tokens[pos].right - 1);

        pos = tokens[pos].right + 1;

        return needInfo?
                [{ ln: tokens[startPos].ln }, CSSPNodeType.FunctionExpressionType, e] :
                [CSSPNodeType.FunctionExpressionType, e];
    }

//funktion = ident:x '(' functionBody:y ')' -> [#funktion, x, y]
    function checkFunktion(_i) {
        var start = _i,
            l = checkIdent(_i);

        if (!l) return fail(tokens[_i]);

        _i += l;

        if (_i >= tokens.length || tokens[_i].type !== TokenType.LeftParenthesis) return fail(tokens[_i - 1]);

        return tokens[_i].right - start + 1;
    }

    function getFunktion() {
        var startPos = pos,
            ident = getIdent();

        pos++;

        var body = ident[needInfo? 2 : 1] !== 'not'?
            getFunctionBody() :
            getNotFunctionBody(); // ok, here we have CSS3 initial draft: http://dev.w3.org/csswg/selectors3/#negation

        return needInfo?
                [{ ln: tokens[startPos].ln }, CSSPNodeType.FunktionType, ident, body] :
                [CSSPNodeType.FunktionType, ident, body];
    }

    function getFunctionBody() {
        var startPos = pos,
            body = [],
            x;

        while (tokens[pos].type !== TokenType.RightParenthesis) {
            if (checkTset(pos)) {
                x = getTset();
                if ((needInfo && typeof x[1] === 'string') || typeof x[0] === 'string') body.push(x);
                else body = body.concat(x);
            } else if (checkClazz(pos)) {
                body.push(getClazz());
            } else {
                throwError();
            }
        }

        pos++;

        return (needInfo?
                    [{ ln: tokens[startPos].ln }, CSSPNodeType.FunctionBodyType] :
                    [CSSPNodeType.FunctionBodyType]
                ).concat(body);
    }

    function getNotFunctionBody() {
        var startPos = pos,
            body = [],
            x;

        while (tokens[pos].type !== TokenType.RightParenthesis) {
            if (checkSimpleselector(pos)) {
                body.push(getSimpleSelector());
            } else {
                throwError();
            }
        }

        pos++;

        return (needInfo?
                    [{ ln: tokens[startPos].ln }, CSSPNodeType.FunctionBodyType] :
                    [CSSPNodeType.FunctionBodyType]
                ).concat(body);
    }

    // node: Ident
    function checkIdent(_i) {
        if (_i >= tokens.length) return fail(tokens[_i]);

        var start = _i,
            wasIdent = false;

        if (tokens[_i].type === TokenType.LowLine) return checkIdentLowLine(_i);

        // start char / word
        if (tokens[_i].type === TokenType.HyphenMinus ||
            tokens[_i].type === TokenType.Identifier ||
            tokens[_i].type === TokenType.DollarSign ||
            tokens[_i].type === TokenType.Asterisk) _i++;
        else return fail(tokens[_i]);

        wasIdent = tokens[_i - 1].type === TokenType.Identifier;

        for (; _i < tokens.length; _i++) {
            if (tokens[_i].type !== TokenType.HyphenMinus &&
                tokens[_i].type !== TokenType.LowLine) {
                    if (tokens[_i].type !== TokenType.Identifier &&
                        (tokens[_i].type !== TokenType.DecimalNumber || !wasIdent)
                        ) break;
                    else wasIdent = true;
            }   
        }

        if (!wasIdent && tokens[start].type !== TokenType.Asterisk) return fail(tokens[_i]);

        tokens[start].ident_last = _i - 1;

        return _i - start;
    }

    function checkIdentLowLine(_i) {
        var start = _i;

        _i++;

        for (; _i < tokens.length; _i++) {
            if (tokens[_i].type !== TokenType.HyphenMinus &&
                tokens[_i].type !== TokenType.DecimalNumber &&
                tokens[_i].type !== TokenType.LowLine &&
                tokens[_i].type !== TokenType.Identifier) break;
        }

        tokens[start].ident_last = _i - 1;

        return _i - start;
    }

    function getIdent() {
        var startPos = pos,
            s = joinValues(pos, tokens[pos].ident_last);

        pos = tokens[pos].ident_last + 1;

        return needInfo?
                [{ ln: tokens[startPos].ln }, CSSPNodeType.IdentType, s] :
                [CSSPNodeType.IdentType, s];
    }

//important = '!' sc*:s0 seq('important') -> [#important].concat(s0)
    function checkImportant(_i) {
        var start = _i,
            l;

        if (tokens[_i++].type !== TokenType.ExclamationMark) return fail(tokens[_i - 1]);

        if (l = checkSC(_i)) _i += l;

        if (tokens[_i].value !== 'important') return fail(tokens[_i]);

        return _i - start + 1;
    }

    function getImportant() {
        var startPos = pos;

        pos++;

        var sc = getSC();

        pos++;

        return (needInfo? [{ ln: tokens[startPos].ln }, CSSPNodeType.ImportantType] : [CSSPNodeType.ImportantType]).concat(sc);
    }

    // node: Namespace
    function checkNamespace(_i) {
        if (tokens[_i].type === TokenType.VerticalLine) return 1;

        return fail(tokens[_i]);
    }

    function getNamespace() {
        var startPos = pos;

        pos++;

        return needInfo?
                [{ ln: tokens[startPos].ln }, CSSPNodeType.NamespaceType] :
                [CSSPNodeType.NamespaceType];
    }

//nth = (digit | 'n')+:x -> [#nth, x.join('')]
//    | (seq('even') | seq('odd')):x -> [#nth, x]
    function checkNth(_i) {
        return checkNth1(_i) || checkNth2(_i);
    }

    function checkNth1(_i) {
        var start = _i;

        for (; _i < tokens.length; _i++) {
            if (tokens[_i].type !== TokenType.DecimalNumber && tokens[_i].value !== 'n') break;
        }

        if (_i !== start) {
            tokens[start].nth_last = _i - 1;
            return _i - start;
        }

        return fail(tokens[_i]);
    }

    function getNth() {
        var startPos = pos;

        if (tokens[pos].nth_last) {
            var n = needInfo?
                        [{ ln: tokens[startPos].ln }, CSSPNodeType.NthType, joinValues(pos, tokens[pos].nth_last)] :
                        [CSSPNodeType.NthType, joinValues(pos, tokens[pos].nth_last)];

            pos = tokens[pos].nth_last + 1;

            return n;
        }

        return needInfo?
                [{ ln: tokens[startPos].ln }, CSSPNodeType.NthType, tokens[pos++].value] :
                [CSSPNodeType.NthType, tokens[pos++].value];
    }

    function checkNth2(_i) {
        if (tokens[_i].value === 'even' || tokens[_i].value === 'odd') return 1;

        return fail(tokens[_i]);
    }

//nthf = ':' seq('nth-'):x (seq('child') | seq('last-child') | seq('of-type') | seq('last-of-type')):y -> (x + y)
    function checkNthf(_i) {
        var start = _i,
            l = 0;

        if (tokens[_i++].type !== TokenType.Colon) return fail(tokens[_i - 1]); l++;

        if (tokens[_i++].value !== 'nth' || tokens[_i++].value !== '-') return fail(tokens[_i - 1]); l += 2;

        if ('child' === tokens[_i].value) {
            l += 1;
        } else if ('last-child' === tokens[_i].value +
                                    tokens[_i + 1].value +
                                    tokens[_i + 2].value) {
            l += 3;
        } else if ('of-type' === tokens[_i].value +
                                 tokens[_i + 1].value +
                                 tokens[_i + 2].value) {
            l += 3;
        } else if ('last-of-type' === tokens[_i].value +
                                      tokens[_i + 1].value +
                                      tokens[_i + 2].value +
                                      tokens[_i + 3].value +
                                      tokens[_i + 4].value) {
            l += 5;
        } else return fail(tokens[_i]);

        tokens[start + 1].nthf_last = start + l - 1;

        return l;
    }

    function getNthf() {
        pos++;

        var s = joinValues(pos, tokens[pos].nthf_last);

        pos = tokens[pos].nthf_last + 1;

        return s;
    }

//nthselector = nthf:x '(' (sc | unary | nth)*:y ')' -> [#nthselector, [#ident, x]].concat(y)
    function checkNthselector(_i) {
        var start = _i,
            l;

        if (l = checkNthf(_i)) _i += l;
        else return fail(tokens[_i]);

        if (tokens[_i].type !== TokenType.LeftParenthesis || !tokens[_i].right) return fail(tokens[_i]);

        l++;

        var rp = tokens[_i++].right;

        while (_i < rp) {
            if (l = checkSC(_i)) _i += l;
            else if (l = checkUnary(_i)) _i += l;
            else if (l = checkNth(_i)) _i += l;
            else return fail(tokens[_i]);
        }

        return rp - start + 1;
    }

    function getNthselector() {
        var startPos = pos,
            nthf = needInfo?
                    [{ ln: tokens[pos].ln }, CSSPNodeType.IdentType, getNthf()] :
                    [CSSPNodeType.IdentType, getNthf()],
            ns = needInfo?
                    [{ ln: tokens[pos].ln }, CSSPNodeType.NthselectorType, nthf] :
                    [CSSPNodeType.NthselectorType, nthf];

        pos++;

        while (tokens[pos].type !== TokenType.RightParenthesis) {
            if (checkSC(pos)) ns = ns.concat(getSC());
            else if (checkUnary(pos)) ns.push(getUnary());
            else if (checkNth(pos)) ns.push(getNth());
        }

        pos++;

        return ns;
    }

    // node: Number
    function checkNumber(_i) {
        if (_i < tokens.length && tokens[_i].number_l) return tokens[_i].number_l;

        if (_i < tokens.length && tokens[_i].type === TokenType.DecimalNumber &&
            (!tokens[_i + 1] ||
             (tokens[_i + 1] && tokens[_i + 1].type !== TokenType.FullStop))
        ) return (tokens[_i].number_l = 1, tokens[_i].number_l); // 10

        if (_i < tokens.length &&
             tokens[_i].type === TokenType.DecimalNumber &&
             tokens[_i + 1] && tokens[_i + 1].type === TokenType.FullStop &&
             (!tokens[_i + 2] || (tokens[_i + 2].type !== TokenType.DecimalNumber))
        ) return (tokens[_i].number_l = 2, tokens[_i].number_l); // 10.

        if (_i < tokens.length &&
            tokens[_i].type === TokenType.FullStop &&
            tokens[_i + 1].type === TokenType.DecimalNumber
        ) return (tokens[_i].number_l = 2, tokens[_i].number_l); // .10

        if (_i < tokens.length &&
            tokens[_i].type === TokenType.DecimalNumber &&
            tokens[_i + 1] && tokens[_i + 1].type === TokenType.FullStop &&
            tokens[_i + 2] && tokens[_i + 2].type === TokenType.DecimalNumber
        ) return (tokens[_i].number_l = 3, tokens[_i].number_l); // 10.10

        return fail(tokens[_i]);
    }

    function getNumber() {
        var s = '',
            startPos = pos,
            l = tokens[pos].number_l;

        for (var i = 0; i < l; i++) {
            s += tokens[pos + i].value;
        }

        pos += l;

        return needInfo?
                [{ ln: tokens[startPos].ln }, CSSPNodeType.NumberType, s] :
                [CSSPNodeType.NumberType, s];
    }

    // node: Operator
    function checkOperator(_i) {
        if (_i < tokens.length &&
            (tokens[_i].type === TokenType.Solidus ||
            tokens[_i].type === TokenType.Comma ||
            tokens[_i].type === TokenType.Colon ||
            tokens[_i].type === TokenType.EqualsSign)) return 1;

        return fail(tokens[_i]);
    }

    function getOperator() {
        return needInfo?
                [{ ln: tokens[pos].ln }, CSSPNodeType.OperatorType, tokens[pos++].value] :
                [CSSPNodeType.OperatorType, tokens[pos++].value];
    }

    // node: Percentage
    function checkPercentage(_i) {
        var x = checkNumber(_i);

        if (!x || (x && _i + x >= tokens.length)) return fail(tokens[_i]);

        if (tokens[_i + x].type === TokenType.PercentSign) return x + 1;

        return fail(tokens[_i]);
    }

    function getPercentage() {
        var startPos = pos,
            n = getNumber();

        pos++;

        return needInfo?
                [{ ln: tokens[startPos].ln }, CSSPNodeType.PercentageType, n] :
                [CSSPNodeType.PercentageType, n];
    }

//progid = sc*:s0 seq('progid:DXImageTransform.Microsoft.'):x letter+:y '(' (m_string | m_comment | ~')' char)+:z ')' sc*:s1
//                -> this.concat([#progid], s0, [[#raw, x + y.join('') + '(' + z.join('') + ')']], s1),
    function checkProgid(_i) {
        var start = _i,
            l,
            x;

        if (l = checkSC(_i)) _i += l;

        if ((x = joinValues2(_i, 6)) === 'progid:DXImageTransform.Microsoft.') {
            _start = _i;
            _i += 6;
        } else return fail(tokens[_i - 1]);

        if (l = checkIdent(_i)) _i += l;
        else return fail(tokens[_i]);

        if (l = checkSC(_i)) _i += l;

        if (tokens[_i].type === TokenType.LeftParenthesis) {
            tokens[start].progid_end = tokens[_i].right;
            _i = tokens[_i].right + 1;
        } else return fail(tokens[_i]);

        if (l = checkSC(_i)) _i += l;

        return _i - start;
    }

    function getProgid() {
        var startPos = pos,
            progid_end = tokens[pos].progid_end;

        return (needInfo? [{ ln: tokens[startPos].ln }, CSSPNodeType.ProgidType] : [CSSPNodeType.ProgidType])
                .concat(getSC())
                .concat([_getProgid(progid_end)])
                .concat(getSC());
    }

    function _getProgid(progid_end) {
        var startPos = pos,
            x = joinValues(pos, progid_end);

        pos = progid_end + 1;

        return needInfo?
                [{ ln: tokens[startPos].ln }, CSSPNodeType.RawType, x] :
                [CSSPNodeType.RawType, x];
    }

//property = ident:x sc*:s0 -> this.concat([#property, x], s0)
    function checkProperty(_i) {
        var start = _i,
            l;

        if (l = checkIdent(_i)) _i += l;
        else return fail(tokens[_i]);

        if (l = checkSC(_i)) _i += l;
        return _i - start;
    }

    function getProperty() {
        var startPos = pos;

        return (needInfo?
                [{ ln: tokens[startPos].ln }, CSSPNodeType.PropertyType, getIdent()] :
                [CSSPNodeType.PropertyType, getIdent()])
            .concat(getSC());
    }

    function checkPseudo(_i) {
        return checkPseudoe(_i) ||
               checkPseudoc(_i);
    }

    function getPseudo() {
        if (checkPseudoe(pos)) return getPseudoe();
        if (checkPseudoc(pos)) return getPseudoc();
    }

    function checkPseudoe(_i) {
        var l;

        if (tokens[_i++].type !== TokenType.Colon) return fail(tokens[_i - 1]);

        if (tokens[_i++].type !== TokenType.Colon) return fail(tokens[_i - 1]);

        if (l = checkIdent(_i)) return l + 2;

        return fail(tokens[_i]);
    }

    function getPseudoe() {
        var startPos = pos;

        pos += 2;

        return needInfo?
                [{ ln: tokens[startPos].ln }, CSSPNodeType.PseudoeType, getIdent()] :
                [CSSPNodeType.PseudoeType, getIdent()];
    }

//pseudoc = ':' (funktion | ident):x -> [#pseudoc, x]
    function checkPseudoc(_i) {
        var l;

        if (tokens[_i++].type !== TokenType.Colon) return fail(tokens[_i - 1]);

        if ((l = checkFunktion(_i)) || (l = checkIdent(_i))) return l + 1;

        return fail(tokens[_i]);
    }

    function getPseudoc() {
        var startPos = pos;

        pos++;

        return needInfo?
                [{ ln: tokens[startPos].ln }, CSSPNodeType.PseudocType, checkFunktion(pos)? getFunktion() : getIdent()] :
                [CSSPNodeType.PseudocType, checkFunktion(pos)? getFunktion() : getIdent()];
    }

    //ruleset = selector*:x block:y -> this.concat([#ruleset], x, [y])
    function checkRuleset(_i) {
        var start = _i,
            l;

        if (tokens[start].ruleset_l !== undefined) return tokens[start].ruleset_l;

        while (l = checkSelector(_i)) {
            _i += l;
        }

        if (l = checkBlock(_i)) _i += l;
        else return fail(tokens[_i]);

        tokens[start].ruleset_l = _i - start;

        return _i - start;
    }

    function getRuleset() {
        var ruleset = needInfo? [{ ln: tokens[pos].ln }, CSSPNodeType.RulesetType] : [CSSPNodeType.RulesetType];

        while (!checkBlock(pos)) {
            ruleset.push(getSelector());
        }

        ruleset.push(getBlock());

        return ruleset;
    }

    // node: S
    function checkS(_i) {
        if (tokens[_i].ws) return tokens[_i].ws_last - _i + 1;

        return fail(tokens[_i]);
    }

    function getS() {
        var startPos = pos,
            s = joinValues(pos, tokens[pos].ws_last);

        pos = tokens[pos].ws_last + 1;

        return needInfo? [{ ln: tokens[startPos].ln }, CSSPNodeType.SType, s] : [CSSPNodeType.SType, s];
    }

    function checkSC(_i) {
        var l,
            lsc = 0;

        while (_i < tokens.length) {
            if (!(l = checkS(_i)) && !(l = checkComment(_i))) break;
            _i += l;
            lsc += l;
        }

        if (lsc) return lsc;

        if (_i >= tokens.length) return fail(tokens[tokens.length - 1]);

        return fail(tokens[_i]);
    }

    function getSC() {
        var sc = [];

        while (pos < tokens.length) {
            if (checkS(pos)) sc.push(getS());
            else if (checkComment(pos)) sc.push(getComment());
            else break;
        }

        return sc;
    }

    //selector = (simpleselector | delim)+:x -> this.concat([#selector], x)
    function checkSelector(_i) {
        var start = _i,
            l;

        if (_i < tokens.length) {
            while (l = checkSimpleselector(_i) || checkDelim(_i)) {
                _i += l;
            }

            tokens[start].selector_end = _i - 1;

            return _i - start;
        }
    }

    function getSelector() {
        var selector = needInfo? [{ ln: tokens[pos].ln }, CSSPNodeType.SelectorType] : [CSSPNodeType.SelectorType],
            selector_end = tokens[pos].selector_end;

        while (pos <= selector_end) {
            selector.push(checkDelim(pos) ? getDelim() : getSimpleSelector());
        }

        return selector;
    }

    // node: Shash
    function checkShash(_i) {
        if (tokens[_i].type !== TokenType.NumberSign) return fail(tokens[_i]);

        var l = checkNmName(_i + 1);

        if (l) return l + 1;

        return fail(tokens[_i]);
    }

    function getShash() {
        var startPos = pos;

        pos++;

        return needInfo?
                [{ ln: tokens[startPos].ln }, CSSPNodeType.ShashType, getNmName()] :
                [CSSPNodeType.ShashType, getNmName()];
    }

//simpleselector = (nthselector | combinator | attrib | pseudo | clazz | shash | any | sc | namespace)+:x -> this.concatContent([#simpleselector], [x])
    function checkSimpleselector(_i) {
        var start = _i,
            l;

        while (_i < tokens.length) {
            if (l = _checkSimpleSelector(_i)) _i += l;
            else break;
        }

        if (_i - start) return _i - start;

        if (_i >= tokens.length) return fail(tokens[tokens.length - 1]);

        return fail(tokens[_i]);
    }

    function _checkSimpleSelector(_i) {
        return checkNthselector(_i) ||
               checkCombinator(_i) ||
               checkAttrib(_i) ||
               checkPseudo(_i) ||
               checkClazz(_i) ||
               checkShash(_i) ||
               checkAny(_i) ||
               checkSC(_i) ||
               checkNamespace(_i);
    }

    function getSimpleSelector() {
        var ss = needInfo? [{ ln: tokens[pos].ln }, CSSPNodeType.SimpleselectorType] : [CSSPNodeType.SimpleselectorType],
            t;

        while (pos < tokens.length && _checkSimpleSelector(pos)) {
            t = _getSimpleSelector();

            if ((needInfo && typeof t[1] === 'string') || typeof t[0] === 'string') ss.push(t);
            else ss = ss.concat(t);
        }

        return ss;
    }

    function _getSimpleSelector() {
        if (checkNthselector(pos)) return getNthselector();
        else if (checkCombinator(pos)) return getCombinator();
        else if (checkAttrib(pos)) return getAttrib();
        else if (checkPseudo(pos)) return getPseudo();
        else if (checkClazz(pos)) return getClazz();
        else if (checkShash(pos)) return getShash();
        else if (checkAny(pos)) return getAny();
        else if (checkSC(pos)) return getSC();
        else if (checkNamespace(pos)) return getNamespace();
    }

    // node: String
    function checkString(_i) {
        if (_i < tokens.length &&
            (tokens[_i].type === TokenType.StringSQ || tokens[_i].type === TokenType.StringDQ)
        ) return 1;

        return fail(tokens[_i]);
    }

    function getString() {
        var startPos = pos;

        return needInfo?
                [{ ln: tokens[startPos].ln }, CSSPNodeType.StringType, tokens[pos++].value] :
                [CSSPNodeType.StringType, tokens[pos++].value];
    }

    //stylesheet = (cdo | cdc | sc | statement)*:x -> this.concat([#stylesheet], x)
    function checkStylesheet(_i) {
        var start = _i,
            l;

        while (_i < tokens.length) {
            if (l = checkSC(_i)) _i += l;
            else {
                currentBlockLN = tokens[_i].ln;
                if (l = checkAtrule(_i)) _i += l;
                else if (l = checkRuleset(_i)) _i += l;
                else if (l = checkUnknown(_i)) _i += l;
                else throwError();
            }
        }

        return _i - start;
    }

    function getStylesheet(_i) {
        var t,
            stylesheet = needInfo? [{ ln: tokens[pos].ln }, CSSPNodeType.StylesheetType] : [CSSPNodeType.StylesheetType];

        while (pos < tokens.length) {
            if (checkSC(pos)) stylesheet = stylesheet.concat(getSC());
            else {
                currentBlockLN = tokens[pos].ln;
                if (checkRuleset(pos)) stylesheet.push(getRuleset());
                else if (checkAtrule(pos)) stylesheet.push(getAtrule());
                else if (checkUnknown(pos)) stylesheet.push(getUnknown());
                else throwError();
            }
        }

        return stylesheet;
    }

//tset = vhash | any | sc | operator
    function checkTset(_i) {
        return checkVhash(_i) ||
               checkAny(_i) ||
               checkSC(_i) ||
               checkOperator(_i);
    }

    function getTset() {
        if (checkVhash(pos)) return getVhash();
        else if (checkAny(pos)) return getAny();
        else if (checkSC(pos)) return getSC();
        else if (checkOperator(pos)) return getOperator();
    }

    function checkTsets(_i) {
        var start = _i,
            l;

        while (l = checkTset(_i)) {
            _i += l;
        }

        return _i - start;
    }

    function getTsets() {
        var tsets = [],
            x;

        while (x = getTset()) {
            if ((needInfo && typeof x[1] === 'string') || typeof x[0] === 'string') tsets.push(x);
            else tsets = tsets.concat(x);
        }

        return tsets;
    }

    // node: Unary
    function checkUnary(_i) {
        if (_i < tokens.length &&
            (tokens[_i].type === TokenType.HyphenMinus ||
            tokens[_i].type === TokenType.PlusSign)
        ) return 1;

        return fail(tokens[_i]);
    }

    function getUnary() {
        var startPos = pos;

        return needInfo?
                [{ ln: tokens[startPos].ln }, CSSPNodeType.UnaryType, tokens[pos++].value] :
                [CSSPNodeType.UnaryType, tokens[pos++].value];
    }

    // node: Unknown
    function checkUnknown(_i) {
        if (_i < tokens.length && tokens[_i].type === TokenType.CommentSL) return 1;

        return fail(tokens[_i]);
    }

    function getUnknown() {
        var startPos = pos;

        return needInfo?
                [{ ln: tokens[startPos].ln }, CSSPNodeType.UnknownType, tokens[pos++].value] :
                [CSSPNodeType.UnknownType, tokens[pos++].value];
    }

//    uri = seq('url(') sc*:s0 string:x sc*:s1 ')' -> this.concat([#uri], s0, [x], s1)
//        | seq('url(') sc*:s0 (~')' ~m_w char)*:x sc*:s1 ')' -> this.concat([#uri], s0, [[#raw, x.join('')]], s1),
    function checkUri(_i) {
        var start = _i,
            l;

        if (_i < tokens.length && tokens[_i++].value !== 'url') return fail(tokens[_i - 1]);

        if (!tokens[_i] || tokens[_i].type !== TokenType.LeftParenthesis) return fail(tokens[_i]);

        return tokens[_i].right - start + 1;
    }

    function getUri() {
        var startPos = pos,
            uriExcluding = {};

        pos += 2;

        uriExcluding[TokenType.Space] = 1;
        uriExcluding[TokenType.Tab] = 1;
        uriExcluding[TokenType.Newline] = 1;
        uriExcluding[TokenType.LeftParenthesis] = 1;
        uriExcluding[TokenType.RightParenthesis] = 1;

        if (checkUri1(pos)) {
            var uri = (needInfo? [{ ln: tokens[startPos].ln }, CSSPNodeType.UriType] : [CSSPNodeType.UriType])
                        .concat(getSC())
                        .concat([getString()])
                        .concat(getSC());

            pos++;

            return uri;
        } else {
            var uri = (needInfo? [{ ln: tokens[startPos].ln }, CSSPNodeType.UriType] : [CSSPNodeType.UriType])
                        .concat(getSC()),
                l = checkExcluding(uriExcluding, pos),
                raw = needInfo?
                        [{ ln: tokens[pos].ln }, CSSPNodeType.RawType, joinValues(pos, pos + l)] :
                        [CSSPNodeType.RawType, joinValues(pos, pos + l)];

            uri.push(raw);

            pos += l + 1;

            uri = uri.concat(getSC());

            pos++;

            return uri;
        }
    }

    function checkUri1(_i) {
        var start = _i,
            l = checkSC(_i);

        if (l) _i += l;

        if (tokens[_i].type !== TokenType.StringDQ && tokens[_i].type !== TokenType.StringSQ) return fail(tokens[_i]);

        _i++;

        if (l = checkSC(_i)) _i += l;

        return _i - start;
    }

    // value = (sc | vhash | any | block | atkeyword | operator | important)+:x -> this.concat([#value], x)
    function checkValue(_i) {
        var start = _i,
            l;

        while (_i < tokens.length) {
            if (l = _checkValue(_i)) _i += l;
            else break;
        }

        if (_i - start) return _i - start;

        return fail(tokens[_i]);
    }

    function _checkValue(_i) {
        return checkSC(_i) ||
               checkVhash(_i) ||
               checkAny(_i) ||
               checkBlock(_i) ||
               checkAtkeyword(_i) ||
               checkOperator(_i) ||
               checkImportant(_i);
    }

    function getValue() {
        var ss = needInfo? [{ ln: tokens[pos].ln }, CSSPNodeType.ValueType] : [CSSPNodeType.ValueType],
            t;

        while (pos < tokens.length && _checkValue(pos)) {
            t = _getValue();

            if ((needInfo && typeof t[1] === 'string') || typeof t[0] === 'string') ss.push(t);
            else ss = ss.concat(t);
        }

        return ss;
    }

    function _getValue() {
        if (checkSC(pos)) return getSC();
        else if (checkVhash(pos)) return getVhash();
        else if (checkAny(pos)) return getAny();
        else if (checkBlock(pos)) return getBlock();
        else if (checkAtkeyword(pos)) return getAtkeyword();
        else if (checkOperator(pos)) return getOperator();
        else if (checkImportant(pos)) return getImportant();
    }

    // node: Vhash
    function checkVhash(_i) {
        if (_i >= tokens.length || tokens[_i].type !== TokenType.NumberSign) return fail(tokens[_i]);

        var l = checkNmName2(_i + 1);

        if (l) return l + 1;

        return fail(tokens[_i]);
    }

    function getVhash() {
        var startPos = pos;

        pos++;

        return needInfo?
                [{ ln: tokens[startPos].ln }, CSSPNodeType.VhashType, getNmName2()] :
                [CSSPNodeType.VhashType, getNmName2()];
    }

    function checkNmName(_i) {
        var start = _i;

        // start char / word
        if (tokens[_i].type === TokenType.HyphenMinus ||
            tokens[_i].type === TokenType.LowLine ||
            tokens[_i].type === TokenType.Identifier ||
            tokens[_i].type === TokenType.DecimalNumber) _i++;
        else return fail(tokens[_i]);

        for (; _i < tokens.length; _i++) {
            if (tokens[_i].type !== TokenType.HyphenMinus &&
                tokens[_i].type !== TokenType.LowLine &&
                tokens[_i].type !== TokenType.Identifier &&
                tokens[_i].type !== TokenType.DecimalNumber) break;
        }

        tokens[start].nm_name_last = _i - 1;

        return _i - start;
    }

    function getNmName() {
        var s = joinValues(pos, tokens[pos].nm_name_last);

        pos = tokens[pos].nm_name_last + 1;

        return s;
    }

    function checkNmName2(_i) {
        var start = _i;

        if (tokens[_i].type === TokenType.Identifier) return 1;
        else if (tokens[_i].type !== TokenType.DecimalNumber) return fail(tokens[_i]);

        _i++;

        if (!tokens[_i] || tokens[_i].type !== TokenType.Identifier) return 1;

        return 2;
    }

    function getNmName2() {
        var s = tokens[pos].value;

        if (tokens[pos++].type === TokenType.DecimalNumber &&
                pos < tokens.length &&
                tokens[pos].type === TokenType.Identifier
        ) s += tokens[pos++].value;

        return s;
    }

    function checkExcluding(exclude, _i) {
        var start = _i;

        while(_i < tokens.length) {
            if (exclude[tokens[_i++].type]) break;
        }

        return _i - start - 2;
    }

    function joinValues(start, finish) {
        var s = '';

        for (var i = start; i < finish + 1; i++) {
            s += tokens[i].value;
        }

        return s;
    }

    function joinValues2(start, num) {
        if (start + num - 1 >= tokens.length) return;

        var s = '';

        for (var i = 0; i < num; i++) {
            s += tokens[start + i].value;
        }

        return s;
    }

    function markSC() {
        var ws = -1, // whitespaces
            sc = -1, // ws and comments
            t;

        for (var i = 0; i < tokens.length; i++) {
            t = tokens[i];
            switch (t.type) {
                case TokenType.Space:
                case TokenType.Tab:
                case TokenType.Newline:
                    t.ws = true;
                    t.sc = true;

                    if (ws === -1) ws = i;
                    if (sc === -1) sc = i;

                    break;
                case TokenType.CommentML:
                    if (ws !== -1) {
                        tokens[ws].ws_last = i - 1;
                        ws = -1;
                    }

                    t.sc = true;

                    break;
                default:
                    if (ws !== -1) {
                        tokens[ws].ws_last = i - 1;
                        ws = -1;
                    }

                    if (sc !== -1) {
                        tokens[sc].sc_last = i - 1;
                        sc = -1;
                    }
            }
        }

        if (ws !== -1) tokens[ws].ws_last = i - 1;
        if (sc !== -1) tokens[sc].sc_last = i - 1;
    }

    return function(_tokens, rule, _needInfo) {
        return _getAST(_tokens, rule, _needInfo);
    }

}());
    return function(s, rule, _needInfo) {
        return getCSSPAST(getTokens(s), rule, _needInfo);
    }
}());
exports.srcToCSSP = srcToCSSP;

});

/*
 * Don't edit this file by hand!
 * This file was generated from a npm-package using gulp. 
 * For more information see gulpfile.js in the project root
 */
define('gonzales/cssp.translator.node',['require','exports','module'],function (require, exports, module) {// version: 1.0.0

function csspToSrc(tree, hasInfo) {

    var _m_simple = {
            'unary': 1, 'nth': 1, 'combinator': 1, 'ident': 1, 'number': 1, 's': 1,
            'string': 1, 'attrselector': 1, 'operator': 1, 'raw': 1, 'unknown': 1
        },
        _m_composite = {
            'simpleselector': 1, 'dimension': 1, 'selector': 1, 'property': 1, 'value': 1,
            'filterv': 1, 'progid': 1, 'ruleset': 1, 'atruleb': 1, 'atrulerq': 1, 'atrulers': 1,
            'stylesheet': 1
        },
        _m_primitive = {
            'cdo': 'cdo', 'cdc': 'cdc', 'decldelim': ';', 'namespace': '|', 'delim': ','
        };

    function _t(tree) {
        var t = tree[hasInfo? 1 : 0];
        if (t in _m_primitive) return _m_primitive[t];
        else if (t in _m_simple) return _simple(tree);
        else if (t in _m_composite) return _composite(tree);
        return _unique[t](tree);
    }

    function _composite(t, i) {
        var s = '';
        i = i === undefined ? (hasInfo? 2 : 1) : i;
        for (; i < t.length; i++) s += _t(t[i]);
        return s;
    }

    function _simple(t) {
        return t[hasInfo? 2 : 1];
    }

    var _unique = {
        percentage: function(t) {
            return _t(t[hasInfo? 2 : 1]) + '%';
        },
        comment: function (t) {
            return '/*' + t[hasInfo? 2 : 1] + '*/';
        },
        clazz: function(t) {
            return '.' + _t(t[hasInfo? 2 : 1]);
        },
        atkeyword: function(t) {
            return '@' + _t(t[hasInfo? 2 : 1]);
        },
        shash: function (t) {
            return '#' + t[hasInfo? 2 : 1];
        },
        vhash: function(t) {
            return '#' + t[hasInfo? 2 : 1];
        },
        attrib: function(t) {
            return '[' + _composite(t) + ']';
        },
        important: function(t) {
            return '!' + _composite(t) + 'important';
        },
        nthselector: function(t) {
            return ':' + _simple(t[hasInfo? 2 : 1]) + '(' + _composite(t, hasInfo? 3 : 2) + ')';
        },
        funktion: function(t) {
            return _simple(t[hasInfo? 2 : 1]) + '(' + _composite(t[hasInfo? 3: 2]) + ')';
        },
        declaration: function(t) {
            return _t(t[hasInfo? 2 : 1]) + ':' + _t(t[hasInfo? 3 : 2]);
        },
        filter: function(t) {
            return _t(t[hasInfo? 2 : 1]) + ':' + _t(t[hasInfo? 3 : 2]);
        },
        block: function(t) {
            return '{' + _composite(t) + '}';
        },
        braces: function(t) {
            return t[hasInfo? 2 : 1] + _composite(t, hasInfo? 4 : 3) + t[hasInfo? 3 : 2];
        },
        atrules: function(t) {
            return _composite(t) + ';';
        },
        atruler: function(t) {
            return _t(t[hasInfo? 2 : 1]) + _t(t[hasInfo? 3 : 2]) + '{' + _t(t[hasInfo? 4 : 3]) + '}';
        },
        pseudoe: function(t) {
            return '::' + _t(t[hasInfo? 2 : 1]);
        },
        pseudoc: function(t) {
            return ':' + _t(t[hasInfo? 2 : 1]);
        },
        uri: function(t) {
            return 'url(' + _composite(t) + ')';
        },
        functionExpression: function(t) {
            return 'expression(' + t[hasInfo? 2 : 1] + ')';
        }
    };

    return _t(tree);
}
exports.csspToSrc = csspToSrc;

});

/*
 * Don't edit this file by hand!
 * This file was generated from a npm-package using gulp. 
 * For more information see gulpfile.js in the project root
 */
define('gonzales/gonzales',['require','exports','module','./gonzales.cssp.node','./cssp.translator.node'],function (require, exports, module) {// CSSP

exports.srcToCSSP = require('./gonzales.cssp.node').srcToCSSP;

exports.csspToSrc = require('./cssp.translator.node').csspToSrc;

exports.csspToTree = function(tree, level) {
    var spaces = dummySpaces(level),
        level = level ? level : 0,
        s = (level ? '\n' + spaces : '') + '[';

    tree.forEach(function(e) {
        if (e.ln === undefined) {
            s += (Array.isArray(e) ? exports.csspToTree(e, level + 1) : ('\'' + e.toString() + '\'')) + ', ';
        }
    });

    return s.substr(0, s.length - 2) + ']';
}

function dummySpaces(num) {
    return '                                                  '.substr(0, num * 2);
}

});

define('metapolator/models/CPS/parsing/Source',[

], function(

) {
    
    /**
     * The source of a all _Nodes in one PropertyCollection.
     * Currently only the name. To trace later where a value
     * comes from.
     */
    function Source(name) {
        this._name = name;
    }

    var _p = Source.prototype;

    _p.toString = function() {
        return ['<Source:', this._name, '>'].join(' ');
    };

    Object.defineProperty(_p, 'name', {
        get: function(){ return this._name; }
    });

    return Source;
});

define('metapolator/models/CPS/elements/_Node',[
    'metapolator/errors'
  , '../../_BaseModel'
  , 'metapolator/models/emitterMixin'
], function(
    errors
  , Parent
  , emitterMixin
) {
    

    var AbstractInterfaceError = errors.AbstractInterface;

    /**
     * All Elements in a ParametersCollection have this base type OR
     * should at least expose the same Interface (ducktyping).
     */
    function _Node(source, lineNo) {
        /*jshint validthis:true*/
        Parent.call(this);
        this._source = source;
        this._lineNo = lineNo;

        // the `reset` method of ParameterCollection will call this constructor
        // repeatedly. So we need a way to detect if this is was already
        // applied or not
        if(!this.__firstTimeInitFlag) {
            emitterMixin.init(this);
            Object.defineProperty(this, '__firstTimeInitFlag', {value: true});
        }
    }
    var _p = _Node.prototype = Object.create(Parent.prototype);
    _p.constructor = _Node;

    emitterMixin(_p);

    _p.toString = function() {
        throw new AbstractInterfaceError('This interface is abstract and'
            + 'needs an implementation (parameters/_Node.toString)');
    };

    /**
     * Trigger the destroy event and let the _Node clean up if needed.
     * When destroy is called, this _Node is probably alredy removed from
     * its hosting structure.
     *
     * Only the parent of this _Node may call destroy, when the node is
     * deleted. So don't use it anywhere else!
     * We will probably not have all nodes using this method, it depends
     * on the context.
     */
    _p.destroy = function(data) {
        this._trigger('destroy', data);
    };

    function _getterCreator(item) {
        /*jshint validthis:true*/
        var external = item[0]
          , internal = item[1]
          ;
        Object.defineProperty(this, external, {
            get: function(){ return this[internal]; }
        });
    }

    ([
        ['source', '_source']
      , ['lineNo', '_lineNo']
    ].forEach(_getterCreator, _p));

    return _Node;
});

define('metapolator/models/CPS/elements/SelectorList',[
    './_Node'
], function(
    Parent
) {
    
    /**
     * A list of ComplexSelectors
     *
     * An instance of this must be treated as immutable, it will not
     * change its content/selectors.
     */
    function SelectorList(selectors, source, lineNo) {
        Parent.call(this, source, lineNo);
        // Keeping this private. The value property returns a copy of
        // the this._selectors array and that's the public interface.
        this._selectors = selectors.slice();
        this._multiplyCache = new WeakMap();

        var i, l, selector, count=0, invalid=false, message;

        for(i=0,l=this._selectors.length;i<l;i++) {
            selector = this._selectors[i];
            if(selector.invalid) {
                invalid = true;
                message = selector.message;
                break;
            }
            if(!selector.selects)
                continue;
            count +=1;
        }
        if(!invalid && !count) {
            invalid = true;
            message = 'SelectorList has no valid selector';
        }
        Object.defineProperties(this,{
            'selects': {
                value: !invalid
              , enumerable: true
            }
          , 'invalid': {
                value: invalid
              , enumerable: true
            }
          , 'length': {
                value: selectors.length
              , enumerable: true
            }
          , 'message': {
                value: message
              , enumerable: true
            }
        });
        Object.freeze(this);
        Object.freeze(this._selectors);
    }

    /**
     * A factory that creates one selectorlist from two input
     * selectorLists
     *
     * This uses the value property of the input selectorLists,
     * so the result uses only selecting ComplexSelectors
     *
     * The ComplexSelectors are combined using the descendant combinator.
     */
    SelectorList.multiply = function(a, b) {
        var x, y, l, ll
          , selectorsA = a._selectors
          , selectorsB = b._selectors
          , result = []
          ;
        for(x=0,l=selectorsA.length;x<l;x++) {
            for(y=0, ll=selectorsB.length;y<ll;y++)
                result.push(selectorsA[x].add(selectorsB[y]));
        }
        return new SelectorList(result);
    };

    var _p = SelectorList.prototype = Object.create(Parent.prototype);
    _p.constructor = SelectorList;

    Object.defineProperty(_p, 'value', {
        get: function(){ return this._selectors.slice(); }
    });

    var _filterValid = function(selector) {
        return !selector.invalid;
    };

    _p.toString = function() {
        return this._selectors.filter(_filterValid).join(',\n') || 'invalidSelectorList';
    };

    _p.multiply = function(selectorList) {
        // the cache is a WeakMap, so it will clean itself
        var r = this._multiplyCache.get(selectorList);
        if(!r) {
            r = this.constructor.multiply(this, selectorList);
            this._multiplyCache.set(selectorList, r);
        }
        return r;
    };

    return SelectorList;
});

define('metapolator/models/CPS/elements/Rule',[
    'metapolator/errors'
  , './_Node'
], function(
    errors
  , Parent
) {
    

    var ValueError = errors.Value;

    /**
     * The container for selectors and parameters.
     */
    function Rule(selectorList, parameterDict, source, lineNo) {
        Parent.call(this, source, lineNo);
        this._selectorList = selectorList;
        Object.defineProperty(this, 'parameters', {
            value: parameterDict
          , enumerable: true
        });
    }

    var _p = Rule.prototype = Object.create(Parent.prototype);
    _p.constructor = Rule;

    _p.toString = function() {
        return [this._selectorList, ' ', this.parameters].join('');
    };

    Object.defineProperty(_p, 'invalid', {
        get: function(){
            return this._selectorList.invalid;
        }
    });

    /**
     * If no namespaces are provided, the result of this method equals
     * this._selectorList.
     */
    _p.getSelectorList = function(namespaces) {
        var selectorList = this._selectorList
          , i, l
          ;
        // Multiply the selectorList on the left by each namespace in turn
        if (namespaces !== undefined) {
            for(i=0, l=namespaces.length;i<l;i++)
                if(namespaces[i] !== null)
                    selectorList = namespaces[i].multiply(selectorList);
        }
        return selectorList;
    };

    _p.setSelectorList = function(selectorList) {
        if(selectorList.invalid)
            throw new ValueError('Trying to set an invalid selectorList: ' + selectorList);
        this._selectorList = selectorList;
        this._trigger('selector-change');
    };

    return Rule;
});

define('metapolator/models/CPS/elements/Comment',[
    './_Node'
], function(
    Parent
) {
    
    /**
     * Any comment in the CPS.
     */
    function Comment(comment, source, lineNo) {
        Parent.call(this, source, lineNo);
        Object.defineProperties(this, {
            comment: {
                value: comment
              , enumerable: true
            }
          , invalid: {
                value: false
              , enumerable: true
            }
        });
    }
    var _p = Comment.prototype = Object.create(Parent.prototype);
    _p.constructor = Comment;

    _p.toString = function() {
        // TODO: escape */ within this.comment, or remove it if escaping doesn't work.
        return ['/*', this.comment, '*/'].join('');
    };

    return Comment;
});

define('metapolator/models/CPS/elements/ParameterCollection',[
    'metapolator/errors'
  , './_Node'
  , './SelectorList'
  , './Rule'
  , './Comment'
], function(
    errors
  , Parent
  , SelectorList
  , Rule
  , Comment
) {
    
    var CPSError = errors.CPS
      , ValueError = errors.Value
      ;
    /**
     * A list of Rule, ParameterCollection (also @namespace, @import) and
     * Comment Elements
     */
    function ParameterCollection(items, source, lineNo) {
        Parent.call(this, source, lineNo);
        this._items = items.slice();

        this._name = null;
        this._rules = null;
        this._rulesCacheSubscriptions = [];
        if(!this._allowNamespace) {
            // lock this.name
            this.name = undefined;
        }
    }
    var _p = ParameterCollection.prototype = Object.create(Parent.prototype);
    _p.constructor = ParameterCollection;

    // called in RuleController._set
    _p.reset = function(/* same as constructor ! */) {
        this._unsetRulesCache();

        // FIXME: without having other listeners on these items, we'll
        // probably won't need to call the destroy method
        // but maybe this becomes interesting when the ui displays this
        // data structure
        // uncomment calls to destroy everywhere???
        var items = this._items, i, l;
        this._items = null;
        for(i=0,l=items.length;i<l;i++)
            items[i].destroy();

        // reset all own, enumerable, configurable properties
        Object.keys(this).forEach(function(key) {
            if(Object.getOwnPropertyDescriptor(this, key).configurable)
                delete this[key];
        }, this);

        this.constructor.apply(this, arguments);
        // the collection changed most probably
        this._trigger('structural-change');
    };

    _p.toString = function() {
        return this._items.join('\n\n');
    };

    /**
     * subclasses of this will have to overide this definition
     */
    Object.defineProperty(_p, 'invalid', {
        value: false
    });

    function _filterRules(item) {
        return item instanceof Rule;
    }

    /**
     * for display in the ui
     */
    Object.defineProperty(_p, 'items', {
        get: function(){return this._items.slice();}
    });

    Object.defineProperty(_p, 'length', {
        get: function(){ return this._items.length;}
    });

    Object.defineProperty(_p, 'name', {
        enumerable: true
      , get: function() {
            return (this._name ? this._name : null);
        }
      , set: function(name) {
            if(this._name !== null)
                throw new CPSError('Name is already set: ' + this._name);
            if(name === undefined) {
                this._name = undefined;
                return;
            }
            else if(typeof name !== 'string')
                throw new CPSError('Name has the wrong type, expected '
                    + 'string but got: '
                    + (name.constructor
                        ? name.constructor.name
                        : name + ' typeof: ' + (typeof name)));
            this._name = name;
        }
    });

    /**
     * this returns all rules that are direct children of this collection
     * AND all rules of ParameterCollection instances that are
     * direct children of this collection, a "flattened" list in the form:
     * [
     *    [namespace Selectorlist, Rule]
     *  , [namespace Selectorlist, Rule]
     *  , ...
     * ]
     *
     */
    Object.defineProperty(_p, 'rules', {
        get: function() {
            if(!this._rules)
                this._rules = this._getRules();
            return this._rules;
        }
    });

    /**
     * invalidate the cache on the right occasions,
     * This are events that imply:
     *  -- That a child rule changed its SelectorList
     *  -- That this AtNamespaceCollection changed its SelectorList (right???)
     *  -- That this ParameterCollection changed its set of Rules
     *  -- That a child ParameterCollection changed its set of Rules
     *
     * We dont need invalidation of this cache if a Rule changed the contents
     * of its ParameterDict.
     */
    _p._unsetRulesCache = function() {
        var i,l, subscription;
        this._rules = null;
        this._unsubscribeAll();
    };

    _p._subscribe = function(item, channel, callback, data) {
        var subscriptionID = item.on(channel, callback, data);
        this._rulesCacheSubscriptions.push([item, subscriptionID]);
    };
    _p._unsubscribeAll = function() {
        var i, l, subscription;
        for(i=0,l=this._rulesCacheSubscriptions.length;i<l;i++) {
            subscription = this._rulesCacheSubscriptions[i];
            subscription[0].off(subscription[1]);
        }
        this._rulesCacheSubscriptions = [];
    };

    _p._structuralChangeHandler = function(data, channelName, eventData) {
        this._unsetRulesCache();
        this._trigger('structural-change');
    };

    _p._getRules = function () {
        var i, l, j, ll
          , rules = []
          , childRules
          , item, rule
          , selectorList
          , callback = [this, '_structuralChangeHandler']
          , ruleChannel = 'selector-change'
          , collectionChannel = 'structural-change'
          , copyRules
          ;
        for(i=0, l=this._items.length;i<l;i++) {
            item = this._items[i];
            if(item instanceof Rule) {
                this._subscribe(item, ruleChannel, callback);
                if(item.invalid) continue;
                // 0: array of namespaces, initially empty
                // 1: the instance of Rule
                // thus: [selectorList, rule, [_Collections where this rule is embeded]]
                rules.push([ item.getSelectorList(), item]);//, [this] ]);
            }
            else if(item instanceof ParameterCollection) {
                this._subscribe(item, collectionChannel, callback);
                if(item.invalid)
                    continue;
                childRules = item.rules;
                // rules of @import are copied, because they are reused
                // in other collections as well. @namespace changes the
                // rule array, for example, that changes all other instances
                // of that rule array as well. So, rule arrays that are reused
                // must be copied, this is currently only true for
                // @import
                // NOTE: this is also caused partly by the `this._rules`
                // cache. Thus a possible solution would be to not use
                // caches for some types of ParameterCollection. @import
                // could, instead of returning the proxied value, return
                // a copy of it's _reference rules.
                // @namespace, on the other hand, needs no cache in principle
                // becuase the important cache is the plain ParameterCollection
                // that contains the @namespace ...
                copyRules = (item.name === 'import');
                for(j=0,ll=childRules.length;j<ll;j++) {
                    rule = childRules[j];
                    // add `this` to the third entry to produce a history
                    // of nested ParameterCollections, this is to show
                    // in the the ui where this rule comes from
                    // rule[2].push(this);
                    rules.push(copyRules ? rule.slice() : rule);
                }
            }
        }
        return rules;
    };


    function _checkItem(item) {
        return (
                (item instanceof Rule && !item.invalid)
             || (item instanceof ParameterCollection && !item.invalid)
             || item instanceof Comment
        );
    }

    /**
     * FIXME: this is copy and pasted from models/ParameterDict but the
     *        implementation should be shared!
     *
     * Calculate the start index where Array.prototype.splice really starts.
     *
     * > start:
     * > Index at which to start changing the array. If greater than the
     * > length of the array, actual starting index will be set to the
     * > length of the array. If negative, will begin that many elements
     * > from the end.
     *
     * Not in that documentation, if negative after length-start: start = 0
     */
    _p._getCanonicalStartIndex = function(start, length) {
        if(start >= length)
            return length;
        if(start < 0)
            return Math.max(0, length - start);
        return start;
    };
    /**
     * One to rule them all:
     *
     * insert a Rule (which must have a valid SelectorList)
     * remove a Rule
     * replace a rule
     * Add/remove @namespace (with valid SelectorList) or @import
     * Add/remove comments
     * Remove invalid hunks of data. <= just don't allow inserting invalid hunks
     *
     * all is done with Array.prototype.splice
     * see: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/splice
     *
     * emits:
     *      "delete" if there where deletions
     *      "add" if there where insertion
     *      "structural-change" if there where insertion or deletions
     */
    _p.splice = function(startIndex, deleteCount, _insertions /* single item or array of items */) {
        var insertions = _insertions instanceof Array
            ? _insertions
            : [_insertions]
          , deleted
          , args
          , i, l
          , item
          , events = []
          , canonicalStartIndex = this._getCanonicalStartIndex(startIndex, this._items.length)
          ;
        for(i=0,l=insertions.length;i<l; i++) {
            item = insertions[i];
            if(!_checkItem(item))
                throw new ValueError('Trying to insert an invalid item: ' + item);
        }

        args = [startIndex, deleteCount];
        Array.prototype.push.apply(args, insertions);
        deleted = Array.prototype.splice.apply(this._items, args);
        for(i=0,l=deleted.length;i<l;i++)
            deleted[i].destroy();
        if(deleted.length)
            events.push('delete');
        if(insertions.length)
            events.push('add');
        if(!events.length)
            // nothing happened
            return;
        events.push('structural-change');
        // TODO: Add maybe information like three numbers:
        //      index, deletedCount, insertedCount
        // That could help to update the ui, however, usually a ui is not
        // that delicate!.
        // NOTE: index and deletedCount must be calculated see the
        // docs for Array.prototype.slice
        this._trigger(events);
        return [canonicalStartIndex, deleted.length, insertions.length];
    };

    _p.getItem = function(index) {
        return this.items[index];
    };

    return ParameterCollection;
});

define('metapolator/models/CPS/parsing/engine',[
    'metapolator/errors'
  , './Source'
  , 'metapolator/models/CPS/elements/ParameterCollection'

], function (
    errors
  , Source
  , ParameterCollection
) {
    
    var CPSError = errors.CPS;
    // FIXME: handle errors!
    // especially erros thrown by gonzales, due to bad CSS input need
    // some attention

    var _pattern_linebreak = /\n/g;
    function _countLinebreaks(data) {
        switch (data) {
            // cheaper shortcuts
            case ' ':
                return 0;
            case '\n':
            case ' \n':
            case '\n ':
            case ' \n ':
                return 1;
            default:
                // this is the most expensive one
                return (data.match(_pattern_linebreak) || [] ).length;
        }
    }

    /**
     * Create a node as used in engine.
     */
    function _makeNode(nodeConstructors, parent, lineNo, data) {
        var ASTType = data[0];
        if(!parent)
            // this creates a root node
            parent = {
                depth: -1 //  +1 will be 0
              , makeInstance: true
              , type: '__init__' // can be anything but '__GenericAST__'
            };
        var node = {
            type: (ASTType in nodeConstructors)
                // create a known entity
                ? ASTType
                // just save the raw AST data
                : '__GenericAST__'
          , depth: parent.depth + 1
          , lineNo: lineNo
          , rawData: data
          , makeInstance: (
              // if the parent will not be instantiated there's no
              // need to instantiate this node, it won't persist
              // anywhere
              parent.makeInstance
              // AND if the parent is a __GenericAST__ type, it won't
              // save any children, so we don't need to make an instance
              // of this node. This--above all--is because we save
              //  __GenericAST__s children at the 'data' key.
              && parent.type !== '__GenericAST__'
            )
        };
        return node;
    }

    /**
     * Create a parameter node (ParameterCollection) from an Abstract
     * Syntax Tree(AST) like the one that is returned by gonzales.srcToCSSP
     * see: https://github.com/css/gonzales/blob/master/doc/AST.CSSP.en.md
     *
     * In the ParameterList Tree, there will be some arrays of the AST
     * referenced. SO if you are going to change the AST, you might change
     * ParameterList items, too. Create a deep copy of the AST if you
     * don't want this side effect.
     */
    function parserEngine(defaultNodeConstructors, factorySwitches, ast
                                    , sourceName, ruleController) {
        if(sourceName === undefined)
            sourceName = '(unknown source)';
        var source = new Source(sourceName)
          , stack = []
          , lineNo = 1
          , frame
          , ASTType
          , node, data, childNode
          , root
          // I added a way to change the node constructors object
          // depending on the context, currently only used for @dictionary
          , nodeConstructors = defaultNodeConstructors
          , oldNodeConstructors
          , i
          ;

        // initial frame
        root = _makeNode(nodeConstructors, false, lineNo, ast);
        // use slice to make a copy of the ast array
        stack.push([ast.slice(), root]);

        // we want to walk the complete tree, because we want to detect all
        // ["s", " \n "] etc. so we can count line breaks. I hope the gonzales
        // parser doesn't hide line breaks from us.
        // Line numbers are VERY helpful when working with a CSS file
        // that's why I want to keep them
        while((frame = stack.pop())) {
            // if frame 2 is set this means that the element switched
            // nodeConstructors for its own object, and that the
            // old nodeConstructors object is in frame[2]

            ASTType = frame[0][0];
            //remove the 2nd item from frame[0] and return it encapsulated
            // into an array
            data = frame[0].splice(1, 1);
            node = frame[1];

            // only ASTType is left; frame[0].splice(1, 1) returned and empty array
            if(!data.length) {
                // ASCENDING
                // All children are already initialized.
                if(node.makeInstance)
                    node.instance = nodeConstructors[node.type](node, source, ruleController);

                //switch back nodeConstructors if this element switched it
                if(frame[2])
                    nodeConstructors = frame[2];
                continue;
            }
            // there may still be data left, we have to revisit this frame
            stack.push(frame);
            data = data[0];
            if(!(data instanceof Array)) {
                // DEEPEST POINT, this node has no children
                // assert(!('children' in node), 'A data node must not have a children key')
                // save the data
                node.data = data;

                if (ASTType in {'comment':null, 's':null})
                    // count linebreaks
                    lineNo += _countLinebreaks(data);
                continue;
            }
            // data is an array
            // DESCENDING

            // switch nodeConstructors if it's the right element
            // currently only used for @dictionary, but this mechanism
            // is very generic
            oldNodeConstructors = undefined;
            for(i=0; i<factorySwitches.length;i++) {
                if(factorySwitches[i][0](data)){
                    oldNodeConstructors = nodeConstructors;
                    // keep this until childNode is finalized, then switch back
                    nodeConstructors = factorySwitches[i][1];
                    break;
                }
            }

            childNode = _makeNode(nodeConstructors, node, lineNo, data);
            // Each frame needs to be visited, because we want to count
            // lines.
            // Use slice to make a copy of the data array
            stack.push([data.slice(), childNode, oldNodeConstructors]);
            if(!childNode.makeInstance)
                continue;
            // keep the childNode
            if(!node.children)
                // assert(!('data' in node), 'A structural node must not have a data key')
                node.children = [];
            node.children.push(childNode);
        }
        //return root
        if(!(root.instance instanceof ParameterCollection))
            throw new CPSError('Parser was expected to create an instance '
                                + 'of ParameterCollection but it delivered '
                                + 'a ' + root.instance.constructor.name);

        return root.instance;
    }
    return parserEngine;
});

define('metapolator/models/CPS/elements/GenericCPSNode',[
    './_Node'
  , 'gonzales/gonzales'
], function(
    Parent
  , gonzales
) {
    
    /**
     * We keep the CPS declarations that we don't understand as Generic
     * CPS object around. These objects can be turned into a CPS string
     * that equals their source from a semantic point of view. The
     * GenericCPSNode makes it possible to be non-destructive and forgiving
     * with CPS originating from other applications etc.
     */
    function GenericCPSNode(ast, source, lineNo) {
        Parent.call(this, source, lineNo);
        this._ast = ast;
    }
    var _p = GenericCPSNode.prototype = Object.create(Parent.prototype);
    _p.constructor = GenericCPSNode;

    // should this return a deep copy to protect its data??
    // since we are not about changing a GenericCPSNode at all,
    // it shouldn't be possible to change the _ast data!
    // Object.defineProperty(_p, 'ast', {
    //     get: function(){ return this._ast.slice(); }
    // })

    _p.toString = function() {
        return gonzales.csspToSrc(this._ast);
    };

    Object.defineProperty(_p, 'type', {
        get: function(){ return this._ast[0]; }
    });

    return GenericCPSNode;
});

define('metapolator/models/CPS/parsing/baseFactories',[
    'metapolator/errors'
  , 'metapolator/models/CPS/elements/ParameterCollection'
  , 'metapolator/models/CPS/elements/Comment'
  , 'metapolator/models/CPS/elements/GenericCPSNode'

], function (
    errors
  , ParameterCollection
  , Comment
  , GenericCPSNode
) {
    
    var CPSError = errors.CPS;
    /**
     * Constructors OR factory functions
     * this can be both because JavaScript allows to call a factory function
     * using the new operator like in `new myfactory()`. The factory must
     * return a new object in this case.
     *
     * all constructors take the following arguments: (node, source)
     * @node: object as created by parserEngine._makeNode and augmented by
     * parserEngine
     * @source: instance of parameters/Source
     *
     * We'll use mostly factories, because the "node" we use as argument
     * is not exactly a nice interface. However, its called _nodeConstructors
     * because that implies that these functions are beeing called using
     * the `new` keyword.
     *
     * see: https://github.com/css/gonzales/blob/master/doc/AST.CSSP.en.md
     */
    return {
        /**
         * stylesheet:
         *
         * A list of rulesets, comments and __GenericAST__
         * We will delete __GenericAST__ of type 's'
         *
         * From the docs:
         * Consists of ruleset (a set of rules with selectors),
         * atrules (single-line at-rule),
         * atruleb (block at-rule)
         * and atruler (at-rule with ruleset).
         *
         * Also there are s (whitespace) and comment (comments).
         */
        'stylesheet': function(node, source) {
            var items = []
              , i=0
              ;
            for(;i<node.children.length;i++) {
                if(node.children[i].type === '__GenericAST__'
                                && node.children[i].instance.type === 's')
                    continue;
                items.push(node.children[i].instance);
            }

            return new ParameterCollection(items, source, node.lineNo);
        }
        /**
         * comment:
         *
         * A comment. We keep comments in the most cases around.
         *
         * Nodes aware of comments are:
         *
         * stylesheet
         * simpleselector
         * block
         * property
         * value
         */
      , 'comment': function (node, source) {
            return new Comment(node.data, source, node.lineNo);
        }
      /**
       * Everything we refuse to understand at this point or later.
       *
       * We use this constructor to keep alien data around and to be able
       * to reproduce it upon serialization.
       */
      , '__GenericAST__': function (node, source) {
            return new GenericCPSNode(node.rawData, source, node.lineNo);
        }
    };
});

define('metapolator/models/CPS/elements/Combinator',[
    './_Node'
], function(
    Parent
) {
    
    /**
     * Any Combinator in the CPS is part of a ComplexSelector.
     */
    function Combinator(value, source, lineNo) {
        Parent.call(this, source, lineNo);
        Object.defineProperties(this, {
            'type': {
                value: this._types[value] || 'unknown'
              , enumerable: true
            }
          , 'value': {
                value: value
              , enumerable: true
            }
        });
    }
    var _p = Combinator.prototype = Object.create(Parent.prototype);
    _p.constructor = Combinator;

    _p.toString = function() {
        return (this.value === ' '
             ? ' '
             : ' ' + this.value + ' '
        );
    };

    _p._types = {
        '>': 'child'
      , ' ': 'descendant'
      , '+': 'next-sibling'
      , '~': 'following-sibling'
    };

    return Combinator;
});

define('metapolator/models/CPS/elements/ComplexSelector',[
    'metapolator/errors'
  , './_Node'
  , './Combinator'
], function(
    errors
  , Parent
  , Combinator
) {
    

    var CPSError = errors.CPS;
    /**
     * A ComplexSelector is a chain of one or more compound selectors
     * separated by combinators.
     *
     * TODO: we will need to extract the meaning of the elements
     *
     * so far, we extract:
     *
     * simple selectors:
     *          universal, type, id, class, id, pseudo-class pseudo-element
     *
     *
     * A selector may be invalid, which would mark its selectorList invalid
     * (and thus all selectors in that list)
     *
     *  reasons for invalid selectors:
     *      it's empty
     *      a child of it is invalid
     *      it has two consecutive combinators
     *          only possible for > at the moment
     *          invalid: master>>penstroke
     *          valid: master>*>penstroke
     *
     * a compound selector is invalid if
     *      - it has more than one of universal or type selector
     *      - a universal or type selector occurs not as first
     */
    function ComplexSelector(value, source, lineNo) {
        Parent.call(this, source, lineNo);
        this._value = value;
        this._specificity = null;

        var i, l, item, invalid = false, message;
        if(!this._value.length) {
            invalid = true;
            message =  'A selector must not be empty';
        }
        else if(this._value[this._value.length-1] instanceof Combinator) {
                invalid = true;
                message ='The last item of a selector must not '
                                +'be a combinator, found: '
                                + this._value[this._value.length-1].value;
        } else for(i=0,l=this._value.length;i<l;i++) {
            item = value[i];
            if(item instanceof Combinator) {
                if(i === 0) {
                    invalid = true;
                    message = 'The first item in a selector must '
                                                +'not be a combinator';
                }
                else if(!(item.type in this._combinators)) {
                    invalid = true;
                    message = 'The combinator type "'+ item.type
                                                    +'" is alien to us';
                }
                // if this is a combinator and the last item in values
                // is a combinator, too, this is inavlid
                else if(this._value[this._value.length-1] instanceof Combinator) {
                    invalid = true;
                    message = ['Two subsequent combinators in a'
                                    , 'selector are not valid. Found:'
                                    , this._value[this._value.length-1].value
                                    , 'followed by:' + item.value
                                    ].join(' ');
                }
            }
            else if(item.invalid) {
               invalid = true;
               message = item.message;
            }

            if (invalid) break;
        }

        Object.defineProperties(this, {
            'selects': {
                value: !invalid
              , enumerable: true
            }
          , 'invalid': {
                value: invalid
              , enumerable: true
            }
          , 'message': {
                value: message
              , enumerable: true
            }
        });
    }

    ComplexSelector.add = function(a, b) {
        var value = a.value;
        value.push(new Combinator(' ', a.source, a.lineNo));
        Array.prototype.push.apply(value, b._value);
        return new ComplexSelector(value, a.source, a.lineNo);
    };

    var _p = ComplexSelector.prototype = Object.create(Parent.prototype);
    _p.constructor = ComplexSelector;

    _p.toString = function() {
        return this._value.join('');
    };

    _p._combinators = {
        // the child combinator
        'child' : true
      , 'descendant': true
    };

    Object.defineProperty(_p, 'value', {
        get: function() {
            // if _value is truthy return a copy of the _value array
            // if value is falsy, return its falsy value (probably undefiend)
            return this._value && this._value.slice();}
    });

    Object.defineProperty(_p, 'specificity', {
        get: function() {
            var a, b, c, i=0, specificity;
            a = b = c = 0;
            if(!this._specificity) {
                for(;i<this._value.length;i++) {
                    if(this._value[i] instanceof Combinator)
                        continue;
                    specificity = this._value[i].specificity;
                    a += specificity[0];
                    b += specificity[1];
                    c += specificity[2];
                }
                this._specificity = [a, b, c];
            }
            return this._specificity;
        }
    });

    _p.add = function(complexSelector) {
        return this.constructor.add(this, complexSelector);
    };

    return ComplexSelector;
});

define('metapolator/models/CPS/elements/SimpleSelector',[
    'metapolator/errors'
  , './_Node'
  , './GenericCPSNode'
], function(
    errors
  , Parent
  , GenericCPSNode
) {
    

    var CPSError = errors.CPS;
    /**
     * This may become an interface for enhancement via plugins.
     *
     * simple selectors:
     *          universal, type, id, class, id, pseudo-class pseudo-element
     */
    function SimpleSelector(type, name, value, source, lineNo) {
        Parent.call(this, source, lineNo);
        this._specificity = null;
        var invalid = false, message;
        if(!(type in this._supportedTypes)) {
            invalid = true;
            message = 'Type of SimpleSelector is unsupported:' + type;
        }
        else if(name === undefined) {
            invalid = true;
            message = 'Name of SimpleSelector is unkown!';
        }
        else if(type === 'pseudo-class' && name === 'i') {
            if(value === undefined || value !== value || typeof value !== 'number') {
                invalid = true;
                message = 'No valid value for pseudoclass "i": ('
                                            + typeof value +') '  + value;
            }
        }
        Object.defineProperties(this, {
            'selects': {
                value: !invalid
              , enumerable: true
            }
          , 'invalid': {
                value: invalid
              , enumerable: true
            }
          , 'message': {
                value: message
              , enumerable: true
            }
          , 'type': {
                value: type
              , enumerable: true
            }
          , 'name': {
                value: name
              , enumerable: true
            }
          , 'value': {
                value: value
              , enumerable: true
            }
        });
    }

    var _p = SimpleSelector.prototype = Object.create(Parent.prototype);
    _p.constructor = SimpleSelector;

    _p.toString = function() {
        switch(this.type) {
            case 'universal':
            case 'type':
                return this.name;
            case 'class':
                return '.'+this.name;
            case 'id':
                return '#'+this.name;
            case 'pseudo-element':
                return '::'+this.name;
            case 'pseudo-class':
                return ':' + this.name
                            + (this.value !== undefined
                                    ? '('+this.value+')'
                                    : '');
        }
    };

    _p._supportedTypes = {
        'universal': null
      , 'type': null
      , 'class': null
      , 'id': null
      , 'pseudo-class': null
      , 'pseudo-element': null
    };
    Object.defineProperty(_p, 'specificity', {
        get: function() {
            var s = this._specificity;
            if(!s) {
                var a, b, c;
                a = b = c = 0;
                switch(this.type) {
                    case 'id':
                        a = 1;
                        break;
                    case 'class':
                    case 'attribute': // unsupported at the moment
                    case 'pseudo-class':
                        b = 1;
                        break;
                    case 'type':
                    case 'pseudo-element':
                        c = 1;
                        break;
                }
                this._specificity = s = [a, b, c];
            }
            return s;
        }
    });

    return SimpleSelector;
});

define('metapolator/models/CPS/elements/CompoundSelector',[
    'metapolator/errors'
  , './_Node'
  , './GenericCPSNode'
  , './SimpleSelector'
], function(
    errors
  , Parent
  , GenericCPSNode
  , SimpleSelector
) {
    

    var CPSError = errors.CPS;

    /**
     * A CompoundSelector is a chain of one or more `SimpleSelector`s
     *
     * a compound selector is invalid if
     *      - it has more than one of universal or type selector
     *      - a universal or type selector occurs at a later than
     *        the first position
     *      - if it is empty
     *
     * simple selectors:
     *          universal, type, id, class, id, pseudo-class pseudo-element
     */
    function CompoundSelector(selectors, source, lineNo) {
        Parent.call(this, source, lineNo);
        this._specificity = undefined;

        if(selectors.length === 0)
            throw new CPSError('CompoundSelector has no SimpleSelector items');

        this._value = selectors.slice();
        if(!(this._value[0].type in {'universal': null, 'type': null})) {
            this._value.unshift(new SimpleSelector('universal', '*',
                                            undefined, source, lineNo));
            this._value[0].___implicit = true;
        }

        var i,l
          , selector
          , invalid = false
          , message
          ;
        for(i=0,l=this._value.length;i<l;i++) {
            selector = this._value[i];
            if(selector.invalid) {
                invalid = true;
                message = 'Invalid selector: ' + selector;
                break;
            }
            if(i !== 0
                    && selector.type in {'universal': null, 'type': null}) {
                invalid = true;
                message = ['Type Selector and Universal selector'
                                , 'can only be the first in a CompoundSelector'
                                , 'but found "'+ selector +'" at position:'
                                , (i+1)].join(' ');
                break;
            }
        }

        Object.defineProperties(this, {
            'selects': {
                value: !invalid
              , enumerable: true
            }
          , 'invalid': {
                value: invalid
              , enumerable: true
            }
          , 'message': {
                value: message
              , enumerable: true
            }
          , 'type': {
                // a element type name or *
                value: this._value[0].name
              , enumerable: true
            }
        });
        this._normalizedValue = undefined;
        this._normalizedName = undefined;
        this.compiled = false;
        this.matches = matchesPlaceholder;
    }

    function matchesPlaceholder(element, selectorEngine) {
        /*jshint validthis: true */
        if(selectorEngine) {
            this.compile(selectorEngine);
            return this.matches(element);
        }
        throw new CPSError('Not yet compiled, use the `compile` method '
                        + 'or supply an instance of SelectorEngine to '
                        + 'this method as a second argument');
    }

    var _p = CompoundSelector.prototype = Object.create(Parent.prototype);
    _p.constructor = CompoundSelector;

    _p.toString = function() {
        // don't serialize the first item if it's marked as implicit
        return (this._value[0] && this._value[0].___implicit
                    ? this._value.slice(1)
                    : this._value
            ).join('');
    };

    _p.compile = function(selectorEngine) {
        this.matches = selectorEngine.compileCompoundSelector(this);
        this.compiled = true;
    };

    Object.defineProperty(_p, 'value', {
        get: function() {
            // if _value is truthy return a copy of the _value array
            // if value is falsy, return its falsy value (probably undefiend)
            return this._value && this._value.slice();}
    });

    /**
     *  sort by type, then by name if type equals.
     */
    function normalize(a, b) {
        var order = {'type':0, 'universal':0, 'id':1, 'pseudo-class':2, 'class':3}
          , val = order[b.type] - order[a.type]
          ;
        return val || (a.name < b.name) ? -1 : (a.name > b.name ? 1 : 0);
    }

    Object.defineProperty(_p, 'normalizedValue', {
        get: function() {
            if(!this._normalizedValue)
                this._normalizedValue = this.value.sort(normalize);
            return this._normalizedValue.slice();
        }
    });
    Object.defineProperty(_p, 'normalizedName', {
        get: function() {
            return this._normalizedName || (this._normalizedName = this.normalizedValue.join(''));
        }
    });

    Object.defineProperty(_p, 'specificity', {
        get: function() {
            var a, b, c, i=0, specificity;
            a = b = c = 0;
            for(;i<this._value.length;i++) {
                specificity = this._value[i].specificity;
                a += specificity[0];
                b += specificity[1];
                c += specificity[2];
            }
            return [a, b, c];
        }
    });

    return CompoundSelector;
});

define('metapolator/models/CPS/parsing/selectorFactories',[
    'metapolator/errors'
  , './baseFactories'
  , 'metapolator/models/CPS/elements/Rule'
  , 'metapolator/models/CPS/elements/SelectorList'
  , 'metapolator/models/CPS/elements/ComplexSelector'
  , 'metapolator/models/CPS/elements/CompoundSelector'
  , 'metapolator/models/CPS/elements/SimpleSelector'
  , 'metapolator/models/CPS/elements/Combinator'
  , 'metapolator/models/CPS/elements/GenericCPSNode'
  , 'metapolator/models/CPS/elements/Comment'

], function (
    errors
  , baseFactories
  , Rule
  , SelectorList
  , ComplexSelector
  , CompoundSelector
  , SimpleSelector
  , Combinator
  , GenericCPSNode
  , Comment
) {
    
    var CPSError = errors.CPS;
    /**
     * Constructors OR factory functions
     * this can be both because JavaScript allows to call a factory function
     * using the new operator like in `new myfactory()`. The factory must
     * return a new object in this case.
     *
     * all constructors take the following arguments: (node, source)
     * @node: object as created by parserEngine._makeNode and augmented by
     * parserEngine
     * @source: instance of parameters/Source
     *
     * We'll use mostly factories, because the "node" we use as argument
     * is not exactly a nice interface. However, its called _nodeConstructors
     * because that implies that these functions are beeing called using
     * the `new` keyword.
     *
     * see: https://github.com/css/gonzales/blob/master/doc/AST.CSSP.en.md
     */

    // inherit from baseFactories
    var selectorFactories = Object.create(baseFactories);
    (function(factories){
        var k;
        for(k in factories) selectorFactories[k] = factories[k];
    })({
        /**
         * ruleset:
         *
         * Has a "selector" as first child and a "block" as second child.
         *
         * From the docs:
         * Consists of selector (selector) and block (a set of rules).
         */
        'ruleset': function(node, source) {
            var selectorList, parameterDict;
            if(node.children[0].type !== 'selector')
                throw new CPSError('The first child of "ruleset" is '
                + 'expected to be a "selector", but got "' + node.children[0].type +'" '
                +'" in a ruleset from: ' + source + 'line: '
                + node.lineNo
                +'.', (new Error()).stack);

            if(node.children[1].type !== 'block')
                throw new CPSError('The second child of "ruleset" is '
                + 'expected to be a "block", but got "' + node.children[1].type +'" '
                +'" in a ruleset from: ' + source + 'line: '
                + node.lineNo
                +'.', (new Error()).stack);
            selectorList = node.children[0].instance;
            parameterDict = node.children[1].instance;

            return new Rule(selectorList, parameterDict, source, node.lineNo);
        }
        // just a stub
      , 'block': function(node, source){
            /*jshint sub:true*/
            var item = baseFactories['__GenericAST__'](node, source);
            item.selects = true;
            return item;
        }
        /**
         * selector:
         *
         * A list of selectors.
         *
         * It contains 'simpleselector' and divides these by 'delim'.
         * delim is a comma in the serialization. Comments are not in here,
         * as these map to the 'simpleselector's.
         *
         * From the docs:
         * Node to store simpleselector groups.
         */
      , 'selector': function(node, source) {
            var items
              , selectorList
              ;
            items = node.children
                .filter(function(item){return item.type === 'simpleselector';})
                .map(function(item){return item.instance;});
            return new SelectorList(items, source, node.lineNo);
        }
        /**
         * simpleselector:
         *
         * An item in a list of selectors "selector".
         *
         * This has a lot different elements, also whitespace 's' AND
         * comments 'comment' etc.
         *
         * creates a ComplexSelector
         */
      , 'simpleselector': function(node, source, ruleController) {
            var elements = node.children
                    .map(function(item){return item.instance;})
              , value = []
              , i=0
              , item
              , compoundSelectorElements = null
              , isWhitespace
              ;
            for(; i<elements.length; i++) {
                item = elements[i];
                isWhitespace = (item instanceof GenericCPSNode && item.type === 's');
                if(isWhitespace && value.length === 0)
                    // skip all whitespaces at the beginning
                    continue;
                else if(item instanceof Comment)
                    // skip all comments
                    // we can get them back in if we want though
                    continue;

                if(item instanceof Combinator) {
                    // close the current simple selector
                    compoundSelectorElements = null;
                    value.push(item);
                    continue;
                }

                // may be whitespace, or a simple selector
                if(isWhitespace) {
                    // close the current simple selector
                    compoundSelectorElements = null;
                    continue;
                }

                // must be a simple selector (or invalid)
                if(compoundSelectorElements === null) {
                    // if no other combinator is already there:
                    if(value.length && !(value[value.length-1] instanceof Combinator))
                        // push a simple 'descendant' Combinator
                        // it's somehow pointless to use this._source, this._lineNo
                        // in this case. we could have remembered the source and line
                        // of the last whitespace
                        value.push(new Combinator(' ', source, node.lineNo));

                    // make a new one
                    compoundSelectorElements = [];
                    value.push(compoundSelectorElements);
                }
                compoundSelectorElements.push(item);
            }
            // build the CompoundSelectors
            for(i=0; i<value.length; i++) {
                if(value[i] instanceof Combinator)
                    continue;
                // replace directly
                value[i] = compoundSelectorFactory(value[i],
                                value[i][0]._source, value[i][0]._lineNo
                              , ruleController && ruleController.selectorEngine);
            }
            return new ComplexSelector(value, source, node.lineNo);
        }
        /**
         *
         * Combinator: +, >, ~
         * is a child of ComplexSelector
         *
         */
      , 'combinator': function (node, source) {
            return new Combinator(node.data, source, node.lineNo);
        }
    });


    function _getImplicitUniversalSelector(source, lineNo) {
        var ast = new GenericCPSNode(['ident', '*'])
          , selector = new SimpleSelector({type: 'universal', name: '*'}
                                                    , source, lineNo)
          ;
          // mark as implicit, so we can let it out when serializing again
          // this is not very 'clean' but very 'practical'
          Object.defineProperty(selector, '___implicit', {value: true});
        return selector;
    }

    /**
     * selectorEngine is optional if not present the selector will be compiled
     * lazily when used first.
     */
    function compoundSelectorFactory(elements, source, lineNo, selectorEngine) {
        var i = 0
          , selectors = []
          , cs
          ;
        for(;i<elements.length;i++) {
            if(!(elements[i] instanceof GenericCPSNode))
                throw new CPSError(['Unknown type for a simple selector:'
                                  , item.constructor.name, 'typeof:'
                                  , typeof item].join(' ')
                                  );
            selectors.push(simpleSelectorFactory(elements[i]));
        }
        cs = new CompoundSelector(selectors, source, lineNo);
        // compiling now moves the load to the parsing process
        if(selectorEngine)
            cs.compile(selectorEngine);
        return cs;
    }


    function _getSimpleSelectorType(type, name) {
        switch(type) {
          case 'ident':
            if(name === '*')
                return 'universal';
            return 'type';
          case 'clazz':
            return 'class';
          case 'shash':
            return 'id';
          case 'pseudoc':
            return 'pseudo-class';
          case 'pseudoe':
            return 'pseudo-element';
        }
        return undefined;
    }

    function _getSimpleSelectorName(element) {
        var name = name;
        if(typeof element._ast[1] === 'string') {
            name = element._ast[1];
        }
        else if(element._ast[1] instanceof Array) {
            if(element._ast[1][0] === 'ident')
                name = element._ast[1][1];
            else if(element._ast[1][0] === 'funktion'
                    && element._ast[1][1] instanceof Array
                    && element._ast[1][1][0] === 'ident')
                name = element._ast[1][1][1];
        }
        if(typeof name !== 'string' && name !== undefined)
            throw new CPSError('Can\'t find a name for SimpleSelector ('
                            + element + ')');
        return name;
    }

    function _getSimpleSelectorClassValueForIndex(element) {
        var body
          , number
          , sign
          ;
        if(element._ast[1][0] !== 'funktion'
                    || element._ast[1][2][0] !== 'functionBody')
            return;
        body = element._ast[1][2].slice(1)
                   .filter(function(item) {
                        return !(item[0] in {'s':null,'comment':null});
                    });

        sign = '+';
        if(body.length === 2 && body[0][0] === 'unary') {
            //  as the docs say: unary is either - or +
            sign = body[0][1];
            body.shift();
        }
        if(body.length === 1 && body[0][0] === 'number')
            number = parseInt(sign + body[0][1], 10);
            // if the result is NaN return undefined
            return (number === number) ? number : undefined;
    }

    function simpleSelectorFactory(element) {
        var name = _getSimpleSelectorName(element)
          , type = _getSimpleSelectorType(element.type, name)
          , value
          ;

        if(type === 'pseudo-class' && name === 'i')
            value = _getSimpleSelectorClassValueForIndex(element);
        return new SimpleSelector(type, name, value);
    }

    return selectorFactories;
});

define('metapolator/models/CPS/parsing/parseSelectorList',[
    'metapolator/errors'
  , 'gonzales/gonzales'
  , './engine'
  , './selectorFactories'
  , 'metapolator/models/CPS/elements/Rule'
  , 'metapolator/models/CPS/elements/Comment'

], function (
    errors
  , gonzales
  , parserEngine
  , selectorFactories
  , Rule
  , Comment
) {
    
    var CPSError = errors.CPS
      , CPSParserError = errors.CPSParser
      ;

    function selectorListFromString(string, sourceName, selectorEngine) {
        var ast;
        try {
            ast = gonzales.srcToCSSP(string + '{}');
        } catch(error) {
            throw new CPSParserError('Error parsing "' + string + '" as a selector. '
                + 'Message: ' + error.message);
        }
        return selectorListFromAST(ast, sourceName, selectorEngine);
    }

    function selectorListFromAST(ast, sourceName, selectorEngine) {
        var rules
          , selectorList
          , i=0
          ;
        rules = parserEngine(selectorFactories, [], ast
                                    , sourceName || 'selector parser'
                                    , {selectorEngine: selectorEngine});
        rules = rules.items;
        // search the first instance of SelectorList
        // and verify that nothing else was submitted.
        for(;i<rules.length;i++) {
            if(rules[i] instanceof Comment)
                // accept comments
                continue;
            else if(!(rules[i] instanceof Rule))
                throw new CPSParserError('The argument string described a '
                        + rules[i].constructor.name + ' but it should be a'
                        + 'SelectorList.');
            else if(selectorList !== undefined)
                throw new CPSParserError('The argument string described more than '
                    + 'a selectorlist is contained: ' + rules[i]);
            else if(rules[i].paramters)
                throw new CPSParserError('Found parameters where there should '
                            + 'be only a SelectorList: ' + rules[i].paramters);
            selectorList = rules[i].getSelectorList();
            // don't break! we want to validate the rules, if there is
            // awkward stuff in it it's better to complain, because it
            // might be a programming error.
        }
        if(!selectorList)
            throw new CPSParserError('No selector found.');
        if(!selectorList.selects)
            throw new CPSParserError('SelectorList will not select anything: '
                    + selectorList.message);
        return selectorList;
    }

    return {
        fromString: selectorListFromString
      , fromAST: selectorListFromAST
    };
});

define('metapolator/models/CPS/dataTypes/formulae/parsing/SelectorToken',[
    'metapolator/errors'
  , './_ValueToken'
  , 'metapolator/models/CPS/parsing/parseSelectorList'
], function(
    errors
  , Parent
  , parseSelectorList
) {
    

    /**
     * Literal is a string representing a CPS selector.
     * Value is a CPS/elements/SelectorList as produced by the
     * CPS/parsing/parseSelectorList module.
     *
     * FIXME: value should maybe rather be the result of query(this.selectorList)
     *
     * Raises a CPSParserError if literal can't be parsed into a selector
     *
     * selectorEngine is optional, it will cause a selector to be compiled
     * immediately, contrary to beeing compiled when first used.
     */
    function SelectorToken(literal, selectorEngine) {
        Parent.call(this, literal, 0, 0);
        this._value = parseSelectorList.fromString(this.literal, undefined, selectorEngine);
    }

    var _p = SelectorToken.prototype = Object.create(Parent.prototype);
    _p.constructor = SelectorToken;

    _p.getValue = function() {
        return this._value;
    };

    return SelectorToken;
});

define('metapolator/models/CPS/dataTypes/formulae/parsing/Stack',[
    'metapolator/errors'
  , './_ValueToken'
  , './NumberToken'
  , './StringToken'
  , './SelectorToken'
], function(
    errors
  , _ValueToken
  , NumberToken
  , StringToken
  , SelectorToken
) {
    

    var CPSFormulaError = errors.CPSFormula
      , stackCache = Object.create(null)
      ;


    function Stack(postfixStack, finalizeMethod) {
        // raises CPSFormulaError
        this._check(postfixStack);
        this._finalizeMethod = finalizeMethod;
        var sig;
        this._signature = sig = this._makeSignature(postfixStack);
        this._stack = this._unwrap(postfixStack);

        this.execute = stackCache[sig] || (stackCache[sig] = this._compile(postfixStack));
        // this.execute = this._compile();
    }

    var _p = Stack.prototype;
    _p.toString = function() {
        return this._stack.join('|');
    };

    Object.defineProperty(_p, 'items', {
        get: function(){ return this._stack.slice(); }
    });

    _p._unwrap = function(stack) {
        var result = [], i,l, token;
        for(i=0,l=stack.length;i<l;i++) {
            token = stack[i];
            result.push((token instanceof NumberToken || token instanceof StringToken
                                                      || token instanceof SelectorToken
                ? token.getValue()
                : token
                ));
        }
        return result;
    };

    _p._makeSignature = function (stack) {
        var i,l, result = [], c=0;
        for(i=0,l=stack.length;i<l;i++) {
            if(stack[i] instanceof _ValueToken)
                c++;
            else {
                if(c) {
                    result.push('c', c);
                    c = 0;
                }
                result.push('e', stack[i].consumes);
            }
        }
        if(c) result.push('c', c);
        if(this._finalizeMethod) result.push('f');
        return result.join('');
    };

    _p._makeDebugMessageStackDetails = function(stack){
        var commands = stack.slice()
         , stck = []
         , i=0
         ;
        for(;i<commands.length;i++) {
            if(commands[i] instanceof _ValueToken)
                stck.push(commands[i]);
             else {
                stck.push('[result of '+commands[i].literal + '('+stck.splice(-commands[i].consumes)+')]');
            }
        }
        return stck.join(' | ');
    };

    _p._check = function(stack) {
        var i=0, stackLen = 0;
        for(; i<stack.length;i++) {
            stackLen -= stack[i].consumes;
            if(stackLen < 0)
                throw new CPSFormulaError('Stack underflow at ('+i+') a '
                    + stack[i] + ' in ' + stack.join('|') + '. '
                    + 'This means an operator consumes more items than '
                    + 'there are on the stack.\n'
                    + 'Execution hints:\n'
                    + this._makeDebugMessageStackDetails(stack));
            stackLen += stack[i].ejects;
        }

        if(stackLen > 1)
            throw new CPSFormulaError('Stack too crowded. A stack must '
                        + 'eventually resolve to 1 item, the result. This '
                        + 'stack has still ' + stackLen + ' items.\n'
                        + 'Stack in postfix notation:\n'
                        +  stack.join(' |\n')
                        + '\nExecution hints:\n'
                        + this._makeDebugMessageStackDetails(stack));
    };

    _p._compile = function(_stack) {
        /*jshint evil:true*/
        var i, l
          , args
          , stack = []
          , resultCounter = 0
          , resultName = 'commands[0]'
          , body = [
               ''
              , 'var commands = this._stack;'
          ];
        for(i=0,l=this._stack.length;i<l;i++) {
            if(_stack[i] instanceof _ValueToken)
                stack.push('commands[' + i +']');
            else {
                args = [];
                Array.prototype.push.apply(args
                                , stack.splice(-_stack[i].consumes));
                resultName = 'r'+ (resultCounter++);
                body.push('var '+resultName+' = commands['+ i +'].execute(getAPI, ['+ args.join(',') +']);');
                stack.push(resultName);
            }
        }
        // return the last result
        if(this._finalizeMethod)
            body.push('return this._finalizeMethod(' + resultName + ', getAPI);');
        else
            body.push('return '+ resultName + ';');
        return new Function('getAPI', body.slice(1).join('\n'));
    };

    // This is replaced with a compiled version on initialisation.
    // It remains here because the algorithm is more obvious.
    _p.execute = function(getAPI) {
        var commands = this._stack.slice()
          , stack = []
          , args
          , i = 0
          , result
          , returned
          ;

        for(;i<commands.length;i++) {
            if(commands[i] instanceof _ValueToken)
                stack.push(commands[i]);
            else {
                args = [getAPI];
                Array.prototype.push.apply(args
                                , stack.splice(-commands[i].consumes));
                // commands always return only one element currently
                returned = commands[i].execute.apply(commands[i], args);
                stack.push( returned );
            }
        }

        // stack.length should be 1 at this point
        if(stack.length === 0)
            throw new CPSFormulaError('No result: stack is empty after '
                            + 'execution. ' +  this._stack.join('|'));
        if(stack.length > 1)
            throw new CPSFormulaError('Too many results, stack contains '
                            +'more than one item after execution: '
                            + this._stack.join('|'));

        result = stack.pop();
        return (this._finalizeMethod
            ?  this._finalizeMethod(result, getAPI)
            : result
        );
    };

    return Stack;
});

define('metapolator/models/CPS/dataTypes/formulae/parsing/BracketToken',[
    'metapolator/errors'
  , './_ValueToken'
], function(
    errors
  , Parent
) {
    

    /**
     * Literal is a string, one of '(' , ')', '[', ']'
     * There is no value, the parser interpretes this kind of token
     * by using its literal
     */
    function BracketToken(literal) {
        Parent.call(this, literal, 0, 0);

        var counterparts = {
                '(': ')'
              , ')': '('
              , '[': ']'
              , ']': '['
        };

        Object.defineProperty(this, 'opening', {
            value: '(['.indexOf(this.literal) !== -1
          , enumerable: true
        });

        Object.defineProperty(this, 'closing', {
            value: !this.opening
          , enumerable: true
        });

        Object.defineProperty(this, 'counterpart', {
            value: counterparts[this.literal]
          , enumerable: true
        });
    }

    var _p = BracketToken.prototype = Object.create(Parent.prototype);
    _p.constructor = BracketToken;

    _p.matches = function(val) {
        return val === this.counterpart;
    };


    return BracketToken;
});

define('metapolator/models/CPS/dataTypes/formulae/parsing/Parser',[
    'metapolator/errors'
  , './_ValueToken'
  , './OperatorToken'
  , './Stack'
  , './BracketToken'
  , './StringToken'
  , './SelectorToken'
  , './NumberToken'
  , './NameToken'
], function(
    errors
  , _ValueToken
  , OperatorToken
  , Stack
  , BracketToken
  , StringToken
  , SelectorToken
  , NumberToken
  , NameToken
) {
    

    var CPSFormulaError = errors.CPSFormula
      , KeyError = errors.Key
      ;

    /**
     * Constructor for a CPS formulae Parser. This takes instances of
     * OperatorToken as Input.
     */
    function Parser(/* operators */) {
        this._operators = this._createOperatorsDict(
                Array.prototype.slice.call(arguments));
        this._operatorsByPrecedence = this._createPrecedenceLookup(
                                                        this._operators);

        this._operatorsByLength = this._createLengthLookup(
                                                        this._operators);

        this._bracketOperators = {};
        this._negateOperator = undefined;
        this._finalizeMethod = undefined;
    }

    var _p = Parser.prototype
        /**
         * Test if a string starts like a number. This detects also
         * negative numbers.
         * R_number.exec(string) !== null
         */
      , R_number = /^(\-?((\d*\.\d+)|(\d+(\.)?))([eE][+\-]?\d+)?)/
        //  Test if a string starts like a name
      , R_name = /^[0-9A-Za-z_]+/
      ;

    _p._createOperatorsDict = function(operators) {
        var i = 0
          , result = {}
          ;
        for(;i<operators.length;i++) {
            if(operators[i].literal in result)
                throw new CPSFormulaError('An operator with the literal "'
                                + operators[i].literal +'" is defined at '
                                + 'least twice, but it must be unique!');
            if(R_number.exec(operators[i].literal) !== null)
                throw new CPSFormulaError('The operator with the literal "'
                                + operators[i].literal +'" starts like a '
                                + 'number literal. This is forbidden.');
            result[operators[i].literal] = operators[i];
        }
        return result;
    };

    /**
     * Creates an array like so:
     * [
     *      {'*': operatorInstance, '/': operatorInstance},
     *      {'+': operatorInstance, '-': operatorInstance},
     * ]
     *
     * The infixToPostfix method uses this to resolve the operators in
     * the right order. This means the first item in the result of this
     * method has the highest precedence, and all its operators are
     * resolved first.
     */
    _p._createPrecedenceLookup = function(operators) {
        var temp = {}
          , k
          , ordered = []
          ;
        for(k in operators) {
            if(temp[operators[k].precedence] === undefined) {
                temp[operators[k].precedence] = {};
                ordered.push(operators[k].precedence);
            }
            temp[operators[k].precedence][k] = operators[k];
        }
        ordered.sort(function(a, b) { return a-b; });
        // highest precedence first
        ordered.reverse();
        return ordered.map(function(precedence){ return temp[precedence]; });
    };

    /**
     * returns an object with the keys "splitting" and "notSplitting"
     * both keys contain an array of objects.
     * The objects are key value pairs of operatorLiteral: operator
     * The operators in one object have all the same length.
     * The arrays are sorted in the way that the objects with the longest
     * operatorLiterals appear first;
     *
     *  {
     *      splitting: [ operator literals by length lookup ]
     *      notSplitting: [ operator literals by length lookup ]
     *  }
     *
     * the array for the "operator literals by length lookup":
     * // ordered by operator.literal.length, longest first
     * [
     *      // all literalName in these objects have the same length
     *      {literalName_A: operator, literalName_B: operator}
     *    , {literalN_A: operator, literalN_B: operator}
     *      ...
     * ]
     */
    _p._createLengthLookup = function(operators) {
        var _get = function(k) {return this[k];}
          , k
          , _temp
          , temp = {
                splitting: {}
              , notSplitting: {}
            }
          , result = {}
        ;

        // put everything in the right temp container
        for(k in operators) {
            _temp = operators[k].splitting
                ? temp.splitting
                : temp.notSplitting
                ;
            if(_temp[k.length] === undefined)
                _temp[k.length] = {};
            _temp[k.length][k] = operators[k];
        }

        // sort and maintain order by returning arrays of operator dicts
        for(k in temp)
            result[k] = Object.keys(temp[k])
                              // sort by "k.length" keys
                              .sort()
                              // longest first
                              .reverse()
                              // return the operator dicts
                              .map(_get, temp[k]);
        return result;
    };

    /**
     * The method is passed from Parser.parse to new Stack and then run in
     * Stack.execute, with the result of the stack execution and getAPI as
     * arguments.
     */
    _p.setFinalizeMethod = function(method) {
        this._finalizeMethod = method;
    };

    _p.setBracketOperator = function(bracketLiteral, operatorLiteral) {
        if(!(operatorLiteral in this._operators))
            throw new KeyError('No operator found for literal: '
                                                        + operatorLiteral);

        this._bracketOperators[bracketLiteral] = operatorLiteral;
    };

    _p.getBracketOperator = function(bracketLiteral) {
        if(bracketLiteral in this._bracketOperators)
            return this._operators[this._bracketOperators[bracketLiteral]];

        throw new KeyError('No bracket operator found for literal: '
                                                        + bracketLiteral);
    };

    _p.setNegateOperator = function(negateLiteral, operatorLiteral) {
        if(!(operatorLiteral in this._operators))
            throw new KeyError('No operator found for literal: '
                                                        + operatorLiteral);
        this._negateOperator = [negateLiteral, operatorLiteral];
    };


    /**
     * Unwrap all elements of nested arrays into one flat array. Keep
     * the depth-first order intact.
     */
    function _flatten(tokens) {
        var result = []
          , item
          ;
        while(!!(item = tokens.shift())) {
            if(item instanceof Array)
                Array.prototype.unshift.apply(tokens, item);
            else
                result.push(item);
        }
        return result;
    }

    /**
     * test if string starts with the operator.literal of one of the
     * operators in the operators list.
     *
     * The operators list has the following structure (to avoid a linear search)
     *
     * // ordered by operator.literal.length
     * [
     *      // all literalName keys in here have the same length
     *      {literalName: operator}
     *      ...
     *  }
     * ]
     *
     *
     */
    function _testOperators(operators, string, index) {
        var i=0, k, search;
        for(;i<operators.length;i++) {
            // get the first key
            k = null;
            for(k in operators[i])
                break;
            if(k === null)
                continue;
            // cut out the right length from string
            search = string.substr(index, k.length);
            if(operators[i].hasOwnProperty(search))
                // search is a key in operators
                return operators[i][search];
        }
        return false;
    }

    /**
     * Test for all NOT splitting operators, longest first.
     */
    _p._testNotSplittingOperators = function(string, index) {
        return _testOperators(this._operatorsByLength.notSplitting
                                                        , string, index);
    };

    /**
     * Test for all splitting operators, longest first.
     */
    _p._testSplittingOperators = function(string, index) {
        return _testOperators(this._operatorsByLength.splitting
                                                        , string, index);
    };


    /**
     * Tokenize into the following tokens:
     *
     * number literals: anything that ufojs/main.isFloatString accepts
     *      1 .3 -1.2 1.2e3  3E3 0.123456E-3 etc..
     *
     * selector literals: anything between S" AND "  S"master#bold > glyph:i(3)"
     *      we keep the quotes, because some characters that can appear
     *      in selectors could cause problems with our CSS/CPS parser in
     *      the context of a parameter value
     * string literals: anything between " AND "
     * parenthesis: ( and )
     * Square brackets [ and ]  <= will essentially behave like a stack ()
     *              but the resulting value will be used as key to get a
     *              value from the previous value in the stack
     *              So, this resolves to a similar thing like the colon
     *              operator. but the colon operator will use the literal
     *              of a NameValue AND thus require a NameValue
     *              we may get rid of the colon operator but then find us
     *              typing a lot of [" AND "] combinations ...
     *
     * names/identifier: essentially every token that is not something else ...
     *            maybe it is wise to identify a set of legal characters,
     *            like 0-9A-Za-z_ this could save space for new additions
     *            also, this eases parsing
     *            name can't begin with numbers, because of the splitting
     *            behavior of numbers at the moment.
     *
     * operators/symbols: identifier that are keys in this._operators
     *
     * special is the "negate" operator, which will be inserted on some
     * occasions where - appears. But this is not done in this context
     * the parser will do so.
     *
     * splitting is done by:
     *  ' ' space
     *  $" " selector literal
     *  " " string literal
     *  \n newline
     *  \r carriage return
     *  \t tab
     *  all operators where operator.splits === true
     *          if it doesn't split it can be part of a 'name'
     *
     * special in terms of splitting is the . operator
     *      it splits, but only if it is not part of a number literal!
     *
     *
     * in the end, we expect a list of:
     *
     * - number values from number literals
     * - selector values from selector literals
     * - string values from string literals
     * - brackets: one of these four at a time ( ) [ ]
     * - operators
     * - names
     *
     *
     * selectorEngine is optional, it will cause a selector to be compiled
     * immediately, contrary to beeing compiled when first used.
     */
    _p.tokenize = function(string, selectorEngine) {
        var i=0, j, tokenEnd
          , tokens = []
          , reResult
          , splitExpected
          , foundOperator
          ;
        while(i<string.length) {
            if(' \n\r\t'.indexOf(string[i]) !== -1) {
                // stuff that splits but is not reported (whitespace)
                i++;
                splitExpected = false; // a splitting token was found
                continue;
            }

            // brackets are splitting
            if('()[]'.indexOf(string[i]) !== -1) {
                tokens.push(new BracketToken(string[i]));
                i++;
                splitExpected = false; // a splitting token was found
                continue;
            }

            // string literals are splitting
            if(string[i] === '"') {
                tokenEnd = string.indexOf('"', i+1);
                if(tokenEnd === -1)
                    throw new CPSFormulaError('A closing double quote is '
                        +' missing for an opening string literal: "');
                tokens.push(new StringToken(string.substring(i+1, tokenEnd)));
                i = tokenEnd+1;
                splitExpected = false; // a splitting token was found
                continue;
            }

            // selector literals are splitting
            if(string[i] === 'S' && string[i+1] === '"') {
                tokenEnd = string.indexOf('"', i+2);
                if(tokenEnd === -1)
                    throw new CPSFormulaError('A closing double quote is '
                        +' missing for an opening selector literal S" ...in: '
                        + string.substr(i));
                tokens.push(new SelectorToken(string.substring(i+2, tokenEnd), selectorEngine));
                i = tokenEnd+1;
                splitExpected = false; // a splitting token was found
                continue;
            }

            // number literals are splitting, thus we can parse negative
            // numbers. (maybe they must not be splitting, but they
            // must be parsed before the splitting operators?)
            // FIXME: I'm not sure if I like this rather hackish workaround.
            // Instead of making numbers splitting, we could maybe have
            // a more robust way to detect the "negate" operator, unfortunately
            // this: "Vector 12 -8" makes it really hard to do so. It can
            // read as "Vector 12 subtract 8" or "Vector 12 negate 8" without
            // having splitting numbers the former applies but the latter
            // is meant.
            // Also, names can't begin with numbers anymore, because of this
            // behavior, however, this quite common in other programming
            // languages as well.
            // The biggest downside of this behavior is that:
            // "1-2" parses as `1|-2` and "1 - 2" parses as
            // `1|subtract|2` which will become confusing at some point.
            string = string.substring(i);
            i = 0;
            if((reResult = R_number.exec(string)) !== null) {
                tokens.push(new NumberToken(reResult[0]));
                i = reResult[0].length;
                splitExpected = false; // a splitting token was found
                continue;
            }

            // test for all splitting operators, length first
            if(!!(foundOperator = this._testSplittingOperators(string, i))) {
                tokens.push(foundOperator);
                i += foundOperator.literal.length;
                splitExpected = false; // a splitting token was found
                continue;
            }

            // END OF SPLITTING TOKENS

            // The last found token was expecting as next token a splitting
            // token, because it was not splitting by itself.
            // A splitting token was not found.
            if(splitExpected === true)
                throw new CPSFormulaError('A splitting token was expected '
                                + 'after: '+ tokens[tokens.length-1])+ ' '
                                + 'but it was not found in: '
                                + string.substr(i);

            // From here we expect to find a not splitting token
            // the token after that must be splitting
            // if we don't find anything a CPSFormulaError is thrown
            splitExpected = true;

            // prepare for RegEx.exec searches
            // the string must be truncated to the current index
            // because RegEx.exec has no offset parameter like indexOf
            string = string.substr(i);
            i=0;

            // name literals are not splitting
            if((reResult = R_name.exec(string)) !== null) {
                if(reResult[0] === 'Infinity')
                    tokens.push(new NumberToken(reResult[0]));
                else if(this._operators[reResult[0]] && !this._operators[reResult[0]].splitting)
                    // could also be a not splitting operator
                    tokens.push(this._operators[reResult[0]]);
                else
                    tokens.push(new NameToken(reResult[0]));
                i += reResult[0].length;
                continue;
            }

            // test for all NOT splitting operators, length first
            if(!!(foundOperator = this._testNotSplittingOperators(string, i))) {
                tokens.push(foundOperator);
                i += foundOperator.literal.length;
                continue;
            }

            // not recognized as token!
            throw new CPSFormulaError('Can\'t find the next token in the '
                                    + 'string: ' + string);
        }
        return tokens;
    };

    _p._resolveBrackets = function(tokens) {
        var i = 0
          , openStack = []
          , start
          , result = []
          ;
        for(;i<tokens.length;i++) {
            if(!(tokens[i] instanceof BracketToken)) {
                if(openStack.length === 0)
                    // record this token, it is not inside of any brackets
                    result.push(tokens[i]);
            }
            // it is a bracket
            else if(tokens[i].opening) {
                if(openStack.length === 0)
                    start = i+1;
                openStack.push(tokens[i]);
            }
            else { // tokens[i].closing === true
                if(openStack.length === 0
                        || !openStack[openStack.length-1].matches(tokens[i].literal))
                    throw new CPSFormulaError('A closing bracket appeared '
                        + '"'+ tokens[i].literal +'" but a matching opening '
                        + ' bracket is missing before.');
                // the closing bracket matches
                else if(openStack.length === 1) {
                    // this closes the current outermost bracket
                    try {
                        // If an operator is registered for this bracket,
                        // we insert it before the bracket.
                        // This is actually used if this is a [] context
                        // We insert a getter operator then, that will
                        // consume the content of the [] stack and uses
                        // its value as a key to read from in the previous
                        // value like: myValue["myKey"]
                        result.push(this.getBracketOperator(openStack[0].literal));
                    }
                    catch(error) {
                        if(!(error instanceof KeyError))
                            throw error;
                        // else: pass. No operator was registered for this
                        // kind of bracket.
                    }


                    // call this.infixToPostfix recursively...
                    // this.infixToPostfix calls this method
                    result.push(this.infixToPostfix(tokens.slice(start, i)));
                }
                openStack.pop();
            }
        }
        if(openStack.length)
            throw new CPSFormulaError(openStack.length + ' '
                    + (openStack.length === 1 ? 'bracket is'
                                                : 'brackets are' ) + ' '
                    + 'missing for the opened: '
                    + openStack.map(function(item){ return item.literal; })
                               .join(', '));
        return result;
    };


    /**
     * Take the tokens where the calculations are in a infix notation and
     * return postfix or Reverse Polish notation:
     * This means we go from 2 + 3 to 2 3 +. The operator follows all
     * of its operand. This is easy to calculate at the end, and we get
     * rid of the Parenthesis. See ./Stack.execute for execution of the
     * stack.
     *
     * This works as far as my tests went, but it could be more efficiently
     * implemented (using the "Dijkstra shunting yard algorithm"?)
     *
     * The algorithm uses one recursive call to eliminate parentheses
     * and multiple passes to solve all operators in order of precedence.
     */
    _p.infixToPostfix = function infixToPostfix(tokensArg) {
        var operators = this._operatorsByPrecedence
          , tokens
          , j=0
          , i
          , k
          , startPre
          , startPost
          , preConsumes
          , postConsumes
          , endPost
          , operation
          ;
        // replace - with negate when looks like this was the intention
        if(this._negateOperator) {
            for(i=0;i<tokensArg.length;i++) {
                if(tokensArg[i] instanceof OperatorToken
                        // usually we use - to negate something
                        && tokensArg[i].literal === this._negateOperator[0]
                        // if the first operator is a subtract operator
                        // or if the operator before the subtract operator
                        // is any operator, then this is a negate operator
                        && (i===0 || tokensArg[i-1] instanceof OperatorToken)) {
                    tokensArg[i] = this._operators[this._negateOperator[1]];
                }
            }
        }

        // find brackets and call this method recursively
        tokens = this._resolveBrackets(tokensArg);

        // convert all operators to postfix notation
        // operator precedence defines the order of the conversion

        for(;j<operators.length;j++) {
            for(i=0;i<tokens.length;i++) {
                // Array and Value don't change the stack, only OperatorToken
                // does. Thus Array and Value stay where they are until
                // they are consumed by an Operator.
                if(!(tokens[i] instanceof OperatorToken))
                    continue;
                // tokens[i] is an Operator

                // only apply operators with the correct precedence
                if(!(tokens[i].literal in operators[j]))
                    continue;

                // If preConsumes is Infinity, the operator consumes
                // anything that is on the stack before its position.
                // This is useful for some kind of list creation.
                preConsumes = tokens[i].preConsumes === Infinity
                    ? i
                    : tokens[i].preConsumes
                    ;

                startPre = i - preConsumes;
                if(startPre < 0)
                    throw new CPSFormulaError('Stack underflow at a "'+tokens[i]+'" '
                                    + 'operator, which pre-consumes more items '
                                    + 'than there are on the stack');

                // skip the operator itself
                startPost = i+1;

                // If postConsumes is Infinity, the operator consumes
                // anything that is on the stack after its position.
                // This is useful for some kind of list creation.
                postConsumes = tokens[i].postConsumes === Infinity
                    ? tokens.length - startPost
                    : tokens[i].postConsumes
                    ;

                endPost = startPost + postConsumes;
                if(endPost > tokens.length)
                    throw new CPSFormulaError('Stack underflow at a "'+tokens[i]+'" '
                                    + 'operator, which post-consumes more items '
                                    + 'than there are on the stack');

                operation = tokens.slice(startPre, i)
                                  .concat(tokens.slice(startPost, endPost));

                // check if everything looks alright
                for(k=0; k<operation.length; k++)
                    if(!(operation[k] instanceof _ValueToken)
                                    && !(operation[k] instanceof Array))
                        throw new CPSFormulaError('Malformed stack at a "'
                            + tokens[i].literal+'" operator, which consumes '
                            + (operation[k] instanceof OperatorToken
                                ? 'another operator: "' + operation[k].literal + '"'
                                : 'something that is not a ValueToken: "'
                                    + operation[k] + '" typeof: '
                                    + typeof operation[k]
                                    + ' '+operation[k].constructor.name));
                // add the operator
                if(tokens[i].preConsumes === Infinity
                                || tokens[i].postConsumes === Infinity)
                    operation.push(
                        tokens[i].fixedConsumptionFactory(
                                            preConsumes, postConsumes));
                else
                    operation.push(tokens[i]);

                // change in place, the operation becomes one array
                // and will be handled as a single value in later
                // repetitions.
                tokens.splice(startPre, operation.length, operation);
                i = startPre;
            }
        }
        return _flatten(tokens);
    };

    /**
     * selectorEngine is optional, it will cause a selector to be compiled
     * immediately, contrary to beeing compiled when first used.
     */
    _p.parse = function(string, selectorEngine) {
        var tokens = this.tokenize(string, selectorEngine);
        tokens = this.infixToPostfix(tokens);
        return new Stack(tokens, this._finalizeMethod);
    };

    return Parser;
});

/* Shared math functions */
define('metapolator/math/utils',[], function() {
    

    /**
     * Normalize `angle` given in radians between 0 and 2*PI
     */
    function normalizeAngle(angle) {
        var result = angle % (2*Math.PI);
        if(result < 0)
            result += (2*Math.PI);
        return result;
    }

    return {
        normalizeAngle: normalizeAngle
    };
});

define('metapolator/math/hobby',[
    './Vector'
  , './utils'
], function(
    Vector
  , utils
) {
    

    /**
     * All points in this module are expected instances of
     * metapolator/math/Vector (complex numbers)
     */

    var normalizeAngle = utils.normalizeAngle;

    function hobby(theta, phi) {
        var st = Math.sin(theta)
          , ct = Math.cos(theta)
          , sp = Math.sin(phi)
          , cp = Math.cos(phi)
          ;
        return (
        (2 + Math.sqrt(2) * (st-1/16*sp) * (sp-1/16*st) * (ct-cp)) /
        (3 * (1 + 0.5*(Math.sqrt(5)-1)* ct + 0.5*(3-Math.sqrt(5))*cp))
        );
    }

    /**
     * Returns two distances from the respective on-curve points to their
     * control points on the given curve segment.
     *
     * dir0 and dir1 are the tangent directions as radians or instances
     * of Vector.
     *
     * alpha and beta are the tension parameters. The tensions values alpha
     * and beta have no influence on the resulting distance of each other.
     *
     * Tensions are bigger the closer they are to their on-curve points.
     * When using Infinity as a tension the returned magnitude is 0;
     * When using 0 as a tension the returned magnitude is Infinity.
     *    When the tension is 0 and z0 equals z1 its resulting
     *    magnitude is NaN; in this case it is short circuited into
     *    returning Infinity, which is OK as a behavior; because it obeys
     *    the rule above, also it's compatible with the reverse operation
     *    magnitude2tension.
     */
    function _tension2magnitude(z0, dir0, alpha, beta, dir1, z1) {
        var diff_z1z0 = z1['-'](z0)
          , angle_z1z0 = diff_z1z0.angle()
          , magnitude_z1z0 = diff_z1z0.magnitude()
            // calculating this using the polar form helps us by not
            // getting into trouble when z1['-'](z0) is <Vector 0, 0>
            // because that would cause a division by 0 when calculating
            // theta and pi using cartesian arithmetic.
          , theta = normalizeAngle(dir0 - angle_z1z0)
          , phi = normalizeAngle(angle_z1z0 - dir1)
          , u, v;

        if(alpha !== undefined)
            u = (magnitude_z1z0 === 0 && (alpha === 0 || alpha === Infinity))
                ? (alpha === 0 ? Infinity : 0)
                : magnitude_z1z0 * hobby(theta, phi) / alpha
                ;
        if(beta !== undefined)
            v = (magnitude_z1z0 === 0 && (beta === 0 || beta === Infinity))
                ? (beta === 0 ? Infinity : 0)
                : magnitude_z1z0 * hobby(phi, theta) / beta
                ;
        return [u, v];
    }

    function tension2magnitude(z0, dir0, alpha, beta, dir1, z1) {
        var uv = _tension2magnitude(z0, dir0, alpha, beta, dir1, z1);
        if(uv[0] === undefined) uv[0] = NaN;
        if(uv[1] === undefined) uv[1] = NaN;
        return uv;
    }

    function tension2magnitudeOut(z0, dir0, alpha, dir1, z1) {
        return _tension2magnitude(z0, dir0, alpha, undefined, dir1, z1)[0];
    }

    function tension2magnitudeIn(z0, dir0, beta, dir1, z1) {
        return _tension2magnitude(z0, dir0, undefined, beta, dir1, z1)[1];
    }

    /**
     * dir0 and dir1 are radians
     * alpha, beta are the magnitudes
     *
     * Also
     * [Infinity, Infinity] instead of [NaN, NaN] when the magnitudes are 0
     * And it can still return a tension for one control when the other
     * control is 0
     */
    function _magnitude2tension(z0, dir0, alpha, beta, dir1, z1) {
        var uv, u, v
            // 1 is the default tension
          , _alpha = alpha === 0 || alpha === undefined ? undefined : 1
          , _beta = beta === 0 || beta === undefined ? undefined : 1
          ;
        if(_alpha || _beta)
            uv = _tension2control(z0, dir0, _alpha, _beta, dir1, z1);

        if(alpha === 0)
            u = Infinity;
        else if (alpha !== undefined)
            u = uv[0]['-'](z0).magnitude()/alpha;

        if(beta === 0)
            v = Infinity;
        else if (beta !== undefined)
            v = uv[1]['-'](z1).magnitude()/beta;

        return[u, v];
    }

    function magnitude2tension(z0, dir0, alpha, beta, dir1, z1) {
        var uv = _magnitude2tension(z0, dir0, alpha, beta, dir1, z1);
        if(uv[0] === undefined) uv[0] = NaN;
        if(uv[1] === undefined) uv[1] = NaN;
        return uv;
    }

    function magnitude2tensionOut(z0, dir0, alpha, dir1, z1) {
        return _magnitude2tension(z0, dir0, alpha, undefined, dir1, z1)[0];
    }

    function magnitude2tensionIn(z0, dir0, beta, dir1, z1) {
        return _magnitude2tension(z0, dir0, undefined, beta, dir1, z1)[1];
    }

    /**
     * returns vectors for the absolute positions of the control points
     * used to be called hobby2cubic
     */
    function _tension2control(z0, dir0, alpha, beta, dir1, z1) {
        var d0, d1, uv, u, v;

        if(dir0 instanceof Vector || dir1 instanceof Vector)
            console.warn('It is deprecated to use Vectors for dir0 or dir1');

        d0 = (dir0 instanceof Vector) ? dir0.arg() : dir0;
        d1 = (dir1 instanceof Vector) ? dir1.arg() : dir1;

        uv = _tension2magnitude(z0, d0, alpha, beta, d1, z1);
        if(uv[0] !== undefined)
            u = Vector.fromPolar(uv[0], d0)['+'](z0);
        if(uv[1] !== undefined)
            v = z1['-'](Vector.fromPolar(uv[1], d1));
        return [u, v];
    }

    function tension2control(z0, dir0, alpha, beta, dir1, z1) {
        var uv = _tension2control(z0, dir0, alpha, beta, dir1, z1);
        if(uv[0] === undefined) uv[0] = new Vector(NaN, NaN);
        if(uv[1] === undefined) uv[1] = new Vector(NaN, NaN);
        return uv;
    }

    function tension2controlOut (z0, dir0, alpha, dir1, z1) {
        return tension2control(z0, dir0, alpha, undefined, dir1, z1)[0];
    }

    function tension2controlIn (z0, dir0, beta, dir1, z1) {
        return tension2control(z0, dir0, undefined, beta, dir1, z1)[1];
    }

    /**
     * If you need both tension values, this version is more efficient
     * than calling posttension and pretension.
     */
    function control2tension(p0, p1, p2, p3) {
        var diffp0p1 = p1['-'](p0)
          , diffp3p2 = p3['-'](p2)
          , dir0 = diffp0p1.angle()
          , dir1 = diffp3p2.angle()
          , alpha = diffp0p1.magnitude()
          , beta = diffp3p2.magnitude()
          ;
        return _magnitude2tension(p0, dir0, alpha, beta, dir1, p3);
    }
    /**
     * returns the tension for the first on-curve point.
     */
    function control2tensionOut(p0, p1, p2, p3) {
        var diffp0p1 = p1['-'](p0)
          , diffp3p2 = p3['-'](p2)
          , dir0 = diffp0p1.angle()
          , dir1 = diffp3p2.magnitude()
          , alpha = diffp0p1.magnitude()
          ;
        return magnitude2tensionOut(p1, dir0, alpha, dir1, p3);
    }
    /**
     * returns the tension for the second on-curve point
     */
    function control2tensionIn(p0, p1, p2, p3) {
        var diffp0p1 = p1['-'](p0)
          , diffp3p2 = p3['-'](p2)
          , dir0 = diffp0p1.angle()
          , dir1 = diffp3p2.magnitude()
          , beta = diffp3p2.magnitude()
          ;
        return magnitude2tensionIn(p1, dir0, beta, dir1, p3);
    }

    return {
        hobby: hobby

      , tension2magnitude: tension2magnitude
      , tension2magnitudeOut: tension2magnitudeOut
      , tension2magnitudeIn: tension2magnitudeIn

      , magnitude2tension: magnitude2tension
      , magnitude2tensionOut: magnitude2tensionOut
      , magnitude2tensionIn: magnitude2tensionIn

      , tension2control: tension2control
      , hobby2cubic: tension2control // DEPRECATED
      , tension2controlOut: tension2controlOut
      , tension2controlIn: tension2controlIn

      , control2tension: control2tension
      , tensions: control2tension // DEPRECATED
      , control2tensionOut: control2tensionOut
      , posttension: control2tensionOut // DEPRECATED
      , control2tensionIn: control2tensionIn
      , pretension: control2tensionIn // DEPRECATED
    };
});

define('metapolator/models/CPS/dataTypes/formulae/formulaEngine',[
    'metapolator/errors'
  , './parsing/Parser'
  , './parsing/OperatorToken'
  , './parsing/NameToken'
  , './parsing/SelectorToken'
  , './parsing/StringToken'
  , './parsing/NumberToken'
  , './parsing/_Token'
  , 'metapolator/models/CPS/elements/SelectorList'
  , 'metapolator/models/MOM/_Node'
  , 'ufojs/tools/misc/transform'
  , 'metapolator/math/Vector'
  , 'metapolator/math/hobby'
  , 'metapolator/math/utils'
], function(
    errors
  , Parser
  , Operator
  , NameToken
  , SelectorToken
  , StringToken
  , NumberToken
  , _Token
  , SelectorList
  , _MOMNode
  , transform
  , Vector
  , hobby
  , mathUtils
) {
    

    var ValueError = errors.Value
      , CPSFormulaError = errors.CPSFormula
      , Transformation = transform.Transform
      , engine
      ;

    /**
     * This defines the operators that are usable in CPS-formulae, thus
     * the better part of the language definition can be found in here.
     * However, some rather specific behaviors are still buried in the
     * Parser implementation
     *
     * see the reference of new Operator for a description of its arguments.
     *
     * usage: engine.parse(CPSParameterValueString)
     */
    engine = new Parser(
        /**
         * returns an Array of everything that is on the current stack
         *
         * May become useful in the future, but for now it's more on the
         * experimentation side. Getters should already work on arrays, so
         * it may be a way to store values in an @dictionary parameter and
         * index numbers.
         */
        new Operator('List', false, -Infinity, 0, Infinity, function(/*args, ...*/) {
            return Array.prototype.slice.call(arguments);
        })
        /**
         * Returns a generic Value, could be virtually anything
         *
         * used in a context like this
         * item['key']
         * which is translated to
         * item __get__ 'key'
         *
         * which should translate roughly to the javascript:
         * item['key'] or item.get('key'), depending on the nature
         * of item and the details of the implementation
         */
      , new Operator('__get__', false, Infinity, 1, 1, [
            ['*getAPI*', NameToken, 'string', function(getAPI, name, key) {
                var item = getAPI.get(name.getValue());
                return getAPI.genericGetter(item, key);
            }]
            // FIXME: I think a signature of
            // '*unboxed+getAPI*' ,'*anything*', '*anything*'
            // would do the same trick, also, the last operator implementation
            // here: '*unboxed+getAPI*','*anything*', ['number', 'string'] could be removed as well?
            // maybe, also the first... ????
          , ['*getAPI*', NameToken, NameToken, function(getAPI, name1, name2) {
                var item = getAPI.get(name1.getValue())
                  , key = getAPI.get(name2.getValue())
                  ;
                return getAPI.genericGetter(item, key);
            }]
            // value: this['parent'][S"point.top"]
          , ['*unboxed+getAPI*', _MOMNode, SelectorList, function(getAPI, node, selector) {
                // internally does node.query(selector); but with dependency subscription
                var result = getAPI.query(node, selector);
                if(!result)
                    throw new CPSFormulaError('Not found: an element for '
                                        + selector + ' '
                                        + 'in ' + node.particulars
                                    );
                return result;
            }]
          , ['*unboxed+getAPI*','*anything*', ['number', 'string'], function(getAPI, item, key) {
                return getAPI.genericGetter(item, key);
            }]
        ])
        /**
         * Returns a generic Value, could be virtually anything
         * similar to __get__
         *
         * used like this:
         * item:name
         *
         * name must be a name token, its value is used to get a propety
         * of item.
         * in javascript it does roughly the following:
         * var key = name.getValue()
         * return item[key]
         */
      , new Operator(':', true, Infinity, 1, 1, [
            ['*getAPI*', NameToken, NameToken, function(getAPI, name, key) {
                var item = getAPI.get(name.getValue());
                if(!item)
                    console.log('item:', item, 'from', '"'+name.getValue()+'"', 'key:', '"'+key.getValue()+'"');
                return getAPI.genericGetter(item, key.getValue());
            }]
          , ['*getAPI*', SelectorList, NameToken, function(getAPI, selector, key) {
                // SelectorList selects from global scope, aka multivers
                // var item = getAPI.get('this').multivers.query(selector);
                // FIXME: do instead
                // var item = getAPI.query(getAPI.get('this').multivers, selector); // internally node.query(selector); but with subscription

                // is some form of subscription needed for node.multivers???
                // maybe in the future, we will allow transports from one
                // multivers to another, then host.multivers can change
                var host = getAPI.get('this')
                  , node = getAPI.genericGetter(host, 'multivers')
                  , item = getAPI.query(node, selector)
                  ;


                if(!item)
                    throw new CPSFormulaError('Not found: an element for '
                                                        + selector);
                return getAPI.genericGetter(item, key.getValue());
            }]
          , ['*getAPI*', '*anything*', NameToken, function(getAPI, item, key) {
                return getAPI.genericGetter(item, key.getValue());
            }]
        ])
        /**
         * When a value is negated using the minus sign, this operator is
         * inserted instead of the minus sign. It can also be used directly.
         *
         * The parser should detect cases where the minus sign is not a
         * subtraction, but a negation:
         *
         * -5 => negate 5
         * -(5 + name) => negate (5 + name)
         * 5 + -name => 5 + negate name
         * 5 + - name => 5 + negate name
         * name * - 5 => name * negate name
         *
         */
      , new Operator('negate', false, 60, 0, 1, [
            // 'number' as an argument is not needed nor happening
            // because something like -123 will be parsed as a negative
            // number directly. This is because "Vector 12 -8" would
            // otherwise be tokenized as "Vector 12 subtract 8", because
            // we have no other indication of splitting.
            // the operator is left in place, so this: --123 could be done
            // and would result in `negate -123`
            ['number', function(a){ return -a; }]
          , [Vector, function(a){ return a.negate();}]
          , [Transformation, function(transformation){ return transformation.inverse();}]
        ])
          /**
           * add
           */
      , new Operator('+', true, 10, 1, 1, [
            ['number' , 'number', function(a, b){ return a + b; }]
          , ['string' , 'string', function(a, b){ return a + b; }]
          , [Array , Array, function(a, b){ return a.concat(b); }]
          , [Vector, Vector, function(a, b){ return a['+'](b);}]
          , [Vector, 'number', function(a, b){ return a['+'](b);}]
        ])
        /**
         * subtract
         */
      , new Operator('-', true, 10, 1, 1, [
            ['number' , 'number', function(a, b){ return a - b; }]
          , [Vector, Vector, function(a, b){ return a['-'](b);}]
          , [Vector, 'number', function(a, b){ return a['-'](b);}]
        ])
        /**
         * multiply
         */
      , new Operator('*', true, 20, 1, 1, [
           ['number' , 'number', function(a, b){ return a * b; }]
         , [Vector, Vector, function(a, b){ return a['*'](b);}]
         , [Vector, 'number', function(a, b){ return a['*'](b);}]
         , [Transformation, Vector, function(tarnsformation, vector) {
                return Vector.fromArray(tarnsformation.transformPoint(vector));
           }]
         , [Transformation, Transformation, function(t1, t2) {return t1.transform(t2);}]
        ])
        /**
         * divide
         */
      , new Operator('/', true, 20, 1, 1, [
            ['number' , 'number', function(a, b){ return a / b; }]
          , [Vector, Vector, function(a, b){ return a['/'](b);}]
          , [Vector, 'number', function(a, b){ return a['/'](b);}]
        ])
        /**
         * pow
         */
      , new Operator('^', true, 30, 1, 1, [
            ['number' , 'number', function(a, b){ return Math.pow(a, b); }]
          , [Vector, Vector, function(a, b){ return a['**'](b);}]
          , [Vector, 'number', function(a, b){ return a['**'](b);}]
        ])
      , new Operator('min', true, 40, 0, 2, [
            ['number' , 'number', function(a, b){ return Math.min(a, b); }]
        ])
      , new Operator('max', true, 40, 0, 2, [
            ['number' , 'number', function(a, b){ return Math.max(a, b); }]
      ])
        /**
         * vector constructor operator
         * Creates a vector from Cartesian coordinates
         * Consumes two numbers returns a Vector
         */
      , new Operator('Vector', false, 40, 0, 2, [
            ['number' , 'number', function(a, b){ return new Vector(a, b); }]
        ])
        /**
         * vector constructor operator
         * Creates a vector from polar coordinates => magnitude angle in radians
         * Consumes two numbers returns a Vector
         */
      , new Operator('Polar', false, 40, 0, 2, [
            ['number' , 'number', function(a, b){ return Vector.fromPolar(a, b); }]
        ])
        /**
         * vector constructor operator
         * Creates a vector from two point coordinates, two directions
         * and one tension value;
         * The returned vector is the position of the outgoing control
         * of point0;
         *
         * Arguments: point0 outDir outTension inDir point1
         */
      , new Operator('tension2controlOut', false, 40, 0, 5, [
            [Vector , 'number', 'number', 'number', Vector, hobby.tension2controlOut]
        ])
        /**
         * vector constructor operator
         * Creates a vector from two point coordinates, two directions
         * and one tension value;
         * The returned vector is the position of the incoming control
         * of point1;
         *
         * Arguments: point0 outDir inTension inDir point1
         */
      , new Operator('tension2controlIn', false, 40, 0, 5, [
            [Vector , 'number', 'number', 'number', Vector, hobby.tension2controlIn]
        ])
        /**
         * Get the maginitude of the incoming control point.
         *
         * Arguments: point0 outDir inTension inDir point1
         */
      , new Operator('tension2magnitudeIn', false, 40, 0, 5, [
            [Vector , 'number', 'number', 'number', Vector, hobby.tension2magnitudeIn]
        ])
        /**
         * Get the maginitude of the outgoing control point.
         *
         * Arguments: point0 outDir outTension inDir point1
         */
      , new Operator('tension2magnitudeOut', false, 40, 0, 5, [
            [Vector , 'number', 'number', 'number', Vector, hobby.tension2magnitudeOut]
        ])
        /**
         * Get the tension of the outgoing control point.
         *
         * Arguments: point0 outDir outLength inDir point1
         */
      , new Operator('magnitude2tensionOut', false, 40, 0, 5, [
            [Vector , 'number', 'number', 'number', Vector, hobby.magnitude2tensionOut]
        ])
        /**
         * Get the tension of the incoming control point.
         *
         * Arguments: point0 outDir inLength inDir point1.
         */
      , new Operator('magnitude2tensionIn', false, 40, 0, 5, [
            [Vector , 'number', 'number', 'number', Vector, hobby.magnitude2tensionIn]
        ])

        /**
         * Convert a number from degree to radians
         * This has higher precedence than "polar" because it makes writing:
         * "polar 100 deg 45" possible.
         */
      , new Operator('deg', false, 50, 0, 1, [
            ['number', function(a) {
                return a * Math.PI/180;
            }]
        ])
        /**
         * Normalize `angle` given in radians between 0 and 2*PI
         */
      , new Operator('normalizeAngle', false, 50, 0, 1, [
            ['number', function(a) {
                return mathUtils.normalizeAngle(a);
            }]
        ])
        /**
         * Print information about the input value to console.log
         * and return the value again.
         * This doesn't change the result of the calculation.
         */
      , new Operator('_print', false, Infinity, 0, 1, function(arg) {
            /*global console*/
            console.log('cps _print: "' +arg +'" typeof', typeof arg
                                                    , 'object: ', arg);
            return arg;
        })
        /**
         * Constructor for a scaling transformation matrix
         */
      , new Operator('Scaling', false, 0, 0, 2, [
          ['number', 'number', function(x, y) {
              return transform.Scale(x, y);
          }]
        ])
      , new Operator('Translation', false, 0, 0, 2, [
            ['number', 'number', function(x, y) {
                return transform.Offset(x, y);
            }]
        ])
      , new Operator('Skew', false, 0, 0, 2, [
            ['number', 'number', function(x, y) {
                return transform.Identity.skew(x, y);
            }]
        ])
      , new Operator('Rotation', false, 0, 0, 1, [
            ['number', function(angle) {
                return transform.Identity.rotate(angle);
            }]
        ])
      , new Operator('Transformation', false, 0, 0, 6, [
            ['number', 'number', 'number', 'number', 'number', 'number'
            , function(xx, xy, yx, yy, dx, dy) {
                return new Transformation(xx, xy, yx, yy, dx, dy);
            }]
        ])
        /**
         * Return the identity transformation
         */
      , new Operator('Identity', false, 0, 0, 0, function(){
                                            return transform.Identity;})
    );

    /**
     * FIXME: I'm not sure where to put this functionality. Also, note
     * that OperatorToken._convertTokenToValue does something similar.
     *
     * This method is passed from Parser to new Stack and then run in
     * Stack.execute, with the result of the stack execution.
     */
    engine.setFinalizeMethod(function(result, getAPI) {
        if(result instanceof NameToken)
            return getAPI.get(result.getValue());
        else if(result instanceof SelectorList) {
            var host = getAPI.get('this') // this can\'t be overidden by cps
              , node = getAPI.genericGetter(host, 'multivers')
              ;
            return getAPI.query(node, result);
            // old, not fully subscribed:
            // return getAPI.get('this').multivers.query(result);
        }
        else if(result instanceof _Token)
            // maybe one day we allow stuff like operators as first class
            // values, but not now.
            throw new CPSFormulaError('It is not allowed for a stack to '
                + 'resolve into a _Token, but this Stack did: ' + result);
        return result;
    });
    engine.setBracketOperator('[', '__get__');
    engine.setNegateOperator('-', 'negate');
    return engine;
});

define('metapolator/models/CPS/dataTypes/SharedFormulaeFactory',[
    'metapolator/errors'
  , './formulae/formulaEngine'
], function(
    errors
  , formulaEngine
) {
    

    var CPSFormulaeError = errors.CPSFormulae;

    function SharedFormulaeFactory(TypeConstructor) {
        this.TypeConstructor = TypeConstructor;
    }

    var _p = SharedFormulaeFactory.prototype;

    _p.init = function(parameterValue, setFactoryAPI, setInvalidAPI) {
        var invalidParamterMessage = false
          , stack
          ;
        // Throws CPSFormulaeError on fail
        // We let it fail on purpose by now. Catching CPSFormulaeError
        // and using invalidParamterMessage = error.message;
        // would make it possible to react more gracefully by skipping
        // invalid values, but right now we have no good way to tell the
        // user that this happened.
        // setInvalidAPI(invalidParamterMessage) will be the way to do so.
        stack = formulaEngine.parse(parameterValue.valueString);

        if(invalidParamterMessage) {
            setInvalidAPI(invalidParamterMessage);
            return;
        }
        setFactoryAPI(function(name, element, getAPI) {
            return new this.TypeConstructor(getAPI, stack);
        }.bind(this));
    };

    return SharedFormulaeFactory;
});

define('metapolator/models/CPS/dataTypes/CPSReal',[
    'metapolator/errors'
  , './_FormulaeValue'
  , './SharedFormulaeFactory'
], function(
    errors
  , Parent
  , SharedFormulaeFactory
) {
    

    var ValueError = errors.Value;

    function CPSReal(getAPI, stack) {
        Parent.call(this, getAPI, stack);
    }

    var _p = CPSReal.prototype = Object.create(Parent.prototype);
    _p.constructor = CPSReal;
    CPSReal.factory = new SharedFormulaeFactory(CPSReal);

    _p.getValue = function() {
        var result = this._stack.execute(this._getAPI);
        // result MUST be a number
        if(typeof result !== 'number' || result !== result)
            throw new ValueError('The formula of this CPSReal did '
                + (result !== result
                    ? 'result in NaN (happens with division by 0 for example)'
                    : 'not result in a number: "'+ result
                        + '" typeof: ' +  typeof result
                        + (result && typeof result.constructor === 'function'
                                ? ' a: ' + result.constructor.name
                                : ''
                        )
                )
            );
        return result;
    };

    return CPSReal;
});

define('metapolator/models/CPS/dataTypes/CPSVector',[
    'metapolator/errors'
  , './_FormulaeValue'
  , './SharedFormulaeFactory'
  , 'metapolator/math/Vector'
], function(
    errors
  , Parent
  , SharedFormulaeFactory
  , Vector
) {
    

    var ValueError = errors.Value;

    function CPSVector(getAPI, stack) {
        Parent.call(this, getAPI, stack);
    }

    var _p = CPSVector.prototype = Object.create(Parent.prototype);
    _p.constructor = CPSVector;
    CPSVector.factory = new SharedFormulaeFactory(CPSVector);

    _p.getValue = function() {
        var result = this._stack.execute(this._getAPI);
        //result MUST be a vector
        if(!(result instanceof Vector))
            throw new ValueError('The formula of this CPSVector '
                            + 'didn\'t resolve to a Vector: "'+ result
                            + '" typeof ' +  typeof result);
        return result;
    };

    return CPSVector;
});

define('metapolator/models/CPS/dataTypes/CPSTransformation',[
    'metapolator/errors'
  , './_FormulaeValue'
  , './SharedFormulaeFactory'
  , 'ufojs/tools/misc/transform'
], function(
    errors
  , Parent
  , SharedFormulaeFactory
  , transform
) {
    

    var ValueError = errors.Value
    , Transformation = transform.Transform
    ;

    function CPSTransformation(getAPI, stack) {
        Parent.call(this, getAPI, stack);
    }

    var _p = CPSTransformation.prototype = Object.create(Parent.prototype);
    _p.constructor = CPSTransformation;
    CPSTransformation.factory = new SharedFormulaeFactory(CPSTransformation);

    _p.getValue = function() {
        var result = this._stack.execute(this._getAPI);
        //result MUST be a ufoJS Transform
        if(!(result instanceof Transformation))
            throw new ValueError('The formula of this CPSTransformation '
                            + 'didn\'t resolve to a ufoJS Transform: "'+ result
                            + '" typeof ' +  typeof result + "  json:" + JSON.stringify(result));
        return result;
    };

    return CPSTransformation;
});

define('metapolator/models/CPS/dataTypes/CPSGeneric',[
    'metapolator/errors'
  , './_FormulaeValue'
  , './SharedFormulaeFactory'
], function(
    errors
  , Parent
  , SharedFormulaeFactory
) {
    

    var ValueError = errors.Value;

    function CPSGeneric(getAPI, stack) {
        Parent.call(this, getAPI, stack);
    }

    var _p = CPSGeneric.prototype = Object.create(Parent.prototype);
    _p.constructor = CPSGeneric;
    CPSGeneric.factory = new SharedFormulaeFactory(CPSGeneric);

    _p.getValue = function() {
        var result = this._stack.execute(this._getAPI);
        // result MUST not be undefined
        if(result === undefined)
            throw new ValueError('The formula of this CPS did returns "undefined" which is never valid: ' + this);
        return result;
    };

    return CPSGeneric;
});

define('metapolator/models/CPS/Registry',[
    'metapolator/errors'
  , './dataTypes/CPSReal'
  , './dataTypes/CPSVector'
  , './dataTypes/CPSTransformation'
  , './dataTypes/CPSGeneric'
], function(
    errors
  , CPSReal
  , CPSVector
  , CPSTransformation
  , CPSGeneric
) {
    
    /**
     * global registry for all known parameter names
     */
    function Registry() {
        this._parameters = {};

        // FIXME: eventually data types should be registered dynamically,
        // too. So that we could load them as plugins if needed.
        // I'm not doing this yet, because I want to design the plugin
        // interface later
        this._dataTypes = {
            // types will have to parse CPS and return instances
            // types may recognize that the CPS is invalid, this could
            // happen way earlier than when creating the instance.
            // thus the idea of factories.
            real: CPSReal.factory
          , vector: CPSVector.factory
          , transformation: CPSTransformation.factory
          , generic: CPSGeneric.factory
        };
    }
    var _p = Registry.prototype;// = Object.create(Parent.prototype)
    _p.constructor = Registry;


    _p.exists = function(name) {
        return name in this._parameters;
    };

    _p.getFactory = function(name, fallbackType /* optional string, default: 'generic'*/) {
        var description, type
          , _fallbackType = fallbackType === undefined ? 'generic' : fallbackType
          ;
        if(this.exists(name))
            type = this._parameters[name].type;
        else if(_fallbackType) {
            if(!(_fallbackType in this._dataTypes))
                throw new errors.CPSRegistryKey('Name "' + name + '" is no registered '
                        + 'parameter and fallback-type "' + _fallbackType + '" is no known type');
            type = _fallbackType;
        }
        else
            throw new errors.CPSRegistryKey('Name "' + name + '" is no registered parameter');
         return this._dataTypes[type];
    };

    _p.register = function(name, parameterDescription) {
        if(this.exists(name))
            throw new errors.CPSRegistryKey('Name "'+name+'" already registered.');

        if(!(parameterDescription.type in this._dataTypes))
            throw new errors.CPSRegistryKey('Type "'
                +parameterDescription.type+'" for parameter "'+name
                +'" is unkown.');

        this._parameters[name] = parameterDescription;
    };

    return Registry;
});

define('metapolator/project/parameters/registry',[
    'metapolator/errors'
  , 'metapolator/models/CPS/Registry'
], function(
    errors
  , Registry
) {
    

    var parameterRegistry = new Registry();

    parameterRegistry.register('on', {
                type: 'vector'
              , description: 'An On-Curve Point.'
    });

    parameterRegistry.register('in', {
                type: 'vector'
              , description: 'An incoming Control Point.'
    });

    parameterRegistry.register('out', {
                type: 'vector'
              , description: 'An outgoing Control Point.'
    });

    parameterRegistry.register('inTension', {
                type: 'real'
              , description: 'The tension value of an incoming Control Point.'
    });

    parameterRegistry.register('outTension', {
                type: 'real'
              , description: 'The tension value of an outgoing Control Point.'
    });

    parameterRegistry.register('onLength', {
                type: 'real'
              , description: 'The distance from center point to left or '
                            + 'right on curve point'
    });

    parameterRegistry.register('inLength', {
                type: 'real'
              , description: 'The distance from on-curve point to the Control Point'
                            + 'usually unused in favor of inTension'
    });

    parameterRegistry.register('outLength', {
                type: 'real'
              , description: 'The distance from on-curve point to the Control Point'
                            + 'usually unused in favor of outTension'
    });

    parameterRegistry.register('onDir', {
                type: 'real'
              , description: 'The direction in radians from center point '
                            + 'to left or right on curve point'
    });

    parameterRegistry.register('inDir', {
                type: 'real'
              , description: 'Direction of an incoming Control Point in radians.'
    });

    parameterRegistry.register('inDirIntrinsic', {
                type: 'real'
              , description: 'The intrinsic value of the direction of an '
                                                + 'incomimg Control Point.'
    });

    parameterRegistry.register('outDir', {
                type: 'real'
              , description: 'Direction of an outgoing Control Point in radians.'
    });

    parameterRegistry.register('outDirIntrinsic', {
                type: 'real'
              , description: 'The intrinsic value of the direction of an '
                                                + 'outgoing Control Point.'
    });

    parameterRegistry.register('transformation', {
                type: 'transformation'
              , description: 'Affine 2D transformation matrix.'
    });

    parameterRegistry.register('advanceWidth', {
                type: 'real'
              , description: 'The advance width of a glyph.'
    });
    parameterRegistry.register('advanceHeight', {
                type: 'real'
              , description: 'The advance height of a glyph.'
    });

    return parameterRegistry;
});

define('metapolator/models/CPS/elements/Parameter',[
    './_Node'
], function(
    Parent
) {
    
    /**
     * A Parameter: name and value
     *
     * This is essentially immutable, to change it replace it with a new
     * Parameter via its parent (ParameterDict).
     */
    function Parameter(parameterName, parameterValue, source, lineNo) {
        Parent.call(this, source, lineNo);
        this._value = parameterValue;

        Object.defineProperties(this, {
            'name': {
                value: parameterName.name
              , enumerable: true
            }
          , 'value': {
                value: parameterValue
              , enumerable: true
            }
          , 'invalid': {
                value: parameterValue.invalid
              , enumerable: true
            }
        });
    }
    var _p = Parameter.prototype = Object.create(Parent.prototype);
    _p.constructor = Parameter;

    _p.toString = function() {
        return [this.name, ': ', this._value,';'].join('');
    };

    Object.defineProperty(_p, 'message', {
        get: function(){ return this._value.message; }
    });

    return Parameter;
});

define('metapolator/models/CPS/elements/ParameterDict',[
    'metapolator/errors'
  , 'metapolator/models/emitterMixin'
  , './_Node'
  , './GenericCPSNode'
  , './Parameter'
], function(
    errors
  , emitterMixin
  , Parent
  , GenericCPSNode
  , Parameter
) {
    

    var ValueError = errors.Value
      , KeyError = errors.Key
      , propertyChangeEmitterSetup
      ;

    // TODO:
    // Make this an ordered dict. Ordered to keep the comments where
    // they belong. Dict for access to the Parameters themselves!
    // There is the possibility to declare two parameters of the same
    // name. We merge multiply defined Parameter like so:
    // the last one wins, the other previous ones are not available via
    // keys, the index interface would work.
    // If this is not fancy enough we can still think of another approach.

    propertyChangeEmitterSetup = {
          stateProperty: '_propertyChannels'
        , onAPI: 'onPropertyChange'
        , offAPI: 'offPropertyChange'
        , triggerAPI: '_triggerPropertyChange'
    };

    /**
     * A dictionary of parameters and a list of parameters, comments and
     * GenericCPSNodes
     *
     * channels for the on/off interface:
     *
     * "add" data: key
     *      A new active property was added.
     * "change" data: key
     *      An active property was changed, there is a new value at key.
     * "delete" data: key
     *      There used to be an active property for key, but there is
     *      no active property for key anymore.
     * "erase" data:key
     *      All active, inactive and invalid properties for key have been
     *      removed. This is preceded by "delete" if there used to be
     *      an active property for key. See "delete"
     *
     * Channels named after the active key/property-names are available
     * via the onPropertyChange/offPropertyChange interface.
     * They fire on "add", "delete", "change" for the respective key.
     */

    function ParameterDict(items, source, lineNo) {
        Parent.call(this, source, lineNo);
        this._items = items.slice();
        this._dict = undefined;
        this._keys = undefined;
        this._indexes = undefined;
        emitterMixin.init(this, propertyChangeEmitterSetup);
    }

    var _p = ParameterDict.prototype = Object.create(Parent.prototype);
    _p.constructor = ParameterDict;

    emitterMixin(_p, propertyChangeEmitterSetup);

    _p.toString = function() {
        var prepared = this._items.map(function(item) {
            if(!item)
                return '';
            if(item instanceof GenericCPSNode)
                return ['    ', item, ';'].join('');
            return '    ' + item;
        });

        prepared.unshift('{');
        prepared.push('}');
        return prepared.join('\n');
    };

    function _filterParameters(item) {
        return (item instanceof Parameter && !item.invalid);
    }

    Object.defineProperty(_p, 'items', {
        get: function() {
            return this._items.slice();
        }
    });

    /**
     * dictionary of active items:
     * {
     *      key: itemValue
     * }
     */
    Object.defineProperty(_p, 'dict', {
        get: function() {
            if(!this._keys)
                this._buildIndex();
            var result = Object.create(null), k, dict = this._dict;
            for(k in dict)
                result[k] = this.getItemValue(dict[k]);
            return result;
        }
    });

    Object.defineProperty(_p, 'length', {
        get: function(){ return this._items.length; }
    });

    _p._buildIndex = function() {
        var items = this._items
          , item
          , i, key, dict, keys, indexes
          ;
        this._dict = dict = Object.create(null);
        this._keys = keys = [];
        this._indexes = indexes = Object.create(null);
        // searching backwards, because the last item with key === name has
        // the highest precedence
        for(i=items.length-1;i>=0;i--) {
            item = items[i];
            key = item.name;

            if(!indexes[key]) indexes[key] = [];
            indexes[key].push(i);

            if(!_filterParameters(item))
                continue;
            if(!(key in dict)) {
                dict[key] = i;
                keys.push(key);
            }
        }
    };

    // FIXME: add a splice API
    // it's good for a more complex ui

    /**
     * replace or add
     * overide the active item or create new entry
     *
     * emits: "add", "change" or nothing
     */
    _p.setParameter = function(item) {
        var key = item.name
          , items = this._items
          , index
          , event
          , old
          ;
        if(!_filterParameters(item))
            throw new ValueError('Trying to set an invalid property: ' + item);
        if(!this.has(key)) {
            event = 'add';
            index = items.length;
            items.push(item);
            if(!this._indexes[key])
                this._indexes[key] = [];
            this._indexes[key].push(index);
            this._keys.push(key);
        }
        else {
            event = 'change';
            index = this._dict[key];
            old = items[index];
            items[index] = item;
        }
        this._dict[key] = index;
        // emit events
        if(old) old.destroy();
        this._trigger(event, key);
        this._triggerPropertyChange(key, event);
    };

    /**
     * Remove all items with key as name (valid, invalid, active, inactive)
     * return number of removed items
     *
     * emits: ["delete", "erase"], "erase" or nothing
     */
    _p.erase = function(key) {
        var count = 0, indexes, i
          , items = this._items
          , removed
          , event
          , deleteEvent = false
          ;
        if(!this._indexes)
            this._buildIndex();
        indexes = this._indexes[key];
        if(!indexes)
            return 0;
        removed = [];
        count = indexes.length;
        delete indexes[key];
        for(i=0;i<count;i++) {
            // returns an array with the deleted elements
            // since we delete always only one item [0].destroy(); is good
            removed.push(items[indexes[i]]);
            delete items[indexes[i]];
        }
        if(key in this._dict) {
            // if key was active, this is also a delete event.
            deleteEvent = true;
            delete this._dict[key];
            event = ['delete', 'erase'];
        }
        else
            event = 'erase';
        this._keys = Object.keys(this._dic);

        for(i=0;i<count;i++)
            removed[i].destroy();
        this._trigger(event, key);
        if(deleteEvent)
            this._triggerPropertyChange(key, 'delete');
        return count;
    };

    /**
     * Remove/delete the currently active item for key.
     * May make another valid parameter with the same name active,
     * if there is any.
     *
     * emits: "change" or "delete" or noting
     */
    _p.removeCurrentActiveParameter = function(key) {
        // return number of removed items
        var indexes, index, i
          , items = this._items
          , old
          , keys
          , event
          ;
        if(!this.has(key))
            return 0;
        // delete the currently active item for key
        index = this._dict[key];
        old = items[index];
        delete items[index];
        delete this._dict[key];
        indexes = this._indexes[key];
        indexes.sort();
        for(i=indexes.length;i>=0;i--) {
            if(indexes[i] === index) {
                // the old active key must come first in this iteration
                // because the highest valid index is the active item
                indexes.splice(i, 1);
            }
            else if(_filterParameters(items[indexes[i]])) {
                // this changed the active value
                this._dict[key] = indexes[i];
                break;
            }
        }
        old.destroy();
        if(!(key in this._dict)) {
            // no follow up was found
            // delete event!
            event = 'delete';
            this._keys = Object.keys(this._dict);
        }
        else
            // there is a successor, change event!
            event = 'change';
        this._trigger(event, key);
        this._triggerPropertyChange(key, event);
        return 1;
    };

    _p.keys = function() {
        if(!this._keys)
            this._buildIndex();
        return this._keys.slice();
    };

    _p.get = function(key) {
        if(!this._dict)
            this._buildIndex();
        if(!(key in this._dict))
            throw new KeyError('Key "'+key+'" not in ParameterDict.');
        return this.getItemValue(this._dict[key]);
    };

    _p.has = function(key) {
        if(!this._dict)
            this._buildIndex();
        return key in this._dict;
    };

    _p.find = function(key) {
        if(!this._dict)
            this._buildIndex();
        return this._indexes[key].slice() || [];
    };

    _p.getItemValue = function(index) {
        return this._items[index].value;
    };

    return ParameterDict;
});

define('metapolator/models/CPS/elements/_Name',[
    './_Node'
], function(
    Parent
) {
    
    /**
     * Used as base of AtRuleName and ParameterName.
     */
    function _Name(name, comments ,source, lineNo) {
        /*jshint validthis:true*/
        Parent.call(this, source, lineNo);
        this._comments = comments;
        Object.defineProperty(this, 'name', {
            value: name
          , enumerable: true
        });
    }
    var _p = _Name.prototype = Object.create(Parent.prototype);
    _p.constructor = _Name;

    /**
     * Prints all comments after the name.
     */
    _p.toString = function() {
        return [this.name,
                this._comments.length ? ' ': '',
                this._comments.join('\n')].join('');
    };
    return _Name;
});

define('metapolator/models/CPS/elements/ParameterName',[
    './_Name'
], function(
    Parent
) {
    
    /**
     * The name of a Parameter.
     */
    function ParameterName(name, comments ,source, lineNo) {
        Parent.call(this, name, comments ,source, lineNo);
    }
    var _p = ParameterName.prototype = Object.create(Parent.prototype);
    _p.constructor = ParameterName;

    return ParameterName;
});

define('metapolator/models/CPS/elements/ParameterValue',[
    'metapolator/errors'
  , './_Node'
], function(
    errors
  , Parent
) {
    
    /**
     * The value of a Parameter.
     *
     * TODO: the value needs to be examined, we need a canonical version
     * of it. Otherwise one effect is, that we add too much whitespace
     * when serializing with toString (because we don't remove whitespace
     * when extracting the comments)
     * This will probably happen when we start to really process the values.
     */
    function ParameterValue(value, comments ,source, lineNo) {
        Parent.call(this, source, lineNo);

        this._value = value;
        this._comments = comments;
        this._factory = undefined;
        this.factory = undefined;
        this._invalid = undefined;
    }
    var _p = ParameterValue.prototype = Object.create(Parent.prototype);
    _p.constructor = ParameterValue;

    Object.defineProperty(_p, 'value', {
        get: function(){ return '!!stub!!' + this._value.join('|||'); }
    });

    function _setInvalidAPI(message) {
        /*jshint validthis:true*/
        if(this._factory !== undefined)
            throw new errors.CPS('Can\'t mark as invalid: factory is already '
                                + 'set.');
        this._invalid = true;
        this._message = message || '(no message left)';
    }

    function _setFactoryAPI(factory) {
        /*jshint validthis:true*/
        if(this._invalid)
            throw new errors.CPS('Can\'t set factory: value is already '
                                + 'marked as invalid: ' + this._message);
        if(this._factory !== undefined)
            throw new errors.CPS('Factory is already set!');
        if(!(factory instanceof Function))
            throw new errors.CPS('Factory must be a function but is: '
                                + typeof factory);
        this._factory = factory;
        Object.defineProperty(this, 'factory', {
            enumerable: true
          , value: factory
        });
    }

    _p.initializeTypeFactory = function(name, typeDefinition) {
        if(this._factory !== undefined)
            throw new errors.CPS('Factory is already set!');
        if(this._invalid)
            throw new errors.CPS('Can\'t set factory: value is already '
                    + 'marked as invalid: ' + this._message);
        typeDefinition.init(this, _setFactoryAPI.bind(this),
                                  _setInvalidAPI.bind(this));

        if(this._factory === undefined && this._invalid === undefined)
            throw new errors.CPS('TypeDefinition for ' + name
                            + ' did not initialize this ParameterValue');
    };

    Object.defineProperty(_p, 'invalid', {
        get: function(){ return this._invalid;}
    });

    // this property ommits the comments on purpose
    Object.defineProperty(_p, 'valueString', {
        get: function(){ return this._value.join(''); }
    });

    Object.defineProperty(_p, 'astTokens', {
        get: function() {
            return this._value.map(
                                function(item){ return item._ast; });
            }
    });

    /**
     * Prints all comments before the value.
     */
    _p.toString = function() {
        return [this._comments.join('\n'),
                this._comments.length ? ' ': '',
                this.valueString.trim()].join('');
    };

    return ParameterValue;
});

define('metapolator/project/parameters/outputConverter',[
    'metapolator/errors'
  , 'metapolator/models/CPS/parsing/Source'
  , 'metapolator/models/CPS/elements/ParameterCollection'
  , 'metapolator/models/CPS/elements/Rule'
  , 'metapolator/models/CPS/elements/ParameterDict'
  , 'metapolator/models/CPS/elements/Parameter'
  , 'metapolator/models/CPS/elements/ParameterName'
  , 'metapolator/models/CPS/elements/ParameterValue'
  , 'metapolator/models/CPS/elements/Comment'
  , 'metapolator/models/CPS/parsing/parseSelectorList'
], function(
    errors
  , Source
  , ParameterCollection
  , Rule
  , ParameterDict
  , Parameter
  , ParameterName
  , ParameterValue
  , Comment
  , parseSelectorList
) {
    

    var items = []
      , source = new Source('(generated/default parameters)')
      , rules = []
      ;


    function parameterDictFromObject(obj, source) {
        var items = []
          , k
          , name
          , value
          ;

        for(k in obj) {
            name = new ParameterName(k, [], source);
            value = new ParameterValue([obj[k]], [], source);
            items.push(new Parameter(name, value, source));
        }
        return new ParameterDict(items);
    }

    rules.push(
        new Rule(
            parseSelectorList.fromString('*', source.name)
          , parameterDictFromObject({
            // let's see what is still needed here.
            //      on: 'onIntrinsic'
            //    , in: 'inIntrinsic'
            //    , out: 'outIntrinsic'
            //    , inDir: 'inDirIntrinsic'
            //    , outDir: 'outDirIntrinsic'
            //    , inTension: '0'
            //    , outTension: '0'
            //    , inIntrinsic: 'Vector 0 0'
            //    , outIntrinsic: 'Vector 0 0'
            //    , inDirIntrinsic: '0'
            //    , outDirIntrinsic: '0'
              })
          , source
      )
      , new Rule(
            parseSelectorList.fromString('component', source.name)
          , parameterDictFromObject({
              transformation: 'originalTransformation'
              })
          , source
      )
      , new Rule(
            parseSelectorList.fromString('contour>p', source.name)
            // FIXME: draw with tensions!
          , parameterDictFromObject({
                  on: 'skeleton:on'
                , 'in': 'skeleton:in'
                , out: 'skeleton:out'
                // the dirs are defined by the importer if this calculations
                // would not produce a good result
                , inDir: '(on - in):angle'
                , outDir: '(out - on):angle'
              })
          , source
      )
      , new Rule(
            parseSelectorList.fromString('point>center', source.name)
          , parameterDictFromObject({
                  on: 'parent:skeleton:on'
                , 'in': 'parent:skeleton:in'
                , out: 'parent:skeleton:out'
                // the dirs are defined by the importer if this calculations
                // would not produce a good result
                , inDir: '(on - in):angle'
                , outDir: '(out - on):angle'
              })
          , source
        )
        // @dict
      , new Rule(
            parseSelectorList.fromString('point>*', source.name)
          , parameterDictFromObject({
                pointBefore: 'parent:parent:children[parent:index - 1][this:type]'
              , pointAfter: 'parent:parent:children[parent:index+1][this:type]'
            })
          , source
        )
      , new Rule(
            parseSelectorList.fromString('point>left, point>right', source.name)
          , parameterDictFromObject({
                  on: 'Polar onLength onDir + parent:center:on'
                // this makes it possible to *JUST* use a Vector creation
                // for pure beziers as well:
                //, 'in': 'Polar inLength inDir + on'
                //, out: 'Polar outLength outDir + on'
                // , 'in': 'Polar (tension2magnitude pointBefore:on pointBefore:outDir pointBefore:outTension inTension inDir on)[0] inDir + on'
                // , out:  'Polar (tension2magnitude on outDir outTension  pointAfter:inTension pointAfter:inDir pointAfter:on)[1] outDir + on'
                , 'in': 'tension2controlIn pointBefore:on pointBefore:outDir inTension inDir on'
                , out: 'tension2controlOut on outDir outTension pointAfter:inDir pointAfter:on'

                , inDir: 'inDirIntrinsic + parent:center:inDir'
                , outDir: 'outDirIntrinsic + parent:center:outDir'
            })
           , source
        )
      , new Rule(
            parseSelectorList.fromString('point>left', source.name)
          , parameterDictFromObject({
                  onDir: 'deg 180 + parent:right:onDir'
                , onLength: 'parent:right:onLength'
            })
          , source
        )
      // opening terminal; drawn from left to right using both 'in' values
      , new Comment('opening terminal')
      , new Rule(
            parseSelectorList.fromString('point:i(0)>left', source.name)
          , parameterDictFromObject({
                'in': 'tension2controlOut on (inDir + deg 180) inTension parent:right:inDir parent:right:on'
              })
          , source
        )
      , new Rule(
            parseSelectorList.fromString('point:i(0)>right', source.name)
          , parameterDictFromObject({
                  'in': 'tension2controlIn parent:left:on (parent:left:inDir  + deg 180) inTension inDir on'
              })
          , source
        )
      // closing terminal; drawn from right to left using both 'out' values
      , new Comment('closing terminal')
      , new Rule(
            parseSelectorList.fromString('point:i(-1)>right', source.name)
          , parameterDictFromObject({
                  out: 'tension2controlOut on outDir outTension (parent:left:outDir + deg 180) parent:left:on'
              })
          , source
        )
      , new Rule(
            parseSelectorList.fromString('point:i(-1)>left', source.name)
          , parameterDictFromObject({
                out: 'tension2controlIn parent:right:on parent:right:outDir outTension (outDir + deg 180) on'
              })
          , source
        )
    );
    return new ParameterCollection(rules, source);
});

define('metapolator/models/MOM/Univers',[
    './_Node'
  , './Master'
], function(
    Parent
  , Master
) {
    
    /**
     * This Element is the container of all masters of a metapolator superfamily.
     * It only contains children of type MOM Master
     */
    function Univers() {
        Parent.call(this);
    }
    var _p = Univers.prototype = Object.create(Parent.prototype);
    _p.constructor = Univers;

    Object.defineProperty(_p, 'MOMType', {
        value: 'MOM Univers'
    });

    Object.defineProperty(_p, 'type', {
        /* this is used for CPS selectors*/
        value: 'univers'
    });

    _p._acceptedChildren = [Master];

    return Univers;
});

define('metapolator/models/CPS/SelectorEngine',[
    'metapolator/errors'
  , 'metapolator/models/CPS/parsing/parseSelectorList'
  , './elements/Rule'
  , './elements/SelectorList'
  , './elements/ComplexSelector'
  , './elements/CompoundSelector'
  , './elements/SimpleSelector'
], function(
    errors
  , parseSelectorList
  , Rule
  , SelectorList
  , ComplexSelector
  , CompoundSelector
  , SimpleSelector
) {
    
    var CPSError = errors.CPS
      , selectorListFromString = parseSelectorList.fromString
      , stringify = JSON.stringify
      ;

    // start selector engine
    function SelectorEngine() {
        this._compoundSelectorCache = Object.create(null);
    }
    var _p = SelectorEngine.prototype;

    _p._complexSelectorMatches = function(complexSelector, element, scopeElement) {
        if(!(complexSelector instanceof ComplexSelector))
            throw new CPSError('complexSelector is not of type '
                                         + 'ComplexSelector: ' + complexSelector);
        var compoundSelectors = complexSelector.value
          , compoundSelector
          , combinator
          , combinatorType
          ;
        // first round: fake a child combinator, so we don't go on
        // if the first selector doesn't match
        combinatorType = 'child';
        // this is a compound selector

        // a shortcut, in the best case this should be generated from
        // structure information of the MOM.
        var length = compoundSelectors.value
          , precheckElem
          , matches
          , type
          ;
        for(var i=0; i<length; i+=2) {
            compoundSelector = compoundSelectors[i];
            type = compoundSelector.type;
            if(type === 'master')
                precheckElem = element.master;
            else if(type === 'glyph')
                precheckElem = element.glyph;
            else
                continue;
            if(precheckElem && !compoundSelector.matches(precheckElem, this))
                return false;
        }
        // end of shortcut

        compoundSelector = compoundSelectors.pop();

        while(element) {
            if(compoundSelector.matches(element, this)) {
                //  we got a hit
                combinator = compoundSelectors.pop();
                if(combinator === undefined) {
                    // that's it all compoundSelectors are consumed
                    return true;
                }
                // there are selectors left, prepare the next round
                // combinatorType is 'child' or 'descendant'
                combinatorType = combinator.type;
                compoundSelector = compoundSelectors.pop();

                element = (scopeElement && scopeElement === element)
                        // do not search above scopeElement
                        ? undefined
                        // may be undefined. if so it will halt the while loop
                        : element.parent;
            }
            // no match
            else if(combinatorType === 'child')
                // this will halt the while loop
                element = undefined;
            else if (combinatorType === 'descendant')
                // may be undefined. if so it will halt the while loop
                element = element.parent;
            else
                throw new CPSError('Combinator type "'+combinatorType
                                                    +'" is unsuported');
        }
        return false;
    };

    function _compileCompoundSelector(compoundSelector) {
        /*jshint evil:true*/
        var simpleSelectors = compoundSelector.normalizedValue
          , simpleSelector
          , body = ['', 'return (true']
          , tests = []
          , i,l
          , val
          , varname
          , name
          ;
        for(i=0, l=simpleSelectors.length;i<l;i++) {
            simpleSelector = simpleSelectors[i];
            name = simpleSelector.name;
            switch(simpleSelector.type) {
                case 'type':
                    body.push(' && (element.type === ', stringify(name), ')');
                    break;
                case 'id':
                    body.push(' && (element.id === ', stringify(name), ')');
                    break;
                case 'class':
                    body.push(' && (element.hasClass(', stringify(name), '))');
                    break;
                case 'pseudo-class':
                    if(name === 'i') {
                        // must have a parent for this
                        body.push(' && (!!element.parent)');
                        val = simpleSelector.value;
                        if(val < 0)
                            body.push(' && (element.parent.children.length + ', val, ' === element.index)');
                        else
                            body.push(' && (', val, ' === element.index)');
                    }
                    else
                        // we know only :i right now
                        body.push('&& false');
                    break;
                case 'universal':
                    // this is always true
                    break;
                default:
                    throw new CPSError('simpleSelector.type "'+ simpleSelector.type +'" is not implemented.');
            }
        }
        body.push(');');
        return new Function(['element'], body.join(''));
    }

    /**
     * A compound selector is a chain (list) of simple selectors that
     * are not separated by a combinator.
     *
     * It always begins with a type selector or a (possibly implied)
     * universal selector. No other type selector or universal
     * selector is allowed in the sequence.
     *
     * If one item of the  simple selectors list is no simple selector
     * this method raises a CPSError.
     */
    _p.compileCompoundSelector = function(compoundSelector) {
        var key = compoundSelector.normalizedName
          , _compoundSelectorCache = this._compoundSelectorCache
          ;
        if(!(key in _compoundSelectorCache))
            _compoundSelectorCache[key] = _compileCompoundSelector(compoundSelector);
        return _compoundSelectorCache[key];
    };


    /**
     * A (complex) selector's specificity is calculated as follows:
     *     count the number of ID selectors in the selector (= a)
     *     count the number of class selectors, attributes selectors, and pseudo-classes in the selector (= b)
     *     count the number of type selectors and pseudo-elements in the selector (= c)
     *     ignore the universal selector
     *
     * Specificities are compared by comparing the three components in
     * order: the specificity with a larger A value is more specific;
     * if the two A values are tied, then the specificity with a larger
     * B value is more specific; if the two B values are also tied, then
     * the specificity with a larger c value is more specific;
     * if all the values are tied, the two specifities are equal.
     *
     * Array.prototype.sort: "The sort is not necessarily stable."
     * https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/sort
     * https://en.wikipedia.org/wiki/Sorting_algorithm#Stability
     *
     * To ensure stability it is possible to introduce more than the above
     * mentioned three elements of specificity.
     */
    function compareSpecificity(sA, sB) {
        for(var i=0, len = Math.min(sA.length, sB.length);i<len;i++) {
            if(sA[i] !== sB[i])
                // id return value is < 0 selectorA will get a lower index
                // id return value is > 0 selectorB will get a lower index
                return sB[i]-sA[i];
        }
        return 0;
    }
    function compareSelectorSpecificity (itemA, itemB) {
        return compareSpecificity(itemA.specificity, itemB.specificity);
    }
    // export static functions
    SelectorEngine.compareSpecificity = compareSpecificity;
    SelectorEngine.compareSelectorSpecificity = compareSelectorSpecificity;

    function _rulesCompareSpecificity (itemA, itemB) {
        return compareSpecificity(itemA[0], itemB[0]);
    }

    /**
     * Returns a list of all of the rules currently applying to the element,
     * sorted from most specific to least.
     *
     * the complexSelectors in namespacedRules[n][0] should be sorted, so that the
     * first complexSelector in namespacedRule has the highest specificity
     */
    _p.getMatchingRules = function(namespacedRules, element) {
        var matchingRules = []
          , namespacedRule
          , complexSelectors
          , specificity
          , i, j, length, lengthCS
          ;
        for(i=0, length = namespacedRules.length;i<length;i++) {
            namespacedRule = namespacedRules[i];
            complexSelectors = namespacedRule[0].value;
            for(j=0, lengthCS = complexSelectors.length;j<lengthCS;j++) {
                if(this._complexSelectorMatches(complexSelectors[j], element)) {
                    // got a match with the most specific selector
                    // augment the specifity with the index number, so we can
                    // make sure, that the order of rules with otherwise
                    // equal specifity is not mixed up. The later rules
                    // are more specific/overide the previous one, so it
                    // is a good match for the sorting function that we use
                    // anyways
                    specificity = complexSelectors[j].specificity.slice();
                    specificity.push(i);
                    matchingRules.push([specificity, namespacedRule[1]]);
                    break;
                }
            }
        }
        matchingRules.sort(_rulesCompareSpecificity);
        return matchingRules.map(function(item){return item[1];});
    };

    function _combinateAll(type, element, complexSelectorArray, seen, selectorEngine) {
        var compoundSelector = complexSelectorArray[0]
          , stack = []
          , frame
          , combinator = null
          , nextComplexSelectorArray
          , result
          , results = []
          , child
          , descendant = type === 'descendant'
          , i,l
          ;
        if(!descendant && type !== 'child')
            throw new CPSError('Combinator type "' + type +'" is unsuported');
        //initial frame setup
        frame = [element.children, 0, 0];
        frame[2] = frame[0].length;
        do {
            i=frame[1];
            l=frame[2];
            while(i<l) {
                child = frame[0][i];
                i++;
                if(compoundSelector.matches(child, selectorEngine)) {
                    // it matches
                    if(combinator === null) // do this lazy and only once
                        combinator = complexSelectorArray[1];
                    if(!combinator) {
                        // no more selectors. we got a hit
                        if(!(child.nodeID in seen)) {
                            results.push(child);
                            seen[child.nodeID] = null;
                        }
                        continue;
                    }
                    if(!nextComplexSelectorArray) // do this lazy and only once
                        nextComplexSelectorArray = complexSelectorArray.slice(2);
                    result = _combinateAll(combinator.type, child, nextComplexSelectorArray, seen, selectorEngine);
                    if(result.length)
                        Array.prototype.push.apply(results, result);
                }
                if(!descendant) continue;
                if(i<l) {
                    // save this frame
                    frame[1]=i;
                    frame[2]=l;
                    stack.push(frame);
                }
                // setup the next frame
                frame = [child.children, 0, 0];
                frame[2] = frame[0].length;
                i=frame[1];
                l=frame[2];
            }
        } while((frame = stack.pop()));
        return results;
    }

    /**
     * return only the first hit in depth first order
     * complexSelectorArray is an array of the form compoundSelectors
     * separated by combinator.
     * [compoundSelector, combinator, compoundSelector, combinator, compoundSelector]
     * min length is 1. length has to be odd always
     */
    function _combinateFirst(type, element, complexSelectorArray, selectorEngine) {
        var compoundSelector = complexSelectorArray[0]
          , stack = []
          , frame
          , combinator = null
          , nextComplexSelectorArray
          , result
          , child
          , descendant = type === 'descendant'
          , i,l
          ;
        if(!descendant && type !== 'child')
            throw new CPSError('Combinator type "' + type +'" is unsuported');
        //initial frame setup
        frame = [element.children, 0, 0];
        frame[2] = frame[0].length;
        do {
            i=frame[1];
            l=frame[2];
            while(i<l) {
                child = frame[0][i];
                i++;
                if(compoundSelector.matches(child, selectorEngine)) {
                    // it matches
                    if(combinator === null) // do this lazy and only once
                        combinator = complexSelectorArray[1];
                    if(!combinator)
                        // no more selectors. we got a hit
                        return child;
                    if(!nextComplexSelectorArray) // do this lazy and only once
                        nextComplexSelectorArray = complexSelectorArray.slice(2);
                    result = _combinateFirst(combinator.type, child, nextComplexSelectorArray, selectorEngine);
                    if(result)
                        return result;
                }
                if(!descendant) continue;
                if(i<l) {
                    // save this frame
                    frame[1]=i;
                    frame[2]=l;
                    stack.push(frame);
                }
                // setup the next frame
                frame = [child.children, 0, 0];
                frame[2] = frame[0].length;
                i=frame[1];
                l=frame[2];
            }
        } while((frame = stack.pop()));
        // nothing found
        return null;
    }

    /**
     * selector may be a string or a SelectorList
     * Returns a set of elements in scope matching at least one of
     * the selectors in selector.
     *
     * scope is an array of zero or more elements, we will search only
     * within the scope elements
     */
    _p.queryAll = function(scope, _selector) {
        var complexSelectors
          , complexSelectorArray
          , i,l, k, ll, j
          , seen = Object.create(null)
          , result = []
          , matches, node
          , selector
          ;
        if(typeof _selector === 'string')
            selector = selectorListFromString(_selector, undefined, this);
        else if(_selector instanceof SelectorList)
            selector = _selector;
        else
             throw new CPSError('SelectorList expected, but got a '
                            + _selector + ' typeof: '+ typeof _selector);
        if(!(scope instanceof Array))
            throw new CPSError('scope must be an Array');
        complexSelectors = selector.value;
        for(i=0,l=complexSelectors.length;i<l;i++) {
            complexSelectorArray = complexSelectors[i].value;
            for(k=0,ll=scope.length;k<ll;k++) {
                matches = _combinateAll('descendant', scope[k], complexSelectorArray, seen, this);
                Array.prototype.push.apply(result, matches);
            }
        }
        return result;
    };

    /**
     * Returns the first element within the scope that matches.
     *
     * Matching only one element could be better optimized, especially
     * further down: queryComplexSelector, doesn't know anything about
     * selecting only one element.
     */
    _p.query = function(scope, _selector) {
        var complexSelectors
          , complexSelectorArray
          , i,l, k, ll
          , match
          , selector
          ;
        if(typeof _selector === 'string')
            selector = selectorListFromString(_selector, undefined, this);
        else if(_selector instanceof SelectorList)
            selector = _selector;
        else
             throw new CPSError('SelectorList expected, but got a '
                            + _selector + ' typeof: '+ typeof _selector);
        if(!(scope instanceof Array))
            throw new CPSError('scope must be an Array');

        complexSelectors = selector.value;
        for(i=0,l=complexSelectors.length;i<l;i++) {
            complexSelectorArray = complexSelectors[i].value;
            for(k=0,ll=scope.length;k<ll;k++) {
                match = _combinateFirst('descendant', scope[k], complexSelectorArray, this);
                if(match) return match;
            }
        }
        return null;
    };

    return SelectorEngine;
});

define('metapolator/models/MOM/Multivers',[
    './_Node'
  , './Univers'
], function(
    Parent
  , Univers
) {
    
    /**
     * This is the root element of a MOM Tree.
     *
     * This element is the container of all Univers elements of a metapolator
     * superfamily. It's needed for as a scope for cps queries that search
     * in the scope of an entire Univers. And it's used to check if an
     * element belongs to the MOM tree where Multivers is the root. Other
     * than that, has no real use now, but we may do cool stuff with it
     * in the future.
     *
     * It only contains children of type MOM Univers
     */
    function Multivers(controller) {
        Parent.call(this);
        this._controller = controller;
    }
    var _p = Multivers.prototype = Object.create(Parent.prototype);
    _p.constructor = Multivers;

    Object.defineProperty(_p, 'MOMType', {
        value: 'MOM Multivers'
    });

    Object.defineProperty(_p, 'type', {
        /* this is used for CPS selectors*/
        value: 'multivers'
    });

    _p.query = function(selector, scope) {
        return this._controller.query(selector, scope);
    };
    _p.queryAll = function(selector, scope) {
        return this._controller.queryAll(selector, scope);
    };

    _p.getComputedStyleFor = function(node) {
        return this._controller.getComputedStyle(node);
    };

    _p._acceptedChildren = [Univers];

    return Multivers;
});

define('metapolator/memoize',['metapolator/errors'], function(errors) {
    

    // _cache is a state variable of this module. It's a single WeakMap
    // to manage all caches on a per-instance basis.
    var  _cache = new WeakMap();

    /**
     * Set up a cache for a method of an instance. The cache is bound to
     * the instance that is used to call the method.
     *
     * namespace: A string to avoid conflicts between caches
     *            on the same instance.
     *
     * func: The function whose results are being cached.
     *
     * keyFunc: function or undefined; is called with all the arguments
     *          that are applied to "func" and returns a unique key for the
     *          combination of arguments. If func is undefined, the default
     *          behavior is: listOfArguments.join(',')
     *
     * Example:
     * // query will be cached on a per instance base.
     * Constructor = function(){}
     * Constructor.prototype.query = memoize('query', function(queryArg){...});
     * Constructor.prototype.search = memoize('search', function(searchArg){...});
     * Constructor.prototype.prune = memoize.prune;
     *
     * var instance = new Constructor();
     * instance.query('something');
     * instance.search('topic');
     *
     * // delete only the caches for the namespace 'search'
     * instance.prune('search');
     * // delete all caches for instance
     * instance.prune();
     * // if you delete all references to instance the cache will be gone to
     * delete instance;
     *
     */
    function memoize(namespace, func, keyFunc) {
        errors.assert(namespace !== undefined, 'Please set a namespace.');
        function cached() {
            /*jshint validthis:true */
            var instanceCache
              , namespaceCache
              , args = Array.prototype.slice.call(arguments)
              , key = keyFunc
                    ? keyFunc.apply(this, args)
                    : args.join(',')
              ;
            instanceCache = _cache.get(this);
            if(instanceCache === undefined) {
                instanceCache = Object.create(null);
                _cache.set(this, instanceCache);
            }

            namespaceCache = instanceCache[namespace];
            if(namespaceCache === undefined)
                namespaceCache = instanceCache[namespace] = Object.create(null);

            if(!(key in namespaceCache))
                namespaceCache[key] = func.apply(this, args);
            return namespaceCache[key];
        }
        return cached;
    }

    /**
     * Delete all cache entries for the cache at "namespace"
     * If "namespace" is `undefined` all caches for the instance are deleted.
     *
     * Call this method so that its "this" refers to the instance that
     * is associated with the cache:
     *     SO: memoize.prune.call(instance, 'queries');
     *  OR SO: instance.prune = memoize.prune;
     *         instance.prune('queries');
     *  OR SO: Constructor.prototype.prune = memoize.prune;
     *         instance = new Constructor();
     *         instance.prune('queries');
     */
    function prune(namespace) {
        /*jshint validthis:true */
        var cache;
        errors.assert(this !== memoize, 'You have to call this method '
                                    + 'from an apropriate host. Currently '
                                    + '"this" is the memoize module.');
        if(namespace === undefined)
            return _cache['delete'](this);
        cache = _cache.get(this);
        if(cache)
            delete cache[namespace];
    }
    memoize.prune = prune;

    return memoize;
});

define('metapolator/models/CPS/StyleDict',[
    'metapolator/errors'
  , './whitelistProxies'
  , 'metapolator/memoize'
  , 'metapolator/models/emitterMixin'
  , 'metapolator/models/MOM/_Node'
  , 'metapolator/models/CPS/elements/SelectorList'
], function(
    errors
  , whitelistProxies
  , memoize
  , emitterMixin
  , _MOMNode
  , SelectorList
) {
    

    var KeyError = errors.Key
      , ReceiverError = errors.Receiver
      , AssertionError = errors.Assertion
      , CPSKeyError = errors.CPSKey
      , CPSRecursionError = errors.CPSRecursion
      , assert = errors.assert
      , propertyChangeEmitterSetup
      ;

    propertyChangeEmitterSetup = {
          stateProperty: '_dependants'
        , onAPI: 'onPropertyChange'
        // TODO: Not deleting the channel will take a bit more memory but in turn
        // needs less garbadge collection
        // we could delete this when the key is removed from this._dict
        // and not added again, supposedly in _rebuildIndex and _paramerChangeHandler
        // delete this._dependants[key];
        // however, _rebuildIndex and updateDictEntry are not part of
        // the concept of emitter/channel thus the emitter should
        // provide a method: removeProperty(channel) which in turn can be called by
        // _rebuildIndex and updateDictEntry. Also, that would throw an error
        // if there are any subscriptions left. (we may add a on-delete event)
        // for that case!?
        , offAPI: 'offPropertyChange'
        , triggerAPI: '_triggerPropertyChange'
    };

    /**
     * StyleDict is an interface to a List of CPS.Rule elements.
     *
     * rules: StyleDict will pull the rules for element from controller
     *        when needed, it uses controller.getRulesForElement(element)
     *        controller, in turn will invalidate the rules via: StyleDict.prototype.invalidateRules
     */
    function StyleDict(controller, element, rules /* default: null */) {
        // I prefer: this.get.bind(this);
        // But this method is called a lot and thus the closure is faster.
        // see: http://jsperf.com/bind-vs-native-bind-run
        // that may change in the future
        var self = this;


        // new GetAPI(this); => would make a cleaner definition, but maybe slows things down???
        this.getAPI = {
            get: function(key) {
                var result = self.get(key);
                self._subscribeTo(self, key);
                return result;
            }
          , query: function(node, selector) {
                var result = node.query(selector);
                self._subscribeTo(node, selector);
                return result;
            }
          , genericGetter: function(item, key){
                return self._genericGetter(item, key);
            }
        };


        Object.defineProperty(this, 'element', {
            value: element
          , enumerable: true
        });
        this._controller = controller;
        this._getting = {
            recursionDetection: Object.create(null)
          , stack: []
          , current: null
        };

        this._rules = rules || null;
        this._dict = null;
        this._cache = Object.create(null);

        // subscriptions to the "add" channel of each parameterDict in this._rules
        this._dictSubscriptions = [];

        // subscriptions to the active key in a parameterDict
        //
        // triggered on "change" and "delete" (also on "add" but we subscribe later)
        //
        // cache_key refers to the same key here and in the parameterDict
        // {
        //    cache_key: [parameterDict, subscriptionUid] /* information needed to unsubscribe */
        // }
        this._propertySubscriptions = Object.create(null);

        // All current subscriptions to dependencies of the cache.
        // One subscription can be used by many _cache entries.
        // {
        //    subscriptionUid: [
        //        /* information needed to unsubscribe */
        //          item // the item/element/object subscribed to
        //        , subscriberId // needed to unsubscribe, returned when subscribing
        //
        //        /* information to control subscribing and unsubscribing */
        //        , object // set of _cache keys subscribed to this
        //        , 0 // counter, number of dependencies, same as previous Object.keys(object).length
        //    ];
        //}
        this._cacheSubscriptions = Object.create(null);

        // the subscriptionUids for each key in cache
        // {
        //    cache_key: [subscriptionUid, ...]
        // }
        this._cacheDependencies = Object.create(null);

        // emitter: PropertyChange
        // Adds this[propertyChangeEmitterSetup.stateProperty]
        // which is this._dependencies
        emitterMixin.init(this, propertyChangeEmitterSetup);

        // adds the default this._channel
        emitterMixin.init(this);

        this._subscriptionUidCounter = 0;
        this._subscriptionUids = new WeakMap();
        this._invalidating = 0;

        // we can prepare this callback once for all channels
        // see also _p._nextTrigger
        this._delayedTriggerData = Object.create(null);
        this.__delayedTrigger = this._delayedTrigger.bind(this);
    }

    var _p = StyleDict.prototype;
    _p.constructor = StyleDict;

    /**
     * adds the methods:
     *    onPropertyChange(propertyName, subscriberData) // returns subscriptionId
     *    offPropertyChange(subscriptionId)
     *    _triggerPropertyChange(propertyName, eventData)
     *
     * these are used mostly for inter-StyleDict communication / cache invalidation
     */
    emitterMixin(_p, propertyChangeEmitterSetup);

    /**
     * adds the methods:
     *    on(channel, subscriberData) // returns subscriptionId
     *    off(subscriptionId)
     *    _trigger(channel, eventData)
     */
    emitterMixin(_p);

    _p._getSubscriptionUid = function(item, key) {
        var uid;
        if(item instanceof _MOMNode) {
            if(key instanceof SelectorList)
                // TODO: currently all subtree changes are handled as one.
                // I think we may become finer grained here. Like for example
                // only fire if a change in a subtree affects the result
                // of item.query(key); then, the SubscriptionUid must be
                // different for different selectors. Until then all selectors
                // for a _MOMNode have the same SubscriptionUid:
                return item.nodeID + 'S:$';// + key
            else
                return item.nodeID + ':' + key;
        }
        else if(item instanceof StyleDict)
            return '!' + item.element.nodeID + ':' + key;
        // fallback, rare cases
        uid = this._subscriptionUids.get(item);
        if(!uid) {
            uid = '?' + (this._uidCounter++) + ':' + key;
            this._subscriptionUids.set(item, uid);
        }
        return uid;
    };

    _p._unsubscribeFromAll = function(key) {
        // we have probably collected dependencies for this cache, since
        // the cache is now invalidated, the dependencies can be unsubscribed
        var dependencies = this._cacheDependencies[key]
          , subscriptionUid
          , subscription
          , i, l
          ;
        if(!dependencies)
            return;
        for(i=0,l=dependencies.length;i<l;i++) {
            subscriptionUid = dependencies[i];
            subscription = this._cacheSubscriptions[subscriptionUid];
            // remove dependency key from subscription
            delete subscription[2][key];//index
            subscription[3]--;//counter
            if(subscription[3])
                continue;
            // no deps left
            subscription[0].offPropertyChange(subscription[1]);
            delete this._cacheSubscriptions[subscriptionUid];
        }
        delete this._cacheDependencies[key];
    };

    /**
     *  if key is in cache, invalidate the cache and inform all subscribers/dependants
     */
    _p._invalidateCache = function(key) {
        // FIXME:
        // This event should fire whenever the value of the dict
        // changed in a way, so that e.g. a redraw of a glyph is needed
        // _invalidateCache seems resonable at the moment, but it might be
        // a source of subtle bugs, when the event was not fired but should
        // have been. So keep an eye on this.
        this._nextTrigger('change', key);

        if(!(key in this._cache)) {
            // Because the key is not cached, there must not be any dependency or dependant
            assert(!this._cacheDependencies[key] || !this._cacheDependencies[key].length
                , 'Because the key is not cached, there must not be any dependency or dependant');
            // FIXME: this should be the concern of the channel: PropertyChange
            // it certainly is wrong in here... remove without replacement when everything works
            // fine.
            assert(!this._dependants[key] || !this._dependants[key].length
                , 'Because the key is not cached, there must not be any dependency or dependant');
            return;
        }
        // remove this this._invalidatingKeys when there are no errors
        if(!this._invalidatingKeys)
            this._invalidatingKeys = Object.create(null);
        assert(!(key in this._invalidatingKeys), 'Key ' + key + 'is beeing invalidated at the moment: '+ Object.keys(this._invalidatingKeys));
        this._invalidatingKeys[key] = true;


        this._invalidating +=1;
        delete this._cache[key];
        this._unsubscribeFromAll(key);
        this._triggerPropertyChange(key);
        this._invalidating -= 1;
        delete this._invalidatingKeys[key];
        assert(!(key in this._cache), '"'+key + '" was just deleted, '
                    + 'yet it is still there: ' + Object.keys(this._cache));
    };

    /**
     * Schedule an event to fire after all synchronous tasks are finished
     * using a simple setTimeout(,0); a subsequent call to this._nextTrigger
     * will delay the timeout again and add it's data to the scheduled data.
     *
     * For now this is enough debouncing, however, we may need better
     * mechanics in the future.
     */
    _p._nextTrigger = function(channelKey, data) {
        /*global setTimeout:true, clearTimeout:true*/
        // FIXME: use https://github.com/YuzuJS/setImmediate/blob/master/setImmediate.js
        //        instead of setTimeout, everywhere not just here!
        var channel = this._delayedTriggerData[channelKey];
        if(!channel)
            channel = this._delayedTriggerData[channelKey] = {
                timeoutID: null
              , data: []
            };
        if(arguments.length > 1)
            channel.data.push(data);
        if(channel.timeoutID)
            return;
            // all _nextTrigger calls will hapen during one synchronous process
            // so there's no need to clearTimeout
            // FIXME: TODO: in the future there may be asynchronisity introduced
            // via the renderer. Then we should switch to a promise that triggers
            // when it's done (using the "then" interface of the promise)
            // clearTimeout(channel.timeoutID);

        channel.timeoutID = setTimeout(this.__delayedTrigger, 0, channelKey);
    };

    /**
     * This is only ever called via _nextTrigger and the
     * this.__delayedTrigger bound method
     */
    _p._delayedTrigger = function(channelKey) {
        var channel = this._delayedTriggerData[channelKey];
        if(!channel)
            throw new AssertionError('The data for "'+ channelKey +'" is missing.');
        delete this._delayedTriggerData[channelKey];
        this._trigger(channelKey, (channel.data.length ? channel.data : undefined));
    };

    _p._invalidateCacheHandler = function(subscriptionUid) {
        assert(subscriptionUid in this._cacheSubscriptions, 'must be subscribed now');
        var dependencies = Object.keys(this._cacheSubscriptions[subscriptionUid][2])
          , i, l
          ;
        for(i=0,l=dependencies.length;i<l;i++)
            this._invalidateCache(dependencies[i]);
        assert(!(subscriptionUid in this._cacheSubscriptions), 'must NOT be subscribed anymore');
    };

    _p._subscribeTo = function(item, key) {
        var subscriberId
          , subscriptionUid = this._getSubscriptionUid(item, key)
          , current = this._getting.current
          , dependencies = this._cacheSubscriptions[subscriptionUid]
          ;
        // add dependency current to subscriptionUid
        if(!dependencies) {
            if(key instanceof SelectorList) {
                // TODO: this can be controlled finer. But at the moment
                // we don't do MOM tree changes anyways.
                assert(item instanceof _MOMNode, 'When "key" is a Selector '
                        +'"item" must be a MOM Element.');
//                subscriberId = item.onSubtreeChange(key, [this, '_invalidateCacheHandler'], subscriptionUid);
//                TODO: make _MOMNode.onSubtreeChange
//                      and any *.cps_proxy.onPropertyChange
                // FIXME: we don't do this currently
                return;
            }
            else if(typeof item.onPropertyChange !== 'function') {
                // NOTE, when the value at item[key] can change, that
                // onPropertyChange and offPropertyChange must be implemented
                // when item is "immutable", we don't need this
                return;
            }
            else {

                subscriberId = item.onPropertyChange(key, [this, '_invalidateCacheHandler'], subscriptionUid);
            }
            dependencies = this._cacheSubscriptions[subscriptionUid]
                         = [item, subscriberId, Object.create(null), 0];
        }
        else if(current in dependencies[2])
            // that cache already subscribed to item.key
            return;
        dependencies[2][current] = true;//index
        dependencies[3] += 1;// counter

        if(!this._cacheDependencies[current])
            this._cacheDependencies[current] = [];
        this._cacheDependencies[current].push(subscriptionUid);
    };

    _p._genericGetter = function (item, key) {
        var result;
        if(item === undefined) {
            // used to be a
            // pass
            // is this happening at ALL?
            // in which case?
            // is that case legit?
            // console.trace();
            throw new Error('trying to read "'+key+'" from an undefined item');
            // also see cpsGetters.whitelist for a similar case
        }
        else if(item instanceof _MOMNode) {
            var cs = item.getComputedStyle();
            result = cs.get(key);
            this._subscribeTo(cs, key);
        }
        else if(item.cps_proxy) {
            // FIXME:
            // do we need this case at all? probably when item is a
            // PenStrokePoint.skeleton and key is on/in/out
            // I don't know if there's another case
            // This means, however that everything that has a cps_proxy
            // will have to provide a `onPropertyChange` API (which makes totally sense)
            // arrays are obviously exceptions...
            // so, the do we need this subscription at all question arises again
            //
            // FIXME: can't we just not subscribe to this and do the same as with array
            // that is the original source of this item must be subscribed and =
            // fire if item changes...
            // it is probably happening in __get anyways, like this
            // cpsGetters.whitelist(this.element, key);
            // and then a this._subscribeTo(this.element, key)
            // REMEMBER: this code was extracted from a merge of
            // cpsGetters.generic plus cpsGetters.whitelist
            // so, in the best case, we wouldn't use this condition at all,
            // I think
            result = item.cps_proxy[key];
            this._subscribeTo(item, key);
        }
        else if(item instanceof Array)
            result = whitelistProxies.array(item)[key];
            // no subscription! the source of the Array should be subscribed
            // to and fire when the array changes
        else
            throw new KeyError('Item "'+item+'" doesn\'t specify a whitelist for cps, trying to read '+key);
        return result;
    };


    _p._buildIndex = function() {
        var i, l, j, ll, keys, key, parameters, subscriberID;
        if(this._rules === null)
            // lazy rule getting, this call is most expensive
            this._rules = this._controller.getRulesForElement(this.element);
        this._dict = Object.create(null);
        for(i=0,l=this._rules.length;i<l;i++) {
            parameters = this._rules[i].parameters;
            subscriberID = parameters.on('add', [this, '_parameterAddHandler'], i);
            this._dictSubscriptions.push([parameters, subscriberID]);

            keys = parameters.keys();
            for(j=0, ll=keys.length; j<ll; j++) {
                key = keys[j];
                if(!(key in this._dict))
                    this._setDictValue(parameters, key, i);
            }
        }
    };

    _p._unsubscribeFromDicts = function(){
        var i, l, subscription;
        for(i=0,l=this._dictSubscriptions.length;i<l;i++) {
            subscription = this._dictSubscriptions[i];

            // Uncaught UnhandledError: EmitterError:
            // Unsubscription without subscription from channel:
            //                  "add" with subscriberID: "1"
            subscription[0].off(subscription[1]);
        }
        this._dictSubscriptions = [];
    };
   /**
     * This method is called when the ParameterCollection of this styleDict
     * changed so much that the this._rules (rules) list needs to be rebuild
     *
     * Changes in the ParameterCollection that are of this kind are:
     * added or removed Rules
     * SelectorList changes (it's always replacement) of Rules OR AtNamespaceCollections
     * A reset of the ParameterCollection (which does all of the above)
     *
     * The value of this StyleDict may not change in the end but we don't
     * know that before)
     *
     * This doesn't include add/remove events of parameters/parameterDicts,
     * we'll handle that on another level.
     *
     * not used at the moment
     */
    _p.setRules = function(rules) {
        this._rules = rules;
        this._unsubscribeFromDicts();
        this._rebuildIndex();
    };

    _p.invalidateRules = function() {
        this._rules = null;
        this._unsubscribeFromDicts();
        // note: copypasta from _p._rebuildIndex
        // which is unused at the moment
        var key;
        for(key in this._dict) {
            this._unsetDictValue(key);
            this._invalidateCache(key);
        }
        // this is needed to trigger _buildIndex when it is time:
        this._dict = null;
    };

    _p._rebuildIndex = function() {
        var key;
        for(key in this._dict) {
            this._unsetDictValue(key);
            this._invalidateCache(key);
        }
        this._buildIndex();
    };

    /**
     * parameters.onPropertyChange wont trigger on "add", because we won't
     * have subscribed to it by then.
     */
    _p._parameterAddHandler = function(data, channelKey, key) {
        var index = data
          , parametersIndexForKey = this._propertySubscriptions[key]
                    ? this._propertySubscriptions[key][2]
                    : undefined
          ;

        if(parametersIndexForKey > index)
            // the higher index overrides the lower index
            return;
        else if(parametersIndexForKey < index) {
            this._unsetDictValue(key);
            this._invalidateCache(key);
        }
        else if(parametersIndexForKey === index)
            // When both are identical this means we don't have an "add"
            // event by definition! Something in the programming logic went
            // terribly wrong.
            throw new AssertionError('The old index must not be identical '
                        + 'to the new one, but it is.\n index: ' + index
                        + ' key: ' + key
                        + ' channel: ' + channelKey);
        this._setDictValue(this._rules[index].parameters, key, index);
    };

    _p._setDictValue = function(parameters, key, parametersIndex) {
        assert(!(key in this._propertySubscriptions), 'there may be no dependency yet!');
        var subscription = this._propertySubscriptions[key] = [];
        this._dict[key] = parameters.get(key);
        subscription[0] = parameters;
        subscription[1] = parameters.onPropertyChange(key, [this, '_paramerChangeHandler'], parameters);
        subscription[2] = parametersIndex;
    };

    _p._unsetDictValue = function(key) {
        var subscription = this._propertySubscriptions[key];
        subscription[0].offPropertyChange(subscription[1]);
        delete this._dict[key];
        delete this._propertySubscriptions[key];
    };

    /**
     *  remake the this._dict entry for key
     */
    _p._updateDictEntry = function(key) {
        var i, l, parameters;
        this._unsetDictValue(key);
        for(i=0,l=this._rules.length;i<l;i++) {
            parameters = this._rules[i].parameters;
            if(!parameters.has(key))
                continue;
            this._setDictValue(parameters, key, i);
            break;
        }
        this._invalidateCache(key);
    };

    _p._paramerChangeHandler = function(parameters, key, eventData) {
        switch(eventData) {
            case('change'):
                // The value is still active and available, but its definition changed
                this._dict[key] = parameters.get(key);
                this._invalidateCache(key);
                break;
            case('delete'):
                // the key of parameters was removed without replacement
                // remove the entry and look for a new one
                this._updateDictEntry(key);
                break;
            default:
                throw new ReceiverError('Expected an event of "change" or '
                                       + '"delete" but got "'+eventData+'"');
        }
    };

    Object.defineProperty(_p, 'keys', {
        get: function() {
            if(!this._dict) this._buildIndex();
            return Object.keys(this._dict);
        }
    });

    /**
     * Get a cps ParameterValue from the _rules
     * This is needed to construct the instance of the Parameter Type.
     * Returns Null if the key is not defined.
     */
    _p._getCPSParameterValue = function(key) {
        if(!this._dict) this._buildIndex();
        return (key in this._dict) ? this._dict[key] : null;
    };

    /**
     * Return a new instance of ParameterValue or null if the key is not defined.
     */
    _p._getParameter = function(key) {
        var cpsParameterValue = this._getCPSParameterValue(key);
        if(cpsParameterValue === null)
            return null;
        return cpsParameterValue.factory(key, this.element, this.getAPI);
    };

    _p.__get = function(key, errors) {
        var param = this._getParameter(key)
          , result
          ;
        if(param)
           return param.getValue();
        errors.push(key + ' not found for ' + this.element.particulars);
        // FIXME: prefer the following, then the cpsGetters module can be removed!
        // if that is not possible, it's certainly interesting why
        result = this.element.cps_proxy[key];
        // old:
        // result = cpsGetters.whitelist(this.element, key);
        this._subscribeTo(this.element, key);
        return result;
    };
    /**
     * Look up a parameter in this.element according to the following
     * rules:
     *
     * 1. If `key' is "this", return the MOM Element of this StyleDict
     * (this.element). We check "this" first so it can't be overridden by
     * a @dictionary rule.
     *
     * 2. If `key' is defiened in CPS its value is returned.
     *
     * 3. If key is available/whitelisted at this.element, return that value.
     *
     * 4. throw KeyError.
     *
     * If `key' is a registered parameter type, the return value's type is
     * the parameter type or an error will be thrown;
     * Otherwise, the return value may be anything that is accessible
     * or constructable from CPS formulae, or a white-listed value on
     * any reachable element.
     */
    _p._get = function(key) {
        var errors = [], getting;
        if(key === 'this')
            return this.element;

        getting = this._getting;
        // Detect recursion on this.element
        if(key in getting.recursionDetection)
            throw new CPSRecursionError('Looking up "' + key
                            + '" is causing recursion in the element: '
                            + this.element.particulars);

        getting.recursionDetection[key] = true;
        getting.stack.push(getting.current);
        getting.current = key;
        try {
            return this.__get(key, errors);
        }
        catch(error) {
            if(!(error instanceof KeyError))
                throw error;
            errors.push(error.message);
            throw new KeyError(errors.join('\n----\n'));
        }
        finally {
            delete getting.recursionDetection[key];
            getting.current = getting.stack.pop();
        }
    };
    // FIXME: memoize seems to be slower, can we fix it?
    //_p.get = memoize('get', _p._get);
    _p.get = function(key) {
        if(this._invalidating)
            throw new AssertionError('This is invalidating, so get is illegal: ' + this.element.type + ' ' + this.element.nodeID);
        var val = this._cache[key];
        if(val === undefined)
            this._cache[key] = val = this._get(key);
        return val;
    };

    return StyleDict;
});

define('metapolator/models/CPS/parsing/curry',[

], function (

) {
    
    /**
     * similar to function.prototype.bind, but it doesn't set
     * the value of 'this'
     *
     */
    function curry(func/* args */) {
        var args = Array.prototype.slice.call(arguments, 1);
        return function() {
           return func.apply(this, args.concat(
                        Array.prototype.slice.call(arguments)));
        };
    }
    return curry;
});

define('metapolator/models/CPS/elements/AtRuleName',[
    './_Name'
], function(
    Parent
) {
    
    /**
     * The name of an AtRule.
     */
    function AtRuleName(name, comments ,source, lineNo) {
        Parent.call(this, name, comments ,source, lineNo);
    }
    var _p = AtRuleName.prototype = Object.create(Parent.prototype);
    _p.constructor = AtRuleName;

    return AtRuleName;
});

define('metapolator/models/CPS/elements/AtNamespaceCollection',[
    'metapolator/errors'
  , './ParameterCollection'
  , './SelectorList'
], function(
    errors
  , Parent
  , SelectorList
) {
    
    var CPSError = errors.CPS
      , ValueError = errors.Value
      ;
    /**
     * A list of Rule, AtRuleCollection, ParameterCollection, and
     * Comment Elements
     */
    function AtNamespaceCollection(name, selectorList, items, source, lineNo) {
        // The _allowNamespace property of this prototype tells the Parent
        // constructor to not look up this.name
        Parent.call(this, items, source, lineNo);
        this._selectorList = null;
        if(name)
            this.name = name;
        if(selectorList)
            this.selectorList = selectorList;
    }

    var _p = AtNamespaceCollection.prototype = Object.create(Parent.prototype);
    _p.constructor = AtNamespaceCollection;

    _p._allowNamespace = true;

    _p.toString = function() {
        return ['@',this.name, '(', this.selectorList,')', ' {\n',
            this._items.join('\n\n') ,'\n}'].join('');
    };

    Object.defineProperty(_p, 'invalid', {
        get: function() {
            return !this._selectorList || this._selectorList.invalid;
        }
    });

    /**
     * Selectorlist may be invalid when it is set initially.
     * This is that the parser can set selectorlist even if it
     * was invalid in the source file, but the API should not be allowed
     * to do so dynamically.
     * If the api creates a new AtNamespaceCollection it still
     * can set an invalid selectorlist (or none). There is however little
     * use for it because an invalid AtNamespaceCollection wont be accepted
     * by a parent ParameterCollection. If there's a problem with this
     * behavior we may change it.
     */
    function setSelectorList (selectorList) {
        /*jshint validthis: true*/
        if(!(selectorList instanceof SelectorList)) {
            throw new CPSError('selectorList has the wrong type, expected '
                + 'SelectorList but got: '
                + (selectorList ? (selectorList.constructor.name
                    ? selectorList.constructor.name
                    : selectorList.constructor): selectorList));
        }
        else if(selectorList.invalid && this._selectorList !== null)
            throw new ValueError('trying to set an invalid selectorList: '+ selectorList);

        this._selectorList = selectorList;
        this._unsetRulesCache();
        this._trigger(['selector-change', 'structural-change']);
    }

    _p.setSelectorList = setSelectorList;

    Object.defineProperty(_p, 'selectorList', {
        enumerable: true
      , set: setSelectorList
      , get: function() {
            return this._selectorList;
        }
    });

    /**
     * Wrapper to add the namespace to the rules returned by
     * Parant.prototype._getRules
     */
    _p._getRules = function() {
        var rules, i, l
          , namespace = this.selectorList
          ;
        if(namespace.invalid)
            return [];
        rules = Parent.prototype._getRules.call(this);
        for(i=0,l=rules.length;i<l;i++) {
            var chk = rules[i][1].parameters.has('__intersection');
            // NOTE: Parent.prototype._getRules must copy rule arrays
            // of collections of which the rules are going to be reused!
            // FIXME: is is better do always create a copy here?
            // that would spare that test in Parent.prototype._getRules
            // rules[i] = [namespace.multiply(rules[i][0]), rules[i][1]]
            rules[i][0] = namespace.multiply(rules[i][0]);
        }
        return rules;
    };

    return AtNamespaceCollection;
});

define('metapolator/models/CPS/parsing/parameterFactories',[
    'metapolator/errors'
  , './curry'
  , './selectorFactories'
  , 'metapolator/models/CPS/elements/ParameterDict'
  , 'metapolator/models/CPS/elements/Parameter'
  , 'metapolator/models/CPS/elements/ParameterName'
  , 'metapolator/models/CPS/elements/ParameterValue'
  , 'metapolator/models/CPS/elements/AtRuleName'
  , 'metapolator/models/CPS/elements/AtNamespaceCollection'
  , 'metapolator/models/CPS/elements/SelectorList'
  , 'gonzales/gonzales'
  , './parseSelectorList'
], function (
    errors
  , curry
  , selectorFactories
  , ParameterDict
  , Parameter
  , ParameterName
  , ParameterValue
  , AtRuleName
  , AtNamespaceCollection
  , SelectorList
  , gonzales
  , parseSelectorList
) {
    
    /*jshint sub:true*/
    var CPSError = errors.CPS;

    /**
     * Constructors OR factory functions
     * this can be both because JavaScript allows to call a factory function
     * using the new operator like in `new myfactory()`. The factory must
     * return a new object in this case.
     *
     * all constructors take the following arguments: (node, source)
     * @node: object as created by parserEngine._makeNode and augmented by
     * parserEngine
     * @source: instance of parameters/Source
     *
     * We'll use mostly factories, because the "node" we use as argument
     * is not exactly a nice interface. However, it's called _nodeConstructors
     * because that implies that these functions are being called using
     * the `new` keyword.
     *
     * see: https://github.com/css/gonzales/blob/master/doc/AST.CSSP.en.md
     */

    function genericNameFactory (Constructor, node, source) {
        var comments = node.children
                .filter(function(item) {
                    return (item.type === 'comment');
                }).
                map(function(item){
                    return item.instance;
                }
            )
          , name
          ;

        if(node.children[0].type !== '__GenericAST__'
                && node.children[0].instance.type !== 'ident')
            throw new CPSError(['The first child of "'+node.type+'" is '
                , 'expected to be an __GenericAST__ of type "ident", '
                , 'but got "', node.children[0].type, '" '
                , 'type: "', (node.children[0].instance
                        ? node.children[0].instance.type
                        : '<no instance>'), '" '
                ,'in a '+node.type+' from: ', source, 'line: '
                , node.lineNo
                ,'.'].join(''), (new Error()).stack);
        name = node.children[0].data;
        return new Constructor(name, comments ,source, node.lineNo);
    }

    // inherit from selectorFactories
    var parameterFactories = Object.create(selectorFactories);

    (function(factories){
        var k;
        for(k in factories) parameterFactories[k] = factories[k];
    })({
        /**
         * block:
         *
         * A list of
         * "declaration"
         * "decldelim" (semicolon)
         * "s" (whitespace)
         * and "comment".
         *
         * IMPORTANT: "filter" can occur, which is a like "declaration"
         * but has a special name. This was a rather random pick, I suppose.
         * We can use "filter" AS "declaration", if we need it, OR just let
         * it be a __GenericAST__. Filter has, instead of a "value" a "filterv"
         * This is a bugging inconsequence in gonzales. But we can shield
         * it from higher levels.
         *
         * We rename "declaration" as "Parameter"
         *
         * We throw away "decldelim" and "s", we keep "declaration",
         * "comment" and __GenericAST__ (which will be produced by from
         * unkown "declaration"s/properties)
         *
         * From the docs: Part of the style in the braces.
         */
        'block': function(node, source) {
            var i=0
              , items = []
              , whitelist = {
                    'comment': null,
                    'declaration': null
                }
              , astBlacklist = {
                    'decldelim': null,
                    's': null
                }
              , children = ('children' in node)
                            ? node.children
                            : []
              ;
            for(;i<children.length; i++)
                if(children[i].type in whitelist
                        || (children[i].type === '__GenericAST__'
                            && !(children[i].instance.type in astBlacklist)
                        )
                )
                    items.push(children[i].instance);
            return new ParameterDict(items, source, node.lineNo);
        }

        /**
         * declaration // Parameter:
         *
         * Key value pair of "property" and "value"
         * We rename "declaration" to "Parameter" and "property" to "ParameterName"
         *
         * We convert unkown "declaration"s into __GenericAST__
         * objects. But for performance reasons, this decision is made in
         * _makeNode.
         */
      , 'declaration': function (node, source, ruleController) {
            var name, value, factory;

            if(node.children[0].type !== 'property')
                throw new CPSError('The first child of "declaration" is '
                + 'expected to be a "property", but got "' + node.children[0].type +'" '
                +'" in a declaration from: ' + source + 'line: '
                + node.lineNo
                +'.', (new Error()).stack);

            if(node.children[1].type !== 'value')
                throw new CPSError('The second child of "declaration" is '
                + 'expected to be a "value", but got "' + node.children[1].type +'" '
                +'" in a declaration from: ' + source + 'line: '
                + node.lineNo
                +'.', (new Error()).stack);

            name = node.children[0].instance;
            value = node.children[1].instance;
            // selectorListFromString uses the parser but doesn't need
            // initialized parameters
            if(ruleController) {
                factory = ruleController.parameterRegistry.getFactory(name.name);
                value.initializeTypeFactory(name.name, factory);
            }
            return new Parameter(name, value, source, node.lineNo);
        }
        /**
         * property // ParameterName
         *
         * The name of a property.
         *
         * It has as first child an ident, which value is the actual name:
         *          ["ident", "margin"]
         * But it also can have subsequent "s" (whitespace) and "comment"
         * nodes:
         */
         // any{ background-color /*property comment*/: #fff;\n\ }
        /**
         * yields in:
         * ['property',
         *    ['ident', 'background-color'],
         *    ['s', ' '],
         *    ['comment', 'property comment']
         * ]
         *
         * The whitespace is going to be removed.
         *
         * I would try to keep the comments here, however, this is a low
         * priority, because comments are not often used at this position.
         *
         * When printing, all comments go between the name and the colon.
         */
      , 'property': curry(genericNameFactory, ParameterName)
        /**
         * value:
         *
         * The value of a property.
         *
         * It's a list of a lot of different nodes. Besides all things
         * meaningful for the value, Comments can go in here, too.
         * I propose to keep the comments, but print them at the beginning
         * of the value, followed by the value itself. Because we won't be
         * able to restore the correct place in most cases anyways.
         */
      , 'value': function(node, source) {
            var comments = []
              , value = []
              , i=0
              , children = ('children' in node)
                                ? node.children
                                : []
              ;
            for(;i<children.length;i++)
                if(children[i].type === 'comment')
                    comments.push(children[i].instance);
                else
                    value.push(children[i].instance);
            return new ParameterValue(value, comments ,source, node.lineNo);
        }
      // tinker on @namespace
      , 'atruler': function(node, source) {
            var name
              , collection
              , selectorList
              , i=0
              ;
            for(;i<node.children.length; i++)
                if(name && collection && selectorList)
                    break;
                else if(!collection
                        && node.children[i].instance instanceof AtNamespaceCollection)
                    collection = node.children[i].instance;
                else if(!name && node.children[i].instance instanceof AtRuleName)
                    name = node.children[i].instance;
                else if(!selectorList && node.children[i].instance instanceof SelectorList)
                    selectorList = node.children[i].instance;
            if ( !name
                    // we only know @namespace here!
                    || name.name !== 'namespace'
                    || !collection)
                return this['__GenericAST__'](node, source);
            // may be undefined
            // if it is, we couldn't parse it
            // an example would be: @namespace("point){}
            // note the " doesn't close
            // TODO: it would be nice to preserve the broken information.
            // so that the AtNamespaceCollection can be repaired better
            // in the ui
            if(selectorList !== undefined)
                collection.selectorList = selectorList;
            collection.name = name.name;
            return collection;
        }
      , 'atkeyword': curry(genericNameFactory, AtRuleName)
      , 'atrulerq': function(node, source, ruleController) {
            var i
              , braces
              , selectorString
              , selectorList
              ;

            // find 'braces'
            for(i=1;i<node.rawData.length;i++)
                if(node.rawData[i][0] && node.rawData[i][0] === 'braces') {
                    braces = node.rawData[i];
                    break;
                }
            if(!braces)
                return this['__GenericAST__'](node, source);

            // we need the quotes only to not break the gonzales parsing
            // in selectorsString, no qotes are necessary. So we simply
            // throw them away at this point, without checking semantics
            // gonzales will fail with non matching quotes anyways
            selectorString = gonzales.csspToSrc(braces)
                // remove the braces
                .slice(1,-1)
                // remove quotes
                .replace(/(\'|\")/gm, '')
                .split(',')
                // remove surrounding whitespace
                .map(function(item){return item.trim();})
                // remove empty entries
                .filter(function(item){return !!item.length;})
                // create a 'normalized' selectorString
                .join(', ');

            try {
                return parseSelectorList.fromString(selectorString, undefined
                        , ruleController && ruleController.selectorEngine);
            }
            catch(error) {
                if(!(error instanceof CPSError))
                    throw error;
            }

            // don't return anything particular
            return this['__GenericAST__'](node, source);
        }
        /***
         * return an AtNamespaceCollection
         * NOTE: at this moment we don't know whether or not this
         * is the collection of AtNamespace or something made up!
         * the aim is to eventually replace AtNamespaceCollection
         * with an enhanced version of ParameterCollection.
         */
      , 'atrulers': function(node, source) {
            var items = []
              , i=0
              ;
            if(!node.children)
                return this['__GenericAST__'](node, source);
            for(;i<node.children.length;i++) {
                if(node.children[i].type === '__GenericAST__'
                                && node.children[i].instance.type === 's')
                    continue;
                items.push(node.children[i].instance);
            }
            // name, selectorList
            return new AtNamespaceCollection(undefined, undefined, items, source, node.lineNo);
        }
    });

    return {
        factories: parameterFactories
      , genericNameFactory: genericNameFactory
    };
});

define('metapolator/models/CPS/parsing/atDictionaryFactories',[
    'metapolator/errors'
  , './curry'
  , './parameterFactories'
  , 'metapolator/models/CPS/elements/Parameter'
  , 'metapolator/models/CPS/elements/ParameterCollection'
  , 'metapolator/models/CPS/elements/AtRuleName'
  , 'metapolator/models/CPS/dataTypes/CPSGeneric'

], function (
    errors
  , curry
  , parameterFactories
  , Parameter
  , ParameterCollection
  , AtRuleName
  , CPSGeneric
) {
    
    var CPSError = errors.CPS
      , genericNameFactory = parameterFactories.genericNameFactory
      ;


    /**
     * Constructors OR factory functions
     * this can be both because JavaScript allows to call a factory function
     * using the new operator like in `new myfactory()`. The factory must
     * return a new object in this case.
     *
     * all constructors take the following arguments: (node, source)
     * @node: object as created by parserEngine._makeNode and augmented by
     * parserEngine
     * @source: instance of parameters/Source
     *
     * We'll use mostly factories, because the "node" we use as argument
     * is not exactly a nice interface. However, it's called _nodeConstructors
     * because that implies that these functions are beeing called using
     * the `new` keyword.
     *
     * see: https://github.com/css/gonzales/blob/master/doc/AST.CSSP.en.md
     */

    /**
     * override constructors for the purpose of @dictionary.
     * This means for all children of @dictionary we can define other rules.
     * If we don't do so, the regular rules apply. JavaScript Prototype
     * Inheritance.
     *
     * like a module pattern, to not pollute the namespace with
     * temporary variables
     */
    var atDictionaryFactories = Object.create(parameterFactories.factories)
      , atDictionaryParsingSwitch
      , _atDictionaryDeprecationWarning
      ;
    (function(factories) {
            var k;
            for(k in factories) atDictionaryFactories[k] = factories[k];
    })({
        /*jshint sub:true*/
        /**
         * Augments the AtRuleCollection created by atrulers with a name.
         */
        'atruler': function(node, source) {
            // this is an @dictionary root node
            var i = 0
              , collection
              , name
              ;
            // FIXME: remove all this ASAP, it will make the codebase
            // much smaller!

            if(!_atDictionaryDeprecationWarning) {
                _atDictionaryDeprecationWarning = true;
                console.warn("@dictionary is deprecated!\n"
                    , 'Remove all occurences of "@dictionary {" and it\'s'
                    , 'closing "}" and you should be good to go.\nThe contents of '
                    , '@dictionary will continue to work as normal parameters.'
                );
            }
            for(;i<node.children.length; i++)
                if(name && collection)
                    break;
                else if(!collection
                        && node.children[i].instance instanceof ParameterCollection)
                    collection = node.children[i].instance;
                else if(!name && node.children[i].instance instanceof AtRuleName)
                    name = node.children[i].instance;
            if(!collection || !name)
                return this['__GenericAST__'](node, source);
            //collection.name = name;
            return collection;
        }
      , 'atkeyword': curry(genericNameFactory, AtRuleName)
      , 'atrulers': function(node, source) {
            var items = []
              , i=0
              ;
            for(;i<node.children.length;i++) {
                if(node.children[i].type === '__GenericAST__'
                                && node.children[i].instance.type === 's')
                    continue;
                items.push(node.children[i].instance);
            }
            //return new AtRuleCollection(undefined, items, source, node.lineNo);
            // We are NOT creating AtRuleCollections anymore!
            return new ParameterCollection(items, source, node.lineNo);
        }
      , 'declaration': function(node, source) {
            // this is an @dictionary declaration
            var name, value, typeDefinition;

            if(node.children[0].type !== 'property')
                throw new CPSError('The first child of "declaration" is '
                + 'expected to be a "property", but got "' + node.children[0].type +'" '
                +'" in a declaration from: ' + source + 'line: '
                + node.lineNo
                +'.', (new Error()).stack);

            if(node.children[1].type !== 'value')
                throw new CPSError('The second child of "declaration" is '
                + 'expected to be a "value", but got "' + node.children[1].type +'" '
                +'" in a declaration from: ' + source + 'line: '
                + node.lineNo
                +'.', (new Error()).stack);
            name = node.children[0].instance;
            value = node.children[1].instance;
            value.initializeTypeFactory(name.name, CPSGeneric.factory);
            return new Parameter(name, value, source, node.lineNo);
        }
    });

    function test_switchToAtDictionary(data) {
        return (data[0] === 'atruler'
              && data[1] && data[1][0] === 'atkeyword'
              && data[1][1] && data[1][1][0] === 'ident'
              && data[1][1][1] === 'dictionary'
        );
    }

    atDictionaryParsingSwitch = [test_switchToAtDictionary, atDictionaryFactories];

    return {
        factories: atDictionaryFactories
      , atDictionaryParsingSwitch: atDictionaryParsingSwitch
    };
});

define('metapolator/models/CPS/elements/AtImportCollection',[
    'metapolator/errors'
  , './ParameterCollection'
  , './_Node'
  , 'obtain/obtain'
], function(
    errors
  , Parent
  , GrandParent
  , obtain
) {
    
    var CPSError = errors.CPS;
    /**
     * Essentially a proxy for the ParameterCollection intance it references.
     *
     * The serialization results in an @import Rule, not in the actual
     * cps that the parameterCollection would produce, but we can still
     * use it as if it was the parameterCollection directly.
     *
     * Most importantly, the "rules" getter is proxied.
     *
     * Use `setResource` to initialize this object.
     *
     */
    function AtImportCollection(ruleController, source, lineNo) {
        GrandParent.call(this, source, lineNo);// setup the emitter
        this._selectorList = null;
        this._name = null;
        this.name = 'import';
        this._resourceName = null;
        this._reference = null;
        this._ruleController = ruleController;
    }
    var _p = AtImportCollection.prototype = Object.create(Parent.prototype);
    _p.constructor = AtImportCollection;

    function _makeProxyForProperty(name, description) {
        var proxy = {};
        proxy.enumerable = description.enumerable;
        proxy.configurable = description.configurable;
        if('value' in description) {
            if(typeof description === 'function') {
                // proxy call
                proxy.value = function() {
                    this._reference[0][name].apply(this._reference[0], arguments);
                };
            }
            else {
                // simple getter
                proxy.get = function() {
                    return this._reference[0][name];
                };
                // simple setter
                proxy.set = function(value) {
                    this._reference[0][name] = value;
                };
            }
        }
        else {
            if('get' in description) {
                // simple getter
                proxy.get = function() {
                    return this._reference[0][name];
                };
            }
            if('set' in description) {
                // proxy setter
                proxy.set = function(value) {
                    this._reference[0][name] = value;
                };
            }
        }
        if(!('set' in proxy))
            proxy.writable = description.writable;

        return proxy;
    }

    _p._proxyEventHandler = function(data, channelName, eventData) {
        this._trigger(channelName, eventData);
    };
    /**
     * Use the public method "setResource" rather than this.
     *
     * parameterCollection: the instance of the ParameterCollection that
     * is loaded for resourceName.
     *
     * parameterCollection is returned from this._ruleController.getRule
     */
    _p._setResource = function(resourceName, parameterCollection) {
        // assert(!parameterCollection.invalid); <= should be valid, it's from ruleController
        if(this._reference) {
            if(this._reference[0] === parameterCollection)
                return;
            this._reference[0].off(this._reference[1]);
        }

        // assert(this._resourceName !== resourceName) <= that would be a flaw in the logic somewhere
        this._resourceName = resourceName;

        // NOTE: We should subscribe on all this._reference events and
        // proxy them. At the moment, however, ParameterCollection will
        // only trigger 'structural-change', so this is it.
        this._reference = [
            parameterCollection
          , parameterCollection.on('structural-change', [this, '_proxyEventHandler'])
        ];
        this._trigger(['resource-change', 'structural-change']);
    };

    _p._getRule = function(async, resourceName) {
        return this._ruleController.getRule(async, resourceName);
    };
    /**
     * A lot of errors can happen here but we won't handle them!
     * As a last resort we can present the user what actually happened
     * but that is not happening here.
     *
     * async: the first argument, this is a obatainJS interface
     *
     * resourceName: the resource name of the @import rule
     * in `@import "bold.cps";` "bold.cps" is the resourceName
     */
    _p.setResource = obtain.factory(
        {
            parameterCollection:[false, 'resourceName', _p._getRule]
        }
      , {
            parameterCollection:[true, 'resourceName', _p._getRule]
        }
      , ['resourceName']
      , function(obtain, resourceName) {
            var parameterCollection = obtain('parameterCollection');
            this._setResource(resourceName, parameterCollection);
            return true;
        }
    );

    _p.toString = function() {
        return '@import "' + this.resourceName + '";';
    };

    Object.defineProperty(_p, 'invalid', {
        get: function() {
            return (!this._reference || this._reference[0].invalid);
        }
    });

    Object.defineProperty(_p, 'resourceName', {
        get: function(){ return this._resourceName; }
      , enumerable: true
    });

    // create some proxy properties
    (function(_p, parent) {
        var names = Object.getOwnPropertyNames(parent), i, l
          , name, description, proxyDescription
          ;
        for(i=0,l=names.length;i<l;i++) {
            name = names[i];
            // FIXME: a whitelist may be better
            // currently we make proxies for:
            // reset, items, length, rules, splice
            // reset should maybe throw an error
            if(     // only public interfaces
                    name[0] === '_'
                    // use the inherited name getter/setter
                    || name === 'name'
                    // only interfaces that are not ownProperties of this prototype
                    // so inherited stuff will be overidden
                    || _p.hasOwnProperty(name))
                continue;
            description = Object.getOwnPropertyDescriptor(parent, name);
            proxyDescription = _makeProxyForProperty(name, description);
            Object.defineProperty(_p, name, proxyDescription);
        }
    })(_p, Parent.prototype);

    return AtImportCollection;
});

define('metapolator/models/CPS/parsing/atImportFactories',[
    'metapolator/errors'
  , './curry'
  , './parameterFactories'
  , 'metapolator/models/CPS/elements/AtImportCollection'
  , 'metapolator/models/CPS/elements/AtRuleName'
  , 'metapolator/models/CPS/elements/GenericCPSNode'
], function (
    errors
  , curry
  , parameterFactories
  , AtImportCollection
  , AtRuleName
  , GenericCPSNode
) {
    
    var CPSError = errors.CPS
      , genericNameFactory = parameterFactories.genericNameFactory
      ;

    /**
     * override constructors for the purpose of @import.
     * This means for all children of @import we can define other rules.
     * If we don't do so, the regular rules apply. JavaScript Prototype
     * Inheritance.
     *
     * like a module pattern, to not pollute the namespace with
     * temporary variables
     */
    var atImportFactories = Object.create(parameterFactories.factories)
      , atImportParsingSwitch
      ;
    (function(factories) {
            var k;
            for(k in factories) atImportFactories[k] = factories[k];
    })({
        /**
         * Find the name of the resource to load and return a ParameterCollection
         */
        'atrules': function(node, source, ruleController) {
            /*jshint sub:true*/
            var args, resource, atImportCollection;
            // filter all whitespace
            args = node.children.slice(1).filter(function(child) {
                if(child.instance instanceof GenericCPSNode && child.instance.type === 's')
                    return false;
                return true;
            });

            // accept only one argument which must be a string
            if(args.length !== 1
                || !(args[0].instance instanceof GenericCPSNode
                                    && args[0].instance.type === 'string'))
                return this['__GenericAST__'](node, source);
            resource = args[0].data.slice(1,-1);

            atImportCollection = new AtImportCollection(ruleController, source, node.lineNo);
            atImportCollection.setResource(false, resource);
            // TODO: we can set up the parser easier for asynchronisity,
            // since the AtImportCollection now handles receiving the
            // parameter collection from ruleController. we could just
            // register the promise somewhere central that central place
            // would wait for all registered promises to "end (successful
            // or not, we must handle then)
            // Useful is the atImportCollection only when
            // !atImportCollection.invalid otherwise it can't be queried
            // for contents
            return atImportCollection;

        }
      , 'atkeyword': curry(genericNameFactory, AtRuleName)
    });

    function test_switchToAtImport(data) {
        return (data[0] === 'atrules'
              && data[1] && data[1][0] === 'atkeyword'
              && data[1][1] && data[1][1][0] === 'ident'
              && data[1][1][1] === 'import'
        );
    }

    atImportParsingSwitch = [test_switchToAtImport, atImportFactories];

    return {
        factories: atImportFactories
      , atImportParsingSwitch: atImportParsingSwitch
    };
});

define('metapolator/models/CPS/parsing/parseRules',[
    'metapolator/errors'
  , 'gonzales/gonzales'
  , './curry'
  , './engine'
  , './parameterFactories'
  , './atDictionaryFactories'
  , './atImportFactories'
], function (
    errors
  , gonzales
  , curry
  , parserEngine
  , parameterFactoriesModule
  , atDictionaryFactories
  , atImportFactories
) {
    
    var CPSError = errors.CPS
      , CPSParserError = errors.CPSParser
      , parameterFactories = parameterFactoriesModule.factories
      , module = {
          parser: gonzales.srcToCSSP
      }
      ;

    var factorySwitches = [
            atDictionaryFactories.atDictionaryParsingSwitch,
            atImportFactories.atImportParsingSwitch
        ]
      , rulesFromAST = curry(parserEngine, parameterFactories, factorySwitches)
      ;
    /**
     * Create a ParameterCollection from a CSS string
     */
    function rulesFromString(css, sourceName, ruleController) {
        var ast;
        try {
            ast = module.parser(css);
        }
        catch (error) {
            // gonzales throws a pure JavaScript Error, but we want more
            // certainty in the rest of our application
            throw new CPSParserError("("+sourceName+") "+error.message, error.stack);
        }

        return module.fromAST(ast, sourceName, ruleController);
    }

    module.fromString = rulesFromString;
    module.fromAST = rulesFromAST;

    return module;
});

define('metapolator/timer',[], (function(){
    var module;

    if(typeof performance !== 'undefined')
        module = function() {
            return {
                now: function(){ return performance.now(); }
            };
        };
    else if(typeof process !== 'undefined')
        module = function() {
            return {
                now: function() {
                    var time = process.hrtime();
                    return (time[0] * 1e3 ) + (time[1] * 1e-6);
                }
            };
        };
    else
        throw new Error('No timer implementation is available.');

    return module;
})());

define('metapolator/models/Controller',[
    'metapolator/errors'
  , 'metapolator/models/CPS/SelectorEngine'
  , 'metapolator/models/MOM/Multivers'
  , 'metapolator/models/MOM/Univers'
  , 'metapolator/models/CPS/elements/Rule'
  , 'metapolator/models/CPS/StyleDict'
  , 'metapolator/models/CPS/parsing/parseRules'
  , 'obtain/obtain'
  , 'metapolator/timer'
], function(
    errors
  , SelectorEngine
  , Multivers
  , Univers
  , Rule
  , StyleDict
  , parseRules
  , obtain
  , timer
) {
    
    var CPSError = errors.CPS
      , KeyError = errors.Key
      ;

    function Controller(ruleController) {
        this._ruleController = ruleController;
        this.parameterRegistry = ruleController.parameterRegistry;
        // rule names of the masters
        this._masters = {};

        this._selectorEngine = new SelectorEngine();
        this._MOM = new Multivers(this);
        this._univers = new Univers();
        this._MOM.add(this._univers);

        // {element.nodeID: styleDict}
        this._styleDicts = Object.create(null);

        // {ruleName:[parameterCollection, subscriptionID, [element.nodeIDs, ...]]}
        this._rules = Object.create(null);
    }

    var _p = Controller.prototype;

    /**
     * StyleDict constructor, can be changed by inheritance or
     * monkey patched on instances
     */
    _p.StyleDict = StyleDict;

    _p.updateChangedRule = function(async, sourceName) {
        return this._ruleController.reloadRule(async, sourceName);
    };

    _p.addMaster = function(master, sourceName) {
        this._masters[master.id] = sourceName;
        this._univers.add(master);
    };

    _p.hasMaster = function (master) {
        return master in this._masters;
    };

    _p._getMasterRule = function (master) {
        if(!(master in this._masters))
            throw new KeyError('Master "'+ master +'" not found in '
                                + Object.keys(this._masters).join(', '));
        return this._masters[master];
    };

    _p.getMasterCPS = function(async, master) {
        var ruleName = this._getMasterRule(master);
        return this._ruleController.getRule(async, ruleName);
    };

    /**
     * Used from within _getComputedStyle and StyleDict, don't use it
     * anywhere else! This is not cached here and pretty expensive.
     * If needed we will add a rules property getter to StyleDict.
     */
    _p.getRulesForElement = function(element) {
        // FIXME: hard coding global.cps is not good here, can this
        // be done configurable?
        var ruleName = element.master
                    ? this._getMasterRule(element.master.id)
                    : 'global.cps'
          , parameterCollection
          , subscriptionID
          , rules, allRules
          ;
        if(!this._rules[ruleName]) {
            // subscribe only once, this saves calling us a lot of handlers
            // for each styledict
            // we are currently not unsubscribing, becuause we don't
            // unload parameterCollections ever.
            // TODO: unload parameterCollections if they are not used anymore.
            //       Probably add a reference counter for that. Maybe this
            //       is better done in _ruleController. The unsubscription
            //       here could happen on('destroy');
            parameterCollection = this._ruleController.getRule(false, ruleName);
            subscriptionID = parameterCollection.on('structural-change', [this, '_updateRule'], ruleName);
            this._rules[ruleName] = [parameterCollection, subscriptionID, []];
        }
        else
            parameterCollection = this._rules[ruleName][0];
        allRules = parameterCollection.rules;
        rules = this._selectorEngine.getMatchingRules(allRules, element);
        this._rules[ruleName][2].push(element.nodeID);
        return rules;
    };

    _p._getComputedStyle = function(element) {
        // rules will be pulled lazily from styleDict, when needed
        var rules = null // rules = this.getRulesForElement(element)
          , styleDict = new this.StyleDict(this, element, rules)
          ;
        this._styleDicts[element.nodeID] = styleDict;
        return styleDict;
    };

    /**
     * returns a single StyleDict to read the final cascaded, computed
     * style for that element.
     */
    _p.getComputedStyle = function(element) {
        if(element.multivers !== this._MOM)
            throw new CPSError('getComputedStyle with an element that is not '
                + 'part of the multivers is not supported' + element);
        // this._styleDicts cache set in _getComputedStyle
        return this._styleDicts[element.nodeID] || this._getComputedStyle(element);
    };

    /**
     * Update each styleDict that uses the rule called `ruleName`
     */
    _p._updateRule = function(ruleName) {
        var ids = this._rules[ruleName][2]
          , parameterCollection = this._rules[ruleName][0]
          , allRules, styleDict, rules
          , i, l
          ;
        allRules = parameterCollection.rules;
        for(i=0,l=ids.length;i<l;i++) {
            styleDict = this._styleDicts[ ids[i] ];
            styleDict.invalidateRules();
            continue;
        }
    };

    _p._checkScope = function(_scope) {
        var i, scope;
        if(!_scope)
            return [this._MOM];
        scope = _scope instanceof Array
            ? _scope
            : [_scope]
            ;
        for(i=0;i<scope.length;i++)
            if(scope[i].multivers !== this._MOM)
                throw new CPSError('Query with a scope that is not '
                    +'part of the multivers is not supported '
                    + scope[i].particulars);
        return scope;
    };

    _p.queryAll = function(selector, scope) {
        var result = this._selectorEngine.queryAll(this._checkScope(scope), selector);
        // monkey patching the returned array.
        // it may become useful to invent an analogue to Web API NodeList
        result.query = this._selectorEngine.queryAll.bind(this._selectorEngine, result);
        return result;
    };

    _p.query = function(selector, scope) {
        return this._selectorEngine.query(this._checkScope(scope), selector);
    };

    return Controller;
});

define('metapolator/models/CPS/RuleController',[
    'metapolator/errors'
  , 'metapolator/models/CPS/parsing/parseRules'
  , 'obtain/obtain'
], function(
    errors
  , parseRules
  , obtain
) {
    
    var KeyError = errors.Key
      , CPSRecursionError = errors.CPSRecursion
      ;

    // FIXME: note that we have a race condition in here:
    //        One request with an older result can respond after
    //        a newer result was cached, the most obvious example
    //        is:
    //              ruleController.getRule(true, name)
    //              ruleController.getRule(false, name)
    //
    //        The second call will write the cache before the first call.
    //        This problem exists with all asynchronous requests, of
    //        course, but in this case it is more probable.
    //        See the implementation of `getRule` (the `rule` getter)
    //        for an attempt to improve the situation, and a further comment.

    function RuleController(io, parameterRegistry, cpsDir, selectorEngine) {
        this._io = io;
        this._cpsDir = cpsDir;
        this._commissionIdCounter = 0;
        this._rules = Object.create(null);
        Object.defineProperty(this, 'parameterRegistry', {
            value: parameterRegistry
          , enumarable: true
          , writable: false
        });
        Object.defineProperty(this, 'selectorEngine', {
            value: selectorEngine
          , enumarable: true
          , writable: false
        });
    }

    var _p = RuleController.prototype;

    _p._isCached = function(sourceName) {
        return (sourceName in this._rules) && this._rules[sourceName].cached;
    };

    _p._set = function(sourceName, rule, commissionId) {
        var record;
        if(!(sourceName in this._rules))
            record = this._rules[sourceName] = {parameterCollection: rule};
        else {
            record = this._rules[sourceName];
            record.parameterCollection.reset(rule.items, rule.source, rule.lineNo);
        }
        record.commissionId = commissionId;
        record.cached = true;
    };

    _p._readFile = function(async, fileName) {
                            return this._io.readFile(async, fileName); };

    _p._getRule = obtain.factory(
        {
            fileName: ['importing', 'sourceName', function(importing, sourceName) {
                if(sourceName in importing)
                throw new CPSRecursionError(sourceName + ' @imports itself: '
                                    + Object.keys(importing).join('  '));
                importing[sourceName] = true;
                return [this._cpsDir, sourceName].join('/');}]
          , cps: [false, 'fileName', 'commissionId', _p._readFile]
          , api: ['importing', function(importing) {
                // return the api needed by parseRules.fromString
                // but create a version of `_getRule` that is aware of the
                // @import history `importing`
                var api = {
                    parameterRegistry: this.parameterRegistry
                  , selectorEngine: this.selectorEngine
                  , getRule: function ruleControllerGetRuleAPI(async, sourceName) {
                                return this._getRule(async, importing, sourceName);
                             }.bind(this)
                };
                return api;
            }]
          , rule: ['cps', 'sourceName', 'commissionId', 'importing', 'api',
                function(cps, sourceName, commissionId, importing, api) {
                    if(!this._isCached(sourceName)
                            // There is a current cache but it was commissioned
                            // before this request, and finished loading before it.
                            // FIXME: a maybe better alternative would be
                            //        to fail here!
                            || this._isCached(sourceName) && commissionId >= this._rules[sourceName].commissionId)
                    {
                        var rule = parseRules.fromString(cps, sourceName, api);
                        this._set(sourceName, rule, commissionId);
                    }
                    delete importing[sourceName];
                    return this._rules[sourceName].parameterCollection;
                }]
          , isCached: ['sourceName', _p._isCached]
          , commissionId:[function(){ return this._commissionIdCounter++;}]
        }
      , {cps: [true, 'fileName', 'commissionId', _p._readFile]}
      , [ 'importing', 'sourceName']
      , function job(obtain, importing, sourceName) {
            if(!obtain('isCached'))
                return obtain('rule');
            return this._rules[sourceName].parameterCollection;
        }
    );

    _p.getRule = function(async, sourceName) {
        // initial recursion detection stack
        var importing = Object.create(null);
        return this._getRule(async, importing, sourceName);
    };

    /**
     * Reload an existing CPS rule
     */
    _p.reloadRule = function(async, sourceName) {
        if(!(sourceName in this._rules))
            throw new KeyError('Can\'t reload rule "'+ sourceName
                                +'" because it\'s not in this controller');
        // mark as uncached
        this._rules[sourceName].cached = false;
        return this.getRule(async, sourceName);
    };
    return RuleController;
});

/**
 * Copyright (c) 2012, Lasse Fister lasse@graphicore.de, http://graphicore.de
 * 
 * You should have received a copy of the MIT License along with this program.
 * If not, see http://www.opensource.org/licenses/mit-license.php
 * 
 * This is a port of the constants of glifLib defined in robofab/branches/ufo3k/Lib/ufoLib/gliflib.py
 *
 */ 
define(
    'ufojs/ufoLib/glifLib/constants',[],
    function()
{
    
    // -------------------------
    // Reading and Writing Modes
    // -------------------------

    // this is javascript ... do we need this?
    
    // if os.name == "mac":
    //     WRITE_MODE = "wb"  # use unix line endings, even with Classic MacPython
    //     READ_MODE = "rb"
    // else:
    //     WRITE_MODE = "w"
    //     READ_MODE = "r"

    // ---------
    // Constants
    //---------
    
    return {
        LAYERINFO_FILENAME: "layerinfo.plist",
        supportedUFOFormatVersions: {1:true, 2:true, 3:true},
        supportedGLIFFormatVersions: {1:true, 2:true},
        transformationInfo: [
            // field name, default value
            ["xScale", 1],
            ["xyScale", 0],
            ["yxScale", 0],
            ["yScale", 1],
            ["xOffset", 0],
            ["yOffset", 0],
        ]
    };
});

/**
 * Copyright (c) 2012, Lasse Fister lasse@graphicore.de, http://graphicore.de
 * 
 * You should have received a copy of the MIT License along with this program.
 * If not, see http://www.opensource.org/licenses/mit-license.php
 * 
 * This is a port of the validators defined in robofab/branches/ufo3k/Lib/ufoLib/validators.py
 * The svn revision of the source file was 576 from 2012-05-11 20:00:18 +0200
 * 
 * 
 * 
 * User name to file name conversion.
 * This was taken form the UFO 3 spec.
 * 
 */
 
define(
    'ufojs/ufoLib/filenames',[
        'ufojs/main',
        'ufojs/errors'
    ],
    function(
        main,
        errors
) {
    
    var assert = errors.assert,
        NameTranslationError = errors.NameTranslation,
        setLike = main.setLike,
        
        illegalCharacters,
        reservedFileNames,
        maxFileNameLength = 255;
    
    illegalCharacters = setLike((function() {
        var arr = '" * + / : < > ? [ \ ] | \0'.split(' ');
        for(var i=1; i<32; i++)
            arr.push(String.fromCharCode(i));
        arr.push(String.fromCharCode(0x7F));
        return arr;
    })())
    reservedFileNames = setLike([
            'CON PRN AUX CLOCK$ NUL A:-Z: COM1',
            'LPT1 LPT2 LPT3 COM2 COM3 COM4'
        ].join(' ').toLowerCase().split(" "));
    
    /**
     * existing should be a case-insensitive list
     * of all existing file names.
     * 
     * from Python doctest
     * >>> userNameToFileName(u"a")
     * u'a'
     * >>> userNameToFileName(u"A")
     * u'A_'
     * >>> userNameToFileName(u"AE")
     * u'A_E_'
     * >>> userNameToFileName(u"Ae")
     * u'A_e'
     * >>> userNameToFileName(u"ae")
     * u'ae'
     * >>> userNameToFileName(u"aE")
     * u'aE_'
     * >>> userNameToFileName(u"a.alt")
     * u'a.alt'
     * >>> userNameToFileName(u"A.alt")
     * u'A_.alt'
     * >>> userNameToFileName(u"A.Alt")
     * u'A_.A_lt'
     * >>> userNameToFileName(u"A.aLt")
     * u'A_.aL_t'
     * >>> userNameToFileName(u"A.alT")
     * u'A_.alT_'
     * >>> userNameToFileName(u"T_H")
     * u'T__H_'
     * >>> userNameToFileName(u"T_h")
     * u'T__h'
     * >>> userNameToFileName(u"t_h")
     * u't_h'
     * >>> userNameToFileName(u"F_F_I")
     * u'F__F__I_'
     * >>> userNameToFileName(u"f_f_i")
     * u'f_f_i'
     * >>> userNameToFileName(u"Aacute_V.swash")
     * u'A_acute_V_.swash'
     * >>> userNameToFileName(u".notdef")
     * u'_notdef'
     * >>> userNameToFileName(u"con")
     * u'_con'
     * >>> userNameToFileName(u"CON")
     * u'C_O_N_'
     * >>> userNameToFileName(u"con.alt")
     * u'_con.alt'
     * >>> userNameToFileName(u"alt.con")
     * u'alt._con'
     * 
     */
    function userNameToFileName(
        userName,
        existing /* default {} (setLike) */,
        prefix /* default "" */,
        suffix /* default="" */
    ) {
        if(existing === undefined) existing = {};
        if(prefix === undefined) prefix = '';
        if(suffix === undefined) suffix = '';
        // the incoming name must be a unicode string
        // in js every string is that
        assert( typeof userName === 'string',
            "The value for userName must be a string.");
        // establish the prefix and suffix lengths
        var prefixLength = prefix.length,
            suffixLength = suffix.length;
        // replace an initial period with an _
        // if no prefix is to be added
        if(prefix === '' && userName[0] === ".")
            userName = "_" + userName.slice(1)
        // filter the user name
        var filteredUserName = [], i=0, character;
        for(; i<userName.length; i++) {
            character = userName[i];
            // replace illegal characters with _
            if(character in illegalCharacters)
                character = "_";
            // add _ to all non-lower characters
            else if(character != character.toLowerCase())
                character += "_";
            filteredUserName.push(character)
        }
        userName = filteredUserName.join('')
        // clip to 255
        var sliceLength = maxFileNameLength - prefixLength - suffixLength;
        userName = userName.slice(0, sliceLength);
        // test for illegal files names
        var parts = [],
            userNameParts = userName.split("."),
            fullName,
            part;
        for(var i=0; i<userNameParts.length; i++) {
            part = userNameParts[i];
            if(part.toLowerCase() in reservedFileNames)
                part = "_" + part;
            parts.push(part)
        }
        userName = parts.join('.');
        // test for clash
        fullName = prefix + userName + suffix;
        if(fullName.toLowerCase() in existing)
            fullName = handleClash1(userName, existing, prefix, suffix);
        // finished
        return fullName
    }

    /**
     * existing should be a case-insensitive list
     * of all existing file names.
     *
     * python doctest:
     * 
     * >>> prefix = ("0" * 5) + "."
     * >>> suffix = "." + ("0" * 10)
     * >>> existing = ["a" * 5]
     *
     * >>> e = list(existing)
     * >>> handleClash1(userName="A" * 5, existing=e,
     * ...		prefix=prefix, suffix=suffix)
     * '00000.AAAAA000000000000001.0000000000'
     *
     * >>> e = list(existing)
     * >>> e.append(prefix + "aaaaa" + "1".zfill(15) + suffix)
     * >>> handleClash1(userName="A" * 5, existing=e,
     * ...		prefix=prefix, suffix=suffix)
     * '00000.AAAAA000000000000002.0000000000'
     *
     * >>> e = list(existing)
     * >>> e.append(prefix + "AAAAA" + "2".zfill(15) + suffix)
     * >>> handleClash1(userName="A" * 5, existing=e,
     * ...		prefix=prefix, suffix=suffix)
     * '00000.AAAAA000000000000001.0000000000'
     */
    function handleClash1(
        userName,
        existing /* default {} (setLike) */,
        prefix /* default "" */,
        suffix /* default="" */
    ) {
        if(existing === undefined) existing = {};
        if(prefix === undefined) prefix = '';
        if(suffix === undefined) suffix = '';
        // if the prefix length + user name length + suffix length + 15 is at
        // or past the maximum length, silce 15 characters off of the user name
        var prefixLength = prefix.length,
            suffixLength = suffix.length;

        if(prefixLength + userName.length + suffixLength + 15 > maxFileNameLength){
            var l = (prefixLength + userName.length + suffixLength + 15),
                sliceLength = maxFileNameLength - l;
            userName = userName.slice(0, sliceLength);
        }
        // try to add numbers to create a unique name
        var counter = 1,
            fill = '000000000000000',
            finalName, counterStr, name, fullName;
        while(finalName === undefined) {
            counterStr = '' + counter;
            name = userName + fill.slice(0, -counterStr.length) + counterStr;
            fullName = prefix + name + suffix
            if(!(fullName.toLowerCase() in existing)){
                finalName = fullName
                break
            }
            else
                counter += 1;
            if(counter >= 999999999999999)
                break;
        }
        // if there is a clash, go to the next fallback
        if(finalName === undefined)
            finalName = handleClash2(existing, prefix, suffix);
        // finished
        return finalName;
    }
    
    /**
     * existing should be a case-insensitive list
     * of all existing file names.
     * 
     * python doctest:
     * >>> prefix = ("0" * 5) + "."
     * >>> suffix = "." + ("0" * 10)
     * >>> existing = [prefix + str(i) + suffix for i in range(100)]
     *
     * >>> e = list(existing)
     * >>> handleClash2(existing=e, prefix=prefix, suffix=suffix)
     * '00000.100.0000000000'
     *
     * >>> e = list(existing)
     * >>> e.remove(prefix + "1" + suffix)
     * >>> handleClash2(existing=e, prefix=prefix, suffix=suffix)
     * '00000.1.0000000000'
     *
     * >>> e = list(existing)
     * >>> e.remove(prefix + "2" + suffix)
     * >>> handleClash2(existing=e, prefix=prefix, suffix=suffix)
     * '00000.2.0000000000'
     */
    function handleClash2(
        existing /* default {} (setLike) */,
        prefix /* default "" */,
        suffix /* default="" */
    ) {
        if(existing === undefined) existing = {};
        if(prefix === undefined) prefix = '';
        if(suffix === undefined) suffix = '';
        
        // calculate the longest possible string
        var maxLength = maxFileNameLength - prefix.length - suffix.length,
            maxValue = [], finalName = undefined, counter = 1, fullName;
        for(var i=0; i<maxLength; i++)
            maxValue.push('9');
        maxValue = maxValue.join('');
        //try to find a number
        while(finalName === undefined) {
            fullName = prefix + counter + suffix;
            if(!(fullName.toLowerCase() in existing)){
                finalName = fullName;
                break;
            }
            else
                counter += 1;
            if(counter >= maxValue)
                break;
        }
        // raise an error if nothing has been found
        if(finalName === undefined)
            throw new NameTranslationError("No unique name could be found.")
        // finished
        return finalName;
    }
    
    //export the module
    return {
        illegalCharacters: illegalCharacters,
        reservedFileNames: reservedFileNames,
        maxFileNameLength: maxFileNameLength,
        userNameToFileName: userNameToFileName,
        handleClash1: handleClash1,
        handleClash2: handleClash2
    };
});

/**
 * Copyright (c) 2012, Lasse Fister lasse@graphicore.de, http://graphicore.de
 * 
 * You should have received a copy of the MIT License along with this program.
 * If not, see http://www.opensource.org/licenses/mit-license.php
 * 
 * This is a port of the validators defined in robofab/branches/ufo3k/Lib/ufoLib/validators.py
 * The svn revision of the source file was 576 from 2012-05-11 20:00:18 +0200
 * 
 * There are blocking functions in here:
 *    pngValidator
 *    layerContentsValidator
 * for these non-blocking counterparts exist
 *    pngValidatorAsync
 *    layerContentsValidatorAsync
 * 
 * todo:
 *    pngValidator throws NotImplementedError when 'fileObj' as Input
 *    it might be nice to have a fileObj api as seen in python
 */
 
define(
    'ufojs/ufoLib/validators',[
        'ufojs/main'
      , 'ufojs/errors'
      , 'ufojs/plistLib/main'
      , 'obtain/obtain'
    ],
    function(
        main
      , errors
      , plistLib
      , obtain
) {
    
    var enhance = main.enhance,
        isInstance = main.isInstance,
        isInt = main.isInt,
        range = main.range,
        isIntString = main.isIntString,
        isDigits = main.isDigits,
        fixedCharCodeAt = main.fixedCharCodeAt,
        assert = errors.assert,
        NotImplementedError = errors.NotImplemented,
        ValueError = errors.Value,
        //we'll return module when all public functions are assigned to it
        module = {};
    
    // -------
    // Generic
    // -------

    /**
     * This looks very different in javascript than in python. I assume
     * in javascript a type of 'object' isDictEnough. This is implemented
     * for completeness
     * 
     * Some objects will likely come in that aren't
     * dicts but are dict-ish enough.
     */
    function isDictEnough(value) {
        return typeof value === 'object';
    }
    module.isDictEnough = isDictEnough;
    
    /**
     * Generic. (Added at version 2.)
     */
    //function genericTypeValidator(value, typ) {
    //    return isInstance(value, typ);
    //}
    //module.genericTypeValidator = genericTypeValidator;
    module.genericTypeValidator = isInstance;
    
    /**
     * Generic. (Added at version 2.)
     */
    function genericIntListValidator(values, validValues) {
        if(!(validValues instanceof Array))
            throw new TypeError('genericIntListValidator expects'+
                ' validValues to be an Array');
        if(!(values instanceof Array))
            return false;
        var validValuesDict = {}, i;
        
        for(i = 0; i<validValues.length; i++)
            // must not be int just number is enough because the values
            // will be checked for being int. However, it might be a reason
            // to throw a TypeError
            if(typeof validValues[i] === 'number')
                validValuesDict[validValues[i]] = true;
        
        for(i = 0; i<values.length; i++) {
            if(!isInt(values[i]))
                return false;
            if(!(values[i] in validValuesDict))
                return false;
        }
        return true
    }
    module.genericIntListValidator = genericIntListValidator;
    
    /**
     * Generic. (Added at version 3.)
     */
    function genericNonNegativeIntValidator(value){
        if(!isInt(value) || value < 0)
            return false;
        return true;
    }
    module.genericNonNegativeIntValidator = genericNonNegativeIntValidator;
    
    /**
     * Generic. (Added at version 3.)
     */
    function genericNonNegativeNumberValidator(value) {
        if( typeof value !== 'number' || value < 0)
            return false;
        return true;
    }
    module.genericNonNegativeNumberValidator = genericNonNegativeNumberValidator;
    
    /**
     * Generic. (Added at version 3.)
     */
    function genericDictValidator(value, prototype) {
        var key, val, prototypeType, required;
        
        if(typeof prototype !== 'object')
            throw new TypeError('genericDictValidator expects  prototype'+
                ' to be type of object');
        
        // not a dict
        if(typeof value !== 'object')
            return false;
        
        // missing required keys
        for(key in prototype) {
            // prototype[key][0] is prototypeType
            // prototype[key][1] is required
            if(!prototype[key][1])
                continue;
            if(!(key in value))
                return false;
        }
        
        // unknown keys
        for(key in value)
            if( !(key in prototype) )
                return false;
        
        // incorrect types
        for(key in value) {
            val = value[key];
            prototypeType = prototype[key][0];
            required = prototype[key][1];
            // don't know if I like this continue here. the key is there
            // so the type must be correct. not?
            if( (val === undefined || val === null) && !required)
                continue;
            if(!isInstance(val, prototypeType))
                return false;
        }
        return true;
    }
    module.genericDictValidator = genericDictValidator
    
    
    // --------------
    // fontinfo.plist
    // --------------

    // Data Validators
    
    /**
     * Version 2+.
     */
    function fontInfoStyleMapStyleNameValidator(value) {
        var options = {
                "regular": true,
                "italic": true,
                "bold": true,
                "bold italic": true
            };
        return value in options;
    }
    module.fontInfoStyleMapStyleNameValidator = fontInfoStyleMapStyleNameValidator;
    
    /**
     * Version 3+.
     */
    function fontInfoOpenTypeGaspRangeRecordsValidator(value) {
        if(!(value instanceof Array))
            return false
        if(value.length === 0)
            return true
        var validBehaviors = [0, 1, 2, 3],
            dictPrototype = {
                rangeMaxPPEM:['int', true],
                rangeGaspBehavior: [Array, true]
            },
            ppemOrder = [], ppemOrderSorted, ppem, behavior, ppemValidity,
            behaviorValidity, rangeRecord, k, i;
        for(k in value) {
            rangeRecord = value[k];
            if(!genericDictValidator(rangeRecord, dictPrototype))
                return false;
            ppem = rangeRecord.rangeMaxPPEM;
            behavior = rangeRecord.rangeGaspBehavior;
            ppemValidity = genericNonNegativeIntValidator(ppem);
            if(!ppemValidity)
                return false;
            behaviorValidity = genericIntListValidator(
                behavior,
                validBehaviors
            );
            if(!behaviorValidity)
                return false;
            ppemOrder.push(ppem);
        }
        ppemOrderSorted = [].slice.call(ppemOrder).sort();
        for(var i = 0; i<ppemOrder.length; i++)
            if(ppemOrder[i] !== ppemOrderSorted[i])
                return false;
        return true;
    }
    module.fontInfoOpenTypeGaspRangeRecordsValidator = fontInfoOpenTypeGaspRangeRecordsValidator;
    
    /**
     * Version 2+.
     */
    function fontInfoOpenTypeHeadCreatedValidator(value) {
        // format: 0000/00/00 00:00:00
        
        var dateTime, date, time, year, month, day, hour, minute, second;
        
        if(typeof value !== 'string') return false;
        
        //basic formatting
        if(value.length !== 19) return false;
        
        dateTime = value.split(" ");
        if(dateTime.length !== 2) return false;
        
        date = dateTime[0].split('/');
        if(date.length !== 3) return false;
        
        time = dateTime[1].split(':');
        if(time.length !== 3) return false;
            
        // date
        year = date[0];
        month = date[1];
        day = date[2];
        
        if(year.length != 4) return false;
            
        if(month.length != 2) return false;
            
        if(day.length != 2) return false;
        
        if(!isIntString(year))return false;
        year = parseInt(year, 10);
        if(!isFinite(year)) return false;
        
        if(!isIntString(month))return false;
        month = parseInt(month, 10);
        if(!isFinite(month)) return false;
        
        if(!isIntString(day))return false;
        day = parseInt(day, 10);
        if(!isFinite(day)) return false;
        
        if(month < 1 || month > 12) return false;
        
        var monthMaxDay = new Date(year, month, 0).getDate();
        if(day < 1 || day > monthMaxDay) return false;
        
        //time
        hour = time[0];
        minute = time[1];
        second = time[2];
        
        if (hour.length != 2) return false;
        
        if (minute.length != 2) return false;
        // this will never happen as everything else is in place and has
        // the right length
        if (second.length != 2) return false;
        
        if(!isIntString(hour))return false;
        hour = parseInt(hour, 10);
        if(!isFinite(hour)) return false;
        
        if(!isIntString(minute))return false;
        minute = parseInt(minute, 10);
        if(!isFinite(minute)) return false;
        
        if(!isIntString(second))return false;
        second = parseInt(second, 10);
        if(!isFinite(second)) return false;
        
        if(hour < 0 || hour > 23) return false;
        
        if(minute < 0 || minute > 59) return false;
        
        if(second < 0 || second > 59) return false;
        
        // fallback
        return true
    }
    module.fontInfoOpenTypeHeadCreatedValidator = fontInfoOpenTypeHeadCreatedValidator;
    
    /**
     * Version 3+.
     */
    function fontInfoOpenTypeNameRecordsValidator(value) {
        if(!(value instanceof Array))
            return false;
        var dictPrototype = {
            nameID: ['int', true],
            platformID: ['int', true],
            encodingID: ['int', true],
            languageID: ['int', true],
            string: ['string', true]
        };
        for(var i=0; i<value.length; i++)
            if(!genericDictValidator(value[i], dictPrototype))
                return false;
        return true;
    }
    module.fontInfoOpenTypeNameRecordsValidator = fontInfoOpenTypeNameRecordsValidator;
    
    /**
     * Version 2+.
     */
    function fontInfoOpenTypeOS2WeightClassValidator(value) {
        if(!isInt(value)) return false;
        if(value < 0) return false;
        return true;
    }
    module.fontInfoOpenTypeOS2WeightClassValidator = fontInfoOpenTypeOS2WeightClassValidator;
    
    /**
     * Version 2+.
     */
    function fontInfoOpenTypeOS2WidthClassValidator(value) {
        if(!isInt(value))
            return false;
        if(value < 1)
            return false;
        if(value > 9)
            return false;
        return true;
    }
    module.fontInfoOpenTypeOS2WidthClassValidator = fontInfoOpenTypeOS2WidthClassValidator;
    
    /**
     * Version 2.
     */
    function fontInfoVersion2OpenTypeOS2PanoseValidator(values) {
        if(!(values instanceof Array))
            return false;
        if(values.length !== 10)
            return false;
        for(var i=0; i<values.length; i++)
            if(!isInt(values[i]))
                return false;
        // XXX further validation?
        return true;
    }
    module.fontInfoVersion2OpenTypeOS2PanoseValidator = fontInfoVersion2OpenTypeOS2PanoseValidator;
    
    /**
     * Version 3+.
     */
    function fontInfoVersion3OpenTypeOS2PanoseValidator(values) {
        if(!(values instanceof Array))
            return false;
        
        if(values.length !== 10)
            return false;
        
        for(var i=0; i<values.length; i++) {
            if(!isInt(values[i]))
                return false;
        
            if(values[i] < 0)
                return false;
        }
        // XXX further validation?
        return true;
    }
    module.fontInfoVersion3OpenTypeOS2PanoseValidator = fontInfoVersion3OpenTypeOS2PanoseValidator;
    
    /**
     * Version 2+.
     */
    function fontInfoOpenTypeOS2FamilyClassValidator(values) {
        if(!(values instanceof Array))
            return false;
        if (values.length !== 2)
            return false;
        for(var i=0; i<values.length; i++)
            if(!isInt(values[i]))
                return false
        var classID = values[0],
            subclassID = values[1];
        
        if(classID < 0 || classID > 14)
            return false;
        if(subclassID < 0 || subclassID > 15)
            return false
        return true;
    }
    module.fontInfoOpenTypeOS2FamilyClassValidator = fontInfoOpenTypeOS2FamilyClassValidator;
    
    /**
     * Version 2+.
     */
    function fontInfoPostscriptBluesValidator(values) {
        if(!(values instanceof Array))
            return false;
        if(values.length > 14)
            return false;
        if(values.length % 2)
            return false;
        for(var i=0; i<values.length; i++)
            if(!isInstance(values[i], 'number'))
                return false;
        return true;
    }
    module.fontInfoPostscriptBluesValidator = fontInfoPostscriptBluesValidator;
    
    /**
     * Version 2+.
     */
    function fontInfoPostscriptOtherBluesValidator(values){
        if(!(values instanceof Array))
            return false;
        if(values.length > 10)
            return false;
        if(values.length % 2)
            return false;
        for(var i=0; i<values.length; i++)
            if(!isInstance(values[i], 'number'))
                return false;
        return true;
    }
    module.fontInfoPostscriptOtherBluesValidator = fontInfoPostscriptOtherBluesValidator;
    
    /**
     * Version 2+.
     */
    function fontInfoPostscriptStemsValidator(values) {
        if(!(values instanceof Array))
            return false;
        if(values.length > 12)
            return false;
        for(var i=0; i<values.length; i++)
            if(!isInstance(values[i], 'number'))
                return false;
        return true;
    }
    module.fontInfoPostscriptStemsValidator = fontInfoPostscriptStemsValidator
    
    /**
     * Version 2+.
     */
    function fontInfoPostscriptWindowsCharacterSetValidator(value) {
        if(!isInt(value))
            return false;
        if(value < 1 || value > 20)
            return false;
        return true;
    }
    module.fontInfoPostscriptWindowsCharacterSetValidator = fontInfoPostscriptWindowsCharacterSetValidator;
    
    /**
     * Version 3+.
     */
    function fontInfoWOFFMetadataUniqueIDValidator(value) {
        var dictPrototype = {id: ['string', true]};
        if(!genericDictValidator(value, dictPrototype))
            return false;
        return true;
    }
    module.fontInfoWOFFMetadataUniqueIDValidator = fontInfoWOFFMetadataUniqueIDValidator;
    
    /**
     * Version 3+.
     */
    function fontInfoWOFFMetadataVendorValidator(value) {
        var dictPrototype = {
            name: ['string', true],
            url: ['string', false],
            dir: ['string', false],
            'class': ['string', false]
        };
        if(!genericDictValidator(value, dictPrototype))
            return false;
        if('dir' in value && !(value['dir'] in {'ltr': true, 'rtl' : true}))
            return false;
        return true;
    }
    module.fontInfoWOFFMetadataVendorValidator = fontInfoWOFFMetadataVendorValidator;
    
    /**
     * Version 3+.
     */
    function fontInfoWOFFMetadataCreditsValidator(value) {
        var dictPrototype = {credits: [Array, true]},
            i, credit;
        if(!genericDictValidator(value, dictPrototype))
            return false;
        if(!value["credits"].length)
            return false;
        dictPrototype = {
            name: ['string', true],
            url: ['string', false],
            role: ['string', false],
            dir: ['string', false],
            'class' : ['string', false]
        };
        for(i=0; i<value["credits"].length; i++) {
            credit = value["credits"][i];
            if(!genericDictValidator(credit, dictPrototype))
                return false;
            if('dir' in credit && !(credit['dir'] in {'ltr': true, 'rtl' : true}))
                return false;
        }
        return true;
    }
    module.fontInfoWOFFMetadataCreditsValidator = fontInfoWOFFMetadataCreditsValidator;
    
    /**
     * Version 3+.
     */
    function fontInfoWOFFMetadataDescriptionValidator(value) {
        var dictPrototype = {
            url: ['string', false],
            text: [Array, true]
        };
        if(!genericDictValidator(value, dictPrototype))
            return false;
        for(var i=0; i<value.text.length; i++)
            if(!fontInfoWOFFMetadataTextValue(value.text[i]))
                return false;
        return true;
    }
    module.fontInfoWOFFMetadataDescriptionValidator = fontInfoWOFFMetadataDescriptionValidator;
    
    /**
     * Version 3+.
     */
    function fontInfoWOFFMetadataLicenseValidator(value) {
        var dictPrototype = {
            url: ['string', false],
            text: [Array, false],
            id: ['string', false]
        };
        if(!genericDictValidator(value, dictPrototype))
            return false;
        if('text' in value)
            for(var i=0; i<value.text.length; i++)
                if(!fontInfoWOFFMetadataTextValue(value.text[i]))
                    return false;
        return true;
    }
    module.fontInfoWOFFMetadataLicenseValidator = fontInfoWOFFMetadataLicenseValidator;
    
    /**
     * Version 3+.
     */
    function fontInfoWOFFMetadataTrademarkValidator(value) {
        var dictPrototype = {text: [Array, true]};
        if(!genericDictValidator(value, dictPrototype))
            return false;
        for(var i=0; i<value.text.length; i++)
            if(!fontInfoWOFFMetadataTextValue(value.text[i]))
                return false;
        return true;
    }
    module.fontInfoWOFFMetadataTrademarkValidator = fontInfoWOFFMetadataTrademarkValidator;
    
    /**
     * Version 3+.
     */
    function fontInfoWOFFMetadataCopyrightValidator(value) {
        var dictPrototype = {text: [Array, true]};
        if(!genericDictValidator(value, dictPrototype))
            return false;
        for(var i=0; i< value.text.length; i++)
            if(!fontInfoWOFFMetadataTextValue(value.text[i]))
                return false;
        return true;
    }
    module.fontInfoWOFFMetadataCopyrightValidator = fontInfoWOFFMetadataCopyrightValidator;
    
    /**
     * Version 3+.
     */
    function fontInfoWOFFMetadataLicenseeValidator(value){
        var dictPrototype = {
            name: ['string', true],
            dir: ['string', false],
            'class' : ['string', false]
        };
        if(!genericDictValidator(value, dictPrototype))
            return false;
        if('dir' in value && !(value.dir in {'ltr': true, 'rtl': true}))
            return false;
        return true;
    }
    module.fontInfoWOFFMetadataLicenseeValidator = fontInfoWOFFMetadataLicenseeValidator;
    
    /**
     * Version 3+.
     */
    function fontInfoWOFFMetadataTextValue(value){
        var dictPrototype = {
            text: ['string', true],
            language: ['string', false],
            dir: ['string', false],
            'class' : ['string', false]
        };
        if(!genericDictValidator(value, dictPrototype))
            return false;
        if('dir' in value && !(value.dir in {'ltr': true, 'rtl': true}))
            return false;
        return true;
    }
    module.fontInfoWOFFMetadataTextValue = fontInfoWOFFMetadataTextValue;
    
    /**
     * Version 3+.
     */
    function fontInfoWOFFMetadataExtensionsValidator(value) {
        if(!(value instanceof Array))
            return false;
        if(!value.length)
            return false;
        for(var i=0; i<value.length; i++)
            if(!fontInfoWOFFMetadataExtensionValidator(value[i]))
                return false;
        return true;
    }
    module.fontInfoWOFFMetadataExtensionsValidator = fontInfoWOFFMetadataExtensionsValidator;
    
    /**
     * Version 3+.
     */
    function fontInfoWOFFMetadataExtensionValidator(value) {
        var dictPrototype = {
            names: [Array, false],
            items: [Array, true],
            id: ['string', false]
        }
        if(!genericDictValidator(value, dictPrototype))
            return false;
        if('names' in value)
            for(var i=0; i<value.names.length; i++)
                if(!fontInfoWOFFMetadataExtensionNameValidator(value.names[i]))
                    return false;
        for(var i=0; i<value.items.length; i++)
            if(!fontInfoWOFFMetadataExtensionItemValidator(value.items[i]))
                return false;
        return true;
    }
    module.fontInfoWOFFMetadataExtensionValidator = fontInfoWOFFMetadataExtensionValidator;
    
    /**
     * Version 3+.
     */
    function fontInfoWOFFMetadataExtensionItemValidator(value) {
        var dictPrototype = {
            id: ['string', false],
            names: [Array, true],
            values: [Array, true]
        };
        if(!genericDictValidator(value, dictPrototype))
            return false;
        for(var i=0; i<value.names.length; i++)
            if(!fontInfoWOFFMetadataExtensionNameValidator(value.names[i]))
                return false;
        for(var i=0; i<value.values.length; i++)
            if(!fontInfoWOFFMetadataExtensionValueValidator(value.values[i]))
                return false;
        return true;
    }
    module.fontInfoWOFFMetadataExtensionItemValidator = fontInfoWOFFMetadataExtensionItemValidator;
    
    /**
     * Version 3+.
     */
    function fontInfoWOFFMetadataExtensionNameValidator(value) {
        var dictPrototype = {
            text: ['string', true],
            language: ['string', false],
            dir: ['string', false],
            class: ['string', false]
        };
        if(!genericDictValidator(value, dictPrototype))
            return false;
        if('dir' in value && !(value.dir in {'ltr': true, 'rtl': true}))
            return false;
        return true;
    }
    module.fontInfoWOFFMetadataExtensionNameValidator = fontInfoWOFFMetadataExtensionNameValidator;
    
    /**
     * Version 3+.
     */
    function fontInfoWOFFMetadataExtensionValueValidator(value) {
        var dictPrototype = {
            text: ['string', true],
            language: ['string', false],
            dir: ['string', false],
            class: ['string', false]
        };
        if(!genericDictValidator(value, dictPrototype))
            return false;
        if('dir' in value && !(value.dir in {'ltr': true, 'rtl': true}))
            return false;
        return true;
    }
    module.fontInfoWOFFMetadataExtensionValueValidator = fontInfoWOFFMetadataExtensionValueValidator;
    
    
    // ----------
    // Guidelines
    // ----------
    
    /**
     * Version 3+.
     */
    function guidelinesValidator(value, identifiers/* default = object */) {
        if(!(value instanceof Array))
            return false;
        if(identifiers === undefined)
            identifiers = {};
        for(var i=0; i<value.length; i++) {
            var guide = value[i];
            if(!guidelineValidator(guide))
                return false;
            var identifier = guide.identifier;
            if(identifier !== undefined) {
                if(identifier in identifiers)
                    return false;
                identifiers[identifier] = true;
            }
        }
        return true
    }
    module.guidelinesValidator = guidelinesValidator;
    
    /**
     * Version 3+.
     */
    function guidelineValidator(value) {
        var dictPrototype = {
            x: ['number', false],
            y: ['number', false],
            angle: ['number', false],
            name: ['string', false],
            color: ['string', false],
            identifier: ['string', false]
        }, x, y, angle, identifier, color;
        if(!genericDictValidator(value, dictPrototype))
            return false;
        x = value.x;
        y = value.y;
        angle = value.angle;
        // x or y must be present
        if(x === undefined && y === undefined)
            return false;
        // if x or y are None, angle must not be present
        if((x === undefined || y === undefined) && angle !== undefined)
            return false;
        // if x and y are defined, angle must be defined
        if(x !== undefined && y !== undefined && angle === undefined)
            return false;
        // angle must be between 0 and 360
        if(angle !== undefined && (angle < 0 || angle > 360))
                return false;
        // identifier must be 1 or more characters
        identifier = value.identifier;
        if(identifier !== undefined && !identifierValidator(identifier))
            return false;
        // color must follow the proper format
        color = value.color;
        if(color !== undefined && !colorValidator(color))
            return false;
        return true;
    }
    module.guidelineValidator = guidelineValidator;
    
    
    // -------
    // Anchors
    // -------
    
    /**
     * Version 3+.
     */
    function anchorsValidator(value, identifiers/* default: object */) {
        if(!(value instanceof Array))
            return false;
        if(identifiers === undefined)
            identifiers = {};
        var anchor;
        for(var i=0; i<value.length; i++) {
            anchor = value[i];
            if(!anchorValidator(anchor))
                return false;
            var identifier = anchor.identifier;
            if(identifier !== undefined){
                if(identifier in identifiers)
                    return false
                identifiers[identifier] = true;
            }
        }
        return true;
    }
    module.anchorsValidator = anchorsValidator;
    
    
    /**
     * Version 3+.
     */
    function anchorValidator(value) {
        var dictPrototype = {
            x: ['number', true],
            y: ['number', true],
            name: ['string', false],
            color: ['string', false],
            identifier: ['string', false]
        }, identifier, color;
        if(!genericDictValidator(value, dictPrototype))
            return false;
        // identifier must be 1 or more characters
        identifier = value.identifier;
        if(identifier !== undefined && !identifierValidator(identifier))
            return false;
        // color must follow the proper format
        color = value.color;
        if(color !== undefined && !colorValidator(color))
            return false;
        return true;
    }
    module.anchorValidator = anchorValidator;
    
    
    // ----------
    // Identifier
    // ----------
    
    /**
     * Version 3+.
     * 
     * Valid Chars 0x20 to 0x7E:
     *      ! " # $ % & ' ( ) * + , - . / 0 1 2 3 4 5 6 7 8 9 : ; < = >
     *      ? @ A B C D E F G H I J K L M N O P Q R S T U V W X Y Z [ \
     *      ] ^ _ ` a b c d e f g h i j k l m n o p q r s t u v w x y z
     *      { | } ~
     * 
     * Python doctest
     * >>> identifierValidator("a")
     * True
     * >>> identifierValidator("")
     * False
     * >>> identifierValidator("a" * 101)
     * False
     */
    function identifierValidator(value) {
        var validCharactersMin = 0x20,
         validCharactersMax = 0x7E,
         c;
        if (typeof value !== 'string')
            return false;
        if(value.length === 0 || value.length > 100)
            return false;
        for(var i=0; i<value.length; i++) {
            c = fixedCharCodeAt(value, i);
            if(c === false)
                //was handled in the iteration before
                continue;
            if(c < validCharactersMin || c > validCharactersMax)
                return false;
        }
        return true;
    }
    module.identifierValidator = identifierValidator;
    
    
    // -----
    // Color
    // -----
    
    /**
     * Version 3+.
     *
     *  Python doctest
     *  >>> colorValidator("0,0,0,0")
     *  True
     *  >>> colorValidator(".5,.5,.5,.5")
     *  True
     *  >>> colorValidator("0.5,0.5,0.5,0.5")
     *  True
     *  >>> colorValidator("1,1,1,1")
     *  True
     *
     *  >>> colorValidator("2,0,0,0")
     *  False
     *  >>> colorValidator("0,2,0,0")
     *  False
     *  >>> colorValidator("0,0,2,0")
     *  False
     *  >>> colorValidator("0,0,0,2")
     *  False
     *
     *  >>> colorValidator("1r,1,1,1")
     *  False
     *  >>> colorValidator("1,1g,1,1")
     *  False
     *  >>> colorValidator("1,1,1b,1")
     *  False
     *  >>> colorValidator("1,1,1,1a")
     *  False
     *
     *  >>> colorValidator("1 1 1 1")
     *  False
     *  >>> colorValidator("1 1,1,1")
     *  False
     *  >>> colorValidator("1,1 1,1")
     *  False
     *  >>> colorValidator("1,1,1 1")
     *  False
     *
     *  >>> colorValidator("1, 1, 1, 1")
     *  True
     */
    function colorValidator(value) {
        if(typeof value !== 'string')
            return false;
        var parts = value.split(","),
            // this will allow things like
            // '1' '.1' '.' '31.5' '0.' '2323' '123.' '14' '12.1234' '12.1234'
            numberFormat = /^[0-9]*[.]?[0-9]*$/,
            i, part, number;
        if(parts.length != 4)
            return false;
        for(i=0; i<parts.length; i++) {
            part = parts[i].trim();
            if(!numberFormat.test(part))
                return false;
            if (  !isFinite(number = parseFloat(part))
               && !isFinite(number = parseInt(part, 10)))
                return false;
            else if (number < 0)
                return false;
            else if( number > 1 )
                return false;
        }
        return true;
    }
    module.colorValidator = colorValidator;
    
    
    // -----
    // image
    // -----
    
    /**
     * Version 3+.
     */
    function imageValidator(value) {
        var dictPrototype = {
            fileName: ['string', true],
            xScale: ['number', false],
            xyScale: ['number', false],
            yxScale: ['number', false],
            yScale: ['number', false],
            xOffset: ['number', false],
            yOffset: ['number', false],
            color: ['string', false]
        };
        if(!genericDictValidator(value, dictPrototype))
            return false;
        // fileName must be one or more characters
        if(!value.fileName.length)
            return false;
        // color must follow the proper format
        if(value.color !== undefined && !colorValidator(value.color))
            return false;
        return true
    }
    module.imageValidator = imageValidator;
    
    /**
     * Version 3+.
     *
     * This checks the signature of the image data.
     * 
     * pngValidatorSync is a blocking api like the one in python
     * pngValidatorAsync is a non-blocking api and takes a nodeJS like
     * callback as second argument
     * pngValidator uses obtainJS-like syntax: pngValidator(switch (a)sync, arg)
     */
    
    function _pngValidator(signature) {
        if(signature !== "\x89PNG\r\n\x1a\n")
            return [false, 'Image does not begin with the PNG signature.'];
        return [true, undefined];
    }
    
    function _readBytes(obtainSwitch, ioAPI, path, bytes) {
        return ioAPI.readBytes(obtainSwitch, path, bytes)
    }
    
    var pngValidator = obtain.factory(
        {// sync getters
            signature: [false, 'io', 'argPath', 8, _readBytes]
          , argPath: ['arg', function(arg) {
                assert(arg.path !== undefined, 'arg.path must be defined')
                return arg.path
            }]
        },
        {// async getters
            signature: [true, 'io', 'argPath', 8, _readBytes]
        },
        ['io', 'arg'],
        function(obtain, io, arg) {
            var signature;
            assert(
                arg !== undefined
                && (arg.path !== undefined
                || arg.data !== undefined
                || arg.fileObj !== undefined),
                'Either "path" or "data" or "fileObj" must be defined.'
            );
            if(arg.path !== undefined)
                signature = obtain('signature');
            else if (arg.data !== undefined)
                signature = arg.data.slice(0, 8);
            else if (arg.fileObj !== undefined) {
                // this depends on a proper FileObject Implementation!
                // implement this explicitly when there is a FileObject API
                throw new NotImplementedError('There\'s no FileObject available yet');
                var pos = arg.fileObj.tell();
                signature = arg.fileObj.read(8);
                arg.fileObj.seek(pos);//reset
            }
            return _pngValidator(signature);
        }
    )
    
    /**
     * synchronous pngValidator
     */
    function pngValidatorSync(io, arg) {
        return pngValidator(false, io, arg)
    }
    
    /**
     * asynchronous pngValidator
     * callback takes (error || result [bool validates, string message])
     * message is most likeley undefined when validates is true and vice versa
     */
    function pngValidatorAsync(io, arg, callback) {
        return pngValidator({unified:callback}, io, arg);
    }
    
    
    
    
    module.pngValidator = pngValidator;
    module.pngValidatorSync = pngValidatorSync;
    module.pngValidatorAsync = pngValidatorAsync;
    
    // -------------------
    // layercontents.plist
    // -------------------
    
    /**
     * Check the validity of layercontents.plist.
     * Version 3+.
     * 
     * layerContentsValidator is a blocking api like the one in python
     * layerContentsValidatorAsync is a non blocking api and takes a callback as
     * third argument
     */
    function _layerContentsValidator(value) {
        var bogusFileMessage = 'layercontents.plist in not in the correct'
                             + ' format.',
            // did we find the default layer (where directoryName === 'glyphs')
            foundDefault = false,
            usedLayerNames, usedDirectories, entry, i, j, layerName,
            directoryName, p;
        // file isn't in the right format
        if(!(value instanceof Array))
            return [false, bogusFileMessage];
        // work through each entry
        usedLayerNames = {};
        usedDirectories = {};
        for(i=0; i<value.length; i++){
            entry = value[i];
            // layer entry in the incorrect format
            if(!(entry instanceof Array))
                return [false, bogusFileMessage];
            if(entry.length !== 2)
                return [false, bogusFileMessage];
            for(j=0; j<entry.length; j++)
                if(typeof entry[j] !== 'string')
                    return [false, bogusFileMessage];
            layerName = entry[0];
            directoryName = entry[1];
            // check directory naming
            if(directoryName !== 'glyphs') {
                if(directoryName.indexOf('glyphs.') !== 0)
                    return [false, [ 'Invalid directory name (', directoryName,
                        ') in layercontents.plist.'].join('')];
            } else
                //we found the default layer
                foundDefault = true;
            if(layerName.length === 0)
                return [false, 'Empty layer name in layercontents.plist.'];
            // default layer name
            if(layerName === 'public.default' && directoryName !== 'glyphs')
                return [false, 'The name public.default is being used by'
                    +' a layer that is not the default.'];
            // check usage
            if(layerName in usedLayerNames)
                return [false, ['The layer name ', layerName,
                        ' is used by more than one layer.'].join('')];
            usedLayerNames[layerName] = true;
            if(directoryName in usedDirectories)
                return [false, [ 'The directory ', directoryName,
                    ' is used by more than one layer.'].join('')];
            usedDirectories[directoryName] = true;
        }
        // did we find the default layer (where directoryName === 'glyphs')
        if(!foundDefault)
            // missing default layer
            return [false, 'The required default glyph set is not in the UFO.'];
        return [true, undefined];
    }
    
    
    /**
     * layerContentsValidator uses obtainJS-like syntax:
     *      layerContentsValidator(switch (a)sync, value, ufoPath)
     */
    var layerContentsValidator = obtain.factory(
        { // sync
            listOfPathsExists: ['io', 'directoryNames', 'ufoPath',
            function(io, directoryNames, ufoPath) {
                var i=0
                , directoryName
                , path;
                
                for(i=0; i<directoryNames.length; i++) {
                    directoryName = directoryNames[i];
                    path = [ufoPath, directoryName].join('/');
                    if(!io.pathExists(false, path))
                        return [false, 'A glyphset does not exist at '
                            + directoryName];
                }
                return [true, undefined];
            }]
          , directoryNames: ['value', function(value) {
                return value.map(function(item){return item[1]});
            }]
        }
      , { // async
            listOfPathsExists: ['io', 'directoryNames', 'ufoPath', '_callback'
                              , '_errback', function(io, directoryNames
                                            , ufoPath, callback, errback) {
                var i = 0
                  , requested = 0 // we'll use this to determine if the test passed
                  , failed = false // ioCallback will change this
                  , directoryName
                  , path
                  , success = [true, undefined]
                  , ioCallback = function(directoryName, boolExists) {
                        requested -= 1;
                        // if it failed once we won't have to use the
                        // callbacks anymore, although it may be an option 
                        // to write this to the logs in the future
                        if(failed)
                            return;
                        if(!boolExists) {
                            failed = true;
                            callback([false, 'A glyphset does not exist at '
                                            + directoryName])
                            return;
                        }
                        if(requested === 0)
                            // all requested files where found
                            callback(success);
                    }
                  ;
                // if there was no dir in directoryNames
                if(directoryNames.length === 0) {
                    setTimeout(function(){callback(success)}, 0)
                    return;
                }
                // we just fire all now. the idea is that the io module
                // will have to throttle stuff like this in the future
                // (and should provide an api to cancel the already fired
                // requests, when possible)
                for(;i<directoryNames.length; i++) {
                    directoryName = directoryNames[i];
                    path = [ufoPath, directoryName].join('/');
                    requested += 1;
                    io.pathExists(true, path).then(ioCallback.bind(null, directoryName));
                }
            }]
        }
      , ['io', 'value', 'ufoPath']
      , function(obtain, io, value, ufoPath) {
            var result = _layerContentsValidator(value);
            if(!result[0])
                return result;
            return obtain('listOfPathsExists');
        }
    )
    
    /**
     * synchronous layerContentsValidator
     */
    function layerContentsValidatorSync(io, value, ufoPath) {
        return layerContentsValidator(false, io, value, ufoPath);
        
    }
    /**
     * asynchronous layerContentsValidator
     * callback takes (error, [bool validates,  message string || undefined])
     * message is most likeley undefined when validates is true and vice versa
     */
    function layerContentsValidatorAsync(io, value, ufoPath, callback) {
        return layerContentsValidator({unified: callback}, io, value, ufoPath)
    }
    module.layerContentsValidator = layerContentsValidator;
    module.layerContentsValidatorSync = layerContentsValidatorSync;
    module.layerContentsValidatorAsync = layerContentsValidatorAsync;
    
    
    // ------------
    // groups.plist
    // ------------
    
    /**
     * Check the validity of the groups.
     * Version 3+ (though it's backwards compatible with UFO 1 and UFO 2).
     * 
     * Python doctest
     * >>> groups = {"A" : ["A", "A"], "A2" : ["A"]}
     * >>> groupsValidator(groups)
     * (True, None)
     *
     * >>> groups = {"" : ["A"]}
     * >>> groupsValidator(groups)
     * (False, 'A group has an empty name.')
     *
     * >>> groups = {"public.awesome" : ["A"]}
     * >>> groupsValidator(groups)
     * (True, None)
     *
     * >>> groups = {"public.kern1." : ["A"]}
     * >>> groupsValidator(groups)
     * (False, 'The group data contains a kerning group with an incomplete name.')
     * >>> groups = {"public.kern2." : ["A"]}
     * >>> groupsValidator(groups)
     * (False, 'The group data contains a kerning group with an incomplete name.')
     *
     * >>> groups = {"public.kern1.A" : ["A"], "public.kern2.A" : ["A"]}
     * >>> groupsValidator(groups)
     * (True, None)
     *
     * >>> groups = {"public.kern1.A1" : ["A"], "public.kern1.A2" : ["A"]}
     * >>> groupsValidator(groups)
     * (False, 'The glyph "A" occurs in too many kerning groups.')
     */
    function groupsValidator(value) {
        var bogusFormatMessage = 'The group data is not in the correct format.',
            firstSideMapping, secondSideMapping, groupName, glyphList, d,
            i, glyphName;
        
        if(typeof value !== 'object')
            return [false, bogusFormatMessage];
        firstSideMapping = {};
        secondSideMapping = {};
        for(groupName in value) {
            glyphList = value[groupName];
            // there used to be a check for groupName beeing string
            // but with javascript groupName will always be string
            // when we iterate over the keys of an object like this
            if(!(glyphList instanceof Array))
                return [false, bogusFormatMessage];
            if(groupName.length === 0)
                return [false, 'A group has an empty name.'];
            if(groupName.indexOf('public.') === 0) {
                if(groupName.indexOf('public.kern1.') !== 0
                    && groupName.indexOf('public.kern2.') !== 0)
                    // unknown pubic.* name. silently skip.
                    continue;
                else if('public.kernN.'.length === groupName.length)
                    return [false, 'The group data contains a kerning '
                        +'group with an incomplete name.'];
                
                d = (groupName.indexOf('public.kern1.') === 0)
                    ? firstSideMapping : secondSideMapping;
                for(i=0; i<glyphList.length; i++) {
                    glyphName = glyphList[i];
                    if(typeof glyphName !== 'string')
                        return [false, ['The group data ', groupName,
                            'contains an invalid member.'].join('')];
                    if(glyphName in d)
                        return [false, ['The glyph "', glyphName,
                            '" occurs in too many kerning groups.'].join('')];
                    d[glyphName] = groupName;
                }
            }
        }
        return [true, undefined];
    }
    module.groupsValidator = groupsValidator;
    
    
    // -------------
    // kerning.plist
    // -------------
    
    /**
     * join a and b to astring that is unique for the combination of
     * a and b
     */
    var _kerningNamesHash_escapeEscape = /\\/g,
        _kerningNamesHash_escapeKomma = /,/g;
    function _kerningNamesHash_escaper(str) {
        return str.replace(
                _kerningNamesHash_escapeEscape, '\\\\'
            ).replace(
                _kerningNamesHash_escapeKomma, '\\,'
            );
    }
    function _kerningNamesHash(a, b) {
        if(typeof a !== 'string' || typeof b !== 'string')
            throw new errors.Type('Both arguments of _kerningNamesHash'
                +' must be string');
        return([a, b].map(_kerningNamesHash_escaper).join(','));
    }
    
    /**
     * This validates a passed kerning dictionary
     * using the provided groups. The validation
     * checks to make sure that there are no conflicting
     * glyph + group and group + glyph exceptions.
     * 
     * problem:
     * in python the kern dict contains keys as tuples like: kerning[left, right]
     * where left and right are group names
     * so
     * kerning= {
     *  (left, right): data,
     *  (left2, right2): data2
     * }
     * 
     * I assume for javascript that a list like the following will work out:
     * kerning = [
     *  [[left, right], data],
     *  [[left2, right2], data2]
     * ]
     * I use a helper to make a lookup object :(  _kerningNamesHash
     * 
     * Python doctest
     * >>> groups = {
     * ...     "public.kern1.O" : ["O", "D", "Q"],
     * ...     "public.kern2.E" : ["E", "F"]
     * ... }
     * >>> kerning = {
     * ...     ("public.kern1.O", "public.kern2.E") : -100,
     * ...     ("public.kern1.O", "F") : -200,
     * ...     ("D", "F") : -300,
     * ... }
     * >>> kerningValidator(kerning, groups)
     * True
     * >>> kerning = {
     * ...     ("public.kern1.O", "public.kern2.E") : -100,
     * ...     ("public.kern1.O", "F") : -200,
     * ...     ("Q", "public.kern2.E") : -250,
     * ...     ("D", "F") : -300,
     * ... }
     * >>> kerningValidator(kerning, groups)
     * False
     */
    function kerningValidator(kerning, groups) {
        if(!(kerning instanceof Array))
            throw new errors.Type('kerningValidator expects kerning to be'
            + ' an Array');
        if(typeof groups !== 'object')
            throw new errors.Type('kerningValidator expects groups to be'
            + ' typeof object');
        
        var flatFirstGroups = {},
            flatSecondGroups = {},
            groupName, glyphList, d, i, glyphName, first, second,
            firstIsGroup, secondIsGroup, firstOptions, firstGroup, glyph,
            j, secondOptions, firstGroup, kerningLookup = {}, hash, secondGroup;
        
        //make a lookup to check fast if the groups exist alredy
        for(i=0; i<kerning.length; i++) {
            first = kerning[i][0][0];
            second = kerning[i][0][1];
            // throws a ValueError when either argument is not a string
            kerningLookup[_kerningNamesHash(first, second)] = true;
        }
        // flatten the groups
        for(groupName in groups) {
            glyphList = groups[groupName];
            if(groupName.indexOf('public.kern1.') !== 0
                && groupName.indexOf('public.kern2.') !== 0)
                continue;
            if(groupName.indexOf('public.kern1.') === 0)
                d = flatFirstGroups;
            else if(groupName.indexOf('public.kern2.') === 0)
                d = flatSecondGroups;
            for(i=0; i<glyphList.length; i++){
                glyphName = glyphList[i];
                d[glyphName] = groupName;
            }
        }
        // search for conflicts
        for(i=0; i<kerning.length; i++) {
            first = kerning[i][0][0];
            second = kerning[i][0][1];
            firstIsGroup = first.indexOf('public.kern1.') === 0;
            secondIsGroup = second.indexOf('public.kern2.') === 0;
            // skip anything other than glyph + group and group + glyph
            if(firstIsGroup && secondIsGroup)
                continue;
            if (!firstIsGroup && !secondIsGroup)
                continue;
            // if the first is a glyph and it isn't in a group, skip
            if(!firstIsGroup && !(first in flatFirstGroups))
                continue;
            // if the second is a glyph and it isn't in a group, skip
            if (!secondIsGroup && !(second in flatSecondGroups))
                    continue;
            // skip unknown things
            if(firstIsGroup && !(first in groups))
                continue;
            if(firstIsGroup && !(second in flatSecondGroups))
                continue;
            if(secondIsGroup && !(second in groups))
                continue;
            if(secondIsGroup && !(first in flatFirstGroups))
                continue;
            // validate group + glyph
            if(firstIsGroup) {
                firstOptions = groups[first];
                secondGroup = flatSecondGroups[second];
                for(j=0; j<firstOptions.length; j++) {
                    glyph = firstOptions[j];
                    hash = _kerningNamesHash(glyph, secondGroup);
                    if(hash in kerningLookup)
                        return false;
                }
            }
            // validate glyph + group
            if(secondIsGroup) {
                secondOptions = groups[second];
                firstGroup = flatFirstGroups[first];
                for(j=0; j<secondOptions.length; j++) {
                    glyph = secondOptions[j];
                    hash = _kerningNamesHash(firstGroup, glyph);
                    if(hash in kerningLookup)
                        return false;
                }
            }
        }
        // fallback
        return true;
    }
    module.kerningValidator = kerningValidator;
    
    // -------------
    // lib.plist/lib
    // -------------
    
    /**
     * Check the validity of the lib.
     * Version 3+ (though it's backwards compatible with UFO 1 and UFO 2).
     *
     * Python doctest
     * >>> lib = {"foo" : "bar"}
     * >>> fontLibValidator(lib)
     * (True, None)
     *
     * >>> lib = {"public.awesome" : "hello"}
     * >>> fontLibValidator(lib)
     * (True, None)
     *
     * >>> lib = {"public.glyphOrder" : ["A", "C", "B"]}
     * >>> fontLibValidator(lib)
     * (True, None)
     *
     * >>> lib = {"public.glyphOrder" : "hello"}
     * >>> fontLibValidator(lib)
     * (False, 'public.glyphOrder is not properly formatted.')
     *
     * >>> lib = {"public.glyphOrder" : ["A", 1, "B"]}
     * >>> fontLibValidator(lib)
     * (False, 'public.glyphOrder is not properly formatted.')
     */
    function fontLibValidator(value) {
        var bogusFormatMessage = 'The lib data is not in the correct format.',
            bogusGlyphOrderMessage = 'public.glyphOrder is not properly formatted.',
            key, val, i, glyphName;
        if(plistLib.getType(value) !== 'dict')
            return [false, bogusFormatMessage];
        for(key in value) {
            val = value[key];
            // key is always string in javascript this way
            // if(typeof key !== 'string')
            //    return [false, bogusFormatMessage];
            
            // public.glyphOrder
            if(key === 'public.glyphOrder') {
                if(!(val instanceof Array))
                    return [false, bogusGlyphOrderMessage];
                for(i=0; i<val.length; i++){
                    glyphName = val[i];
                    if(typeof glyphName !== 'string')
                        return [false, bogusGlyphOrderMessage];
                }
            }
        }
        return [true, undefined];
    }
    module.fontLibValidator = fontLibValidator;
    // --------
    // GLIF lib
    // --------
    
    /**
     * Check the validity of the lib.
     * Version 3+ (though it's backwards compatible with UFO 1 and UFO 2).
     * 
     * Python doctest
     * >>> lib = {"foo" : "bar"}
     * >>> glyphLibValidator(lib)
     * (True, None)
     * 
     * >>> lib = {"public.awesome" : "hello"}
     * >>> glyphLibValidator(lib)
     * (True, None)
     * 
     * >>> lib = {"public.markColor" : "1,0,0,0.5"}
     * >>> glyphLibValidator(lib)
     * (True, None)
     * 
     * >>> lib = {"public.markColor" : 1}
     * >>> glyphLibValidator(lib)
     * (False, 'public.markColor is not properly formatted.')
     */
    function glyphLibValidator(value) {
        var bogusFormatMessage = 'The lib data is not in the correct format.',
            bogusColorMessage = 'public.markColor is not properly formatted.',
            key, val;
        if(plistLib.getType(value) !== 'dict')
            return [false, bogusFormatMessage];
            
        // the keys of value are always string in javascript, no need to check
            
        if(
            value['public.markColor'] !== undefined
            && !colorValidator(value['public.markColor'])
        )
            return [false, bogusColorMessage];
        return [true, undefined];
    }
    module.glyphLibValidator = glyphLibValidator;
    
    //export the validators
    return module;
});

/**
 * Copyright (c) 2012, Lasse Fister lasse@graphicore.de, http://graphicore.de
 * 
 * You should have received a copy of the MIT License along with this program.
 * If not, see http://www.opensource.org/licenses/mit-license.php
 * 
 * This is a port of various functions  defined in robofab/branches/ufo3k/Lib/ufoLib/gliflib.py
 *
 */ 
define(
    'ufojs/ufoLib/glifLib/misc',[
    'ufojs/main',
    'ufojs/errors',
    'ufojs/ufoLib/filenames',
    'ufojs/ufoLib/validators'
    ],
    function(
        main,
        errors,
        filenames,
        validators
) {
    
    var setLike = main.setLike,
        userNameToFileName = filenames.userNameToFileName,
        colorValidator = validators.colorValidator,
        genericTypeValidator = validators.genericTypeValidator,
        GlifLibError = errors.GlifLib;
    
    // -----------------------
    // Glyph Name to File Name
    // -----------------------
    
    /**
     * Wrapper around the userNameToFileName function in filenames.py
     */
    function glyphNameToFileName(glyphName, glyphSet) {
        var existing = {};
        for(var name in glyphSet.contents)
            existing[name.toLowerCase()] = true;
        return userNameToFileName(glyphName, existing, '', '.glif');
    }
    
    // -----------------------
    // layerinfo.plist Support
    // -----------------------

    var layerInfoVersion3ValueData = {
        'color' : {type: 'string', valueValidator: colorValidator},
        'lib' : {type: 'object', valueValidator: genericTypeValidator}
    };

    /**
     * This performs very basic validation of the value for attribute
     * following the UFO 3 fontinfo.plist specification. The results
     * of this should not be interpretted as *correct* for the font
     * that they are part of. This merely indicates that the value
     * is of the proper type and, where the specification defines
     * a set range of possible values for an attribute, that the
     * value is in the accepted range.
     */
    function validateLayerInfoVersion3ValueForAttribute(attr, value) {
        if(!(attr in layerInfoVersion3ValueData))
            return false;
        var dataValidationDict = layerInfoVersion3ValueData[attr],
            valueType = dataValidationDict['type'],
            validator = dataValidationDict['valueValidator'],
            valueOptions = dataValidationDict['valueOptions'],
            isValidValue;
        // have specific options for the validator
        if(valueOptions !== undefined)
            isValidValue = validator(value, valueOptions);
        // no specific options
        else
            if (validator === genericTypeValidator)
                isValidValue = validator(value, valueType);
            else
                isValidValue = validator(value);
        return isValidValue;
    }
    
    /**
     * This performs very basic validation of the value for infoData
     * following the UFO 3 layerinfo.plist specification. The results
     * of this should not be interpretted as *correct* for the font
     * that they are part of. This merely indicates that the values
     * are of the proper type and, where the specification defines
     * a set range of possible values for an attribute, that the
     * value is in the accepted range.
     */
    function validateLayerInfoVersion3Data(infoData) {
        var validInfoData = {}, attr, value, isValidValue;
        for(attr in infoData) {
            value = infoData[attr];
            if(!(attr in layerInfoVersion3ValueData))
                throw new GlifLibError('Unknown attribute ' + attr + '.');
            isValidValue = validateLayerInfoVersion3ValueForAttribute(attr, value);
            if(!isValidValue)
                throw new GlifLibError('Invalid value for attribute '
                    + attr + ' (' + (typeof value) + ': '+ value + ').');
            else
                validInfoData[attr] = value
        }
        return validInfoData;
    }
    
    return {
        glyphNameToFileName : glyphNameToFileName,
        layerInfoVersion3ValueData: layerInfoVersion3ValueData,
        validateLayerInfoVersion3ValueForAttribute : validateLayerInfoVersion3ValueForAttribute,
        validateLayerInfoVersion3Data : validateLayerInfoVersion3Data
    }
});

/**
 * Copyright (c) 2011, Lasse Fister lasse@graphicore.de, http://graphicore.de
 * 
 * You should have received a copy of the MIT License along with this program.
 * If not, see http://www.opensource.org/licenses/mit-license.php
 * 
 * This is a translation of BasePointToSegmentPen defined in robofab/pens/pointPen.py
 * The svn revision of the source file in trunk/Lib/ was 67 from 2008-03-11 10:18:32 +0100
 * 
 * I even copied the docstrings and comments! (These may still refer to the Python code)
 */
define(
    'ufojs/tools/pens/BasePointToSegmentPen',[
        'ufojs/main',
        'ufojs/errors',
        './AbstractPointPen'
    ],
    function(
        main,
        errors,
        AbstractPointPen
) {
    
    //shortcuts
    var enhance = main.enhance,
        NotImplementedError = errors.NotImplemented,
        assert = errors.assert;
    
    /*constructor*/
    
    /**
     * Base class for retrieving the outline in a segment-oriented
     * way. The PointPen protocol is simple yet also a little tricky,
     * so when you need an outline presented as segments but you have
     * as points, do use this base implementation as it properly takes
     * care of all the edge cases.
     */
    function BasePointToSegmentPen()
    {
        this.currentPath = null;
    };

    /*inheritance*/
    BasePointToSegmentPen.prototype = Object.create(AbstractPointPen.prototype)
    BasePointToSegmentPen.prototype.constructor = BasePointToSegmentPen;
    
    /*definition*/
    enhance(BasePointToSegmentPen, {
        beginPath: function(kwargs/*optional, object*/)
        {
            assert(this.currentPath === null,
                'currentPath is not null, call endPath');
            this.currentPath = [];
            this.currentPath.kwargs = kwargs;
        },
        /**
         * Override this method.
         * 
         * It will be called for each non-empty sub path with a list
         * of segments: the 'segments' argument.
         * 
         * The segments list contains tuples of length 2:
         * (segmentType, points)
         * 
         * segmentType is one of "move", "line", "curve" or "qcurve".
         * "move" may only occur as the first segment, and it signifies
         * an OPEN path. A CLOSED path does NOT start with a "move", in
         * fact it will not contain a "move" at ALL.
         * 
         * The 'points' field in the 2-tuple is a list of point info
         * tuples. The list has 1 or more items, a point tuple has
         * four items:
         * (point, smooth, name, kwargs)
         * 'point' is an (x, y) coordinate pair.
         * 
         * For a closed path, the initial moveTo point is defined as
         * the last point of the last segment.
         * 
         * The 'points' list of "move" and "line" segments always contains
         * exactly one point tuple.
         */
        _flushContour: function(segments, kwargs/*optional, object*/)
        {
            throw new NotImplementedError(
                'BasePointToSegmentPen has not _flushContour'
                +' endPath');
        },
        endPath: function()
        {
            assert(this.currentPath !== null,
                'currentPath is null, call beginPath');
            var points = this.currentPath
              , contour_kwargs = this.currentPath.kwargs
              ;
            this.currentPath = null;
            if(!points.length)
                return;
            if(points.length === 1) {
                // Not much more we can do than output a single move segment.
                var pt = points[0][0],
                    //segmentType = points[0][1], not using this
                    smooth = points[0][2],
                    name = points[0][3],
                    kwargs = points[0][4],
                    segments = [ ['move', [ [pt, smooth, name, kwargs] ] ] ];
                this._flushContour(segments, contour_kwargs);
                return;
            }
            segments = [];
            if(points[0][1] == 'move') {
                // It's an open contour, insert a "move" segment for the
                // first point and remove that first point from the point list.
                var pt = points[0][0],
                    //segmentType = points[0][1],// it's 'move', we just checked
                    smooth = points[0][2],
                    name = points[0][3],
                    kwargs = points[0][4];
                segments.push(['move', [ [pt, smooth, name, kwargs] ] ]);
                points.splice(0,1);
            } else {
                // It's a closed contour. Locate the first on-curve point, and
                // rotate the point list so that it _ends_ with an on-curve
                // point.
                var firstOnCurve = null;
                for (var i = 0; i < points.length; i++) {
                    var segmentType = points[i][1];
                    if(segmentType !== null) {
                        firstOnCurve = i;
                        break;
                    }
                }
                if(firstOnCurve === null) {
                    // Special case for quadratics: a contour with no on-curve
                    // points. Add a "None" point. (See also the Pen protocol's
                    // qCurveTo() method and fontTools.pens.basePen.py.)
                    points.push([null, 'qcurve', null, null, null]);
                } else {
                    //points = [].concat(points.slice(firstOnCurve+1), points.slice(0, firstOnCurve+1))
                    points = points.concat(points.splice(0, firstOnCurve+1));
                }
            }
            var currentSegment = [];
            for (var i = 0; i < points.length; i++) {
                var pt = points[i][0],
                    segmentType = points[i][1],
                    smooth = points[i][2],
                    name = points[i][3],
                    kwargs = points[i][4];
                currentSegment.push([pt, smooth, name, kwargs]);
                if(segmentType === null)
                    continue;
                segments.push([segmentType, currentSegment]);
                currentSegment = [];
            }
            this._flushContour(segments, contour_kwargs);
        },
        addPoint: function(
            pt,
            segmentType /* default null */,
            smooth /* default false */,
            name /* default null */,
            kwargs /* default an object, javascript has no **kwargs syntax */
        ) {
            segmentType = (segmentType === undefined) ? null : segmentType;
            smooth = (smooth || false);
            name = (name === undefined) ? null : name;
            kwargs = (kwargs || {});//an "options" object
            this.currentPath.push([pt, segmentType, smooth, name, kwargs]);
        }
    });
    return BasePointToSegmentPen;
});

/**
 * Copyright (c) 2011, Lasse Fister lasse@graphicore.de, http://graphicore.de
 * 
 * You should have received a copy of the MIT License along with this program.
 * If not, see http://www.opensource.org/licenses/mit-license.php
 * 
 * This is a translation of PointToSegmentPen defined in robofab/pens/adapterPens.py
 * The svn revision of the source file in trunk/Lib/ was 67 from 2008-03-11 10:18:32 +0100
 * 
 * I even copied the docstrings and comments! (These may still refer to the Python code)
 */
 
define(
    'ufojs/tools/pens/PointToSegmentPen',[
        'ufojs/main',
        'ufojs/errors',
        './BasePointToSegmentPen'
    ],
    function(
        main,
        errors,
        Parent
) {
    
    var enhance = main.enhance,
        assert = errors.assert;
    /*constructor*/
    /**
     * Adapter class that converts the PointPen protocol to the
     * (Segment)Pen protocol.
     */
    function PointToSegmentPen(
        segmentPen,
        outputImpliedClosingLine /* default: false*/
    ) {
        Parent.call(this);
        this.pen = segmentPen;
        this.outputImpliedClosingLine = (outputImpliedClosingLine || false);
    }
        
    /*inheritance*/
    PointToSegmentPen.prototype = Object.create(Parent.prototype)
    PointToSegmentPen.prototype.constructor = PointToSegmentPen;
    
    /*definition*/
    enhance(PointToSegmentPen, {
        _flushContour: function(segments)
        {
            assert(segments.length >= 1, 'Less than one segment');
            var pen = this.pen;
            if( segments[0][0] == "move" ) {
                // It's an open path.
                var closed = false,
                    points = segments[0][1];
                assert(points.length === 1, 'Points length is not 1');
                var movePt = points[0][0],
                    smooth = points[0][1],
                    name = points[0][2],
                    kwargs = points[0][3];
                segments.splice(0, 1);
            } else {
                // It's a closed path, do a moveTo to the last
                // point of the last segment.
                var closed = true,
                    segment = segments[segments.length - 1],
                    segmentType = segment[0],
                    points = segment[1],
                    point = points[points.length - 1],
                    movePt = point[0],
                    smooth = point[1],
                    name = point[2],
                    kwargs = point[3];
            }
            if(movePt === null) {
                // quad special case: a contour with no on-curve points
                // contains one "qcurve" segment that ends with a point
                // that's null. We must not output a moveTo() in that case.
                // pass
            } else {
                pen.moveTo(movePt);
            }
            var outputImpliedClosingLine = this.outputImpliedClosingLine,
                nSegments = segments.length;
            for(var i = 0; i < nSegments; i++) {
                var segmentType = segments[i][0],
                    points = [];
                for(var n = 0; n < segments[i][1].length; n++)
                    points.push(segments[i][1][n][0]);
                if(segmentType == 'line') {
                    assert(points.length === 1, 'Points length is not 1');
                    var pt = points[0];
                    if(i + 1 != nSegments
                    || outputImpliedClosingLine
                    || !closed)
                        pen.lineTo(pt);
                } else if(segmentType == 'curve') {
                    pen.curveTo.apply(pen, points);
                } else if(segmentType == 'qcurve') {
                    pen.qCurveTo.apply(pen, points);
                } else {
                    throw new errors.Type('illegal segmentType: '
                        + segmentType);
                }
            }
            if(closed)
                pen.closePath();
            else
                pen.endPath();
        },
        addComponent: function(glyphName, transform)
        {
            this.pen.addComponent(glyphName, transform);
        }
    });
    return PointToSegmentPen;
});

/**
 * Copyright (c) 2012, Lasse Fister lasse@graphicore.de, http://graphicore.de
 * 
 * You should have received a copy of the MIT License along with this program.
 * If not, see http://www.opensource.org/licenses/mit-license.php
 * 
 * This is a port of glifLib.Glyph defined in robofab/branches/ufo3k/Lib/ufoLib/gliflib.py
 *
 */ 
 
define(
    'ufojs/ufoLib/glifLib/Glyph',[
        'ufojs/errors'
      , 'obtain/obtain'
      , 'ufojs/tools/pens/PointToSegmentPen'
    ],
    function(
        errors
      , obtain
      , PointToSegmentPen
) {
    
    
    // ------------
    // Simple Glyph
    //-------------
    
    /**
     * Minimal glyph object. It has no glyph attributes until either
     * the draw() or the drawPoint() method has been called.
     * 
     * The methods of this glyph are not enumerable, so that a 
     *     for(var k in glyph){ ... }
     * yields only glyph attributes
     */
     
    function Glyph(glyphName, glyphSet) {
        Object.defineProperty(this, 'glyphName', {
            enumerable: false
          , value: glyphName
        })
        
        Object.defineProperty(this, 'glyphSet', {
            enumerable: false
          , value: glyphSet
        })
    };
    
    var _p = Glyph.prototype;
    
    /**
     * Draw the outline of this glyph onto a *FontTools* Pen.
     * The rest of the data will be written directly onto the Glyph
     */
     Object.defineProperty(_p, 'draw', {
        enumerable: false
      , value: function(obtainsSwitch, pen) {
            var pointPen = new PointToSegmentPen(pen);
            return this.drawPoints(obtainsSwitch, pointPen);
        }
    })
    
    
    Object.defineProperty(_p, '_readGlyph', {
        enumerable: false
      , value: function(obtainSwitch, pointPen) {
            var args = Array.prototype.slice.call(arguments);
            // insert this.glyphName
            // and the glyphObject argument === this
            args.splice(1, 0, this.glyphName, this);
            // args is now: [obtainSwitch, glyphname, this, pointPen]
            return this.glyphSet.readGlyph.apply(this.glyphSet, args)
        }
    })
    
    /**
     * Draw the outline of this glyph onto a PointPen.
     * The rest of the data will be written directly onto the Glyph
     */
    Object.defineProperty(_p, 'drawPoints', {
        enumerable: false
      , value: obtain.factory(
            {
                readGlyph: [false, 'pen', _p._readGlyph]
            }
          , {
                readGlyph: [true, 'pen', _p._readGlyph]
            }
          , ['pen']
          , function(obtain){ return obtain('readGlyph'); }
        )
    })
    
    return Glyph;
});

/**
 * Copyright (c) 2012, Lasse Fister lasse@graphicore.de, http://graphicore.de
 * 
 * You should have received a copy of the MIT License along with this program.
 * If not, see http://www.opensource.org/licenses/mit-license.php
 * 
 * This is a port of various functions to read a glif xml into a generic
 * glyph object defined in robofab/branches/ufo3k/Lib/ufoLib/gliflib.py
 *
 * There have been modifications from the python sources because XML is
 * treated with the DOM in here.
 */
define('ufojs/ufoLib/glifLib/readGlyph',[
    'ufojs/main'
  , 'ufojs/errors'
  , 'ufojs/xml/main'
  , 'ufojs/plistLib/main'
  , 'ufojs/ufoLib/validators'
  , './constants'
], function(
    main
  , errors
  , xml
  , plistLib
  , validators
  , constants
) {
    
    var GlifLibError = errors.GlifLib,
        glyphLibValidator = validators.glyphLibValidator,
        guidelinesValidator = validators.guidelinesValidator,
        anchorsValidator =  validators.anchorsValidator,
        imageValidator = validators.imageValidator,
        identifierValidator = validators.identifierValidator,
        transformationInfo = constants.transformationInfo;

    /**
     * You may pass a callback function as errorCallback. This
     * function will be called when an error is encountered during the
     * loading of a glyph. The errorCallback can return true and try
     * to let ReadGlyph do more parsing or false which will raise the
     * error immediately. Also, if "errorCallbackData.recoverable" is
     * false, errorCallback can report the error but not prevent it
     * from being thrown by returning true.
     */
    function ReadGlyph( errorCallback /* undefined or function*/ 
    ) {
        if(errorCallback) {
            this._errorCallback = errorCallback;
        }
        this._resetErrorCallbackData();
    }

    var _p = ReadGlyph.prototype;
    _p.constructor = ReadGlyph;

    _p._resetErrorCallbackData = function() {
        this._errorCallbackData = { glyphName: '' };
    }
    _p._executeErrorCallback = function(recoverable, msg) {
        var recover;
        this._errorCallbackData.message = msg;
        this._errorCallbackData.recoverable = recoverable;
        recover = this._errorCallback
            ? this._errorCallback( this._errorCallbackData )
            : false;
        if(!recover || !recoverable)
            throw new GlifLibError(msg);
    }


    /*
     * Read .glif data from a string into a glyph object.
     * 
     * The 'glyphObject' argument can be any kind of object (even None);
     * the readGlyphFromString() method will attempt to set the following
     * attributes on it:
     *   'width'      the advance with of the glyph
     *   'height'     the advance height of the glyph
     *   'unicodes'   a list of unicode values for this glyph
     *   'note'       a string
     *   'lib'        a dictionary containing custom data
     *   'image'      a dictionary containing image data
     *   'guidelines' a list of guideline data dictionaries
     *   'anchors'    a list of anchor data dictionaries
     * 
     * All attributes are optional, in two ways:
     *   1) An attribute *won't* be set if the .glif file doesn't
     *      contain data for it. 'glyphObject' will have to deal
     *      with default values itself.
     *   2) If setting the attribute fails with an AttributeError
     *      (for example if the 'glyphObject' attribute is read-
     *      only), readGlyphFromString() will not propagate that
     *      exception, but ignore that attribute.
     * 
     * To retrieve outline information, you need to pass an object
     * conforming to the PointPen protocol as the 'pointPen' argument.
     * This argument may be None if you don't need the outline data.
     * 
     * The formatVersions argument defined the GLIF format versions
     * that are allowed to be read.
     * 
     * _glifTreeFromFile from the python code should lead you here
     */
    _p.fromString = function(
        glyphDataString,
        glyphObject /* undefined */,
        pointPen /* undefined */,
        // the formatVersions argument is not used! this was in the python code.
        formatVersions /* default = [1, 2]*/
    ) {
        var glifDoc = xml.parseXMLString(glyphDataString);
        this.fromDOM(glifDoc, glyphObject, pointPen, formatVersions );
    }
    
    /**
     * defined as _readGlyphFromTree in the python code
     */
    _p.fromDOM = function(
        glifDoc,
        glyphObject /* undefined */,
        pointPen /* undefined */,
        // the formatVersions argument is not used! this was in the python code.
        formatVersions /* default = [1, 2]*/
    ) {
        try {
            // quick format validation
            var root = glifDoc.documentElement,
            formatError = false,
            formatVersion;
            if( typeof root === 'undefined'
                || typeof root.tagName !== 'string'
                || root.tagName !== 'glyph')
                formatError = true;
            if(formatError) {
                this._executeErrorCallback(false,'GLIF data is not properly formatted.');
            }

            // check the format version
            formatVersion = root.getAttribute('format');
            formatVersion = main.isIntString(formatVersion)
                ? parseInt(formatVersion, 10)
                : formatVersion;
            if(formatVersion === 1)
                this._readGlyphFromTreeFormat1(glifDoc, glyphObject, pointPen);
            else if(formatVersion === 2)
                this._readGlyphFromTreeFormat2(glifDoc, glyphObject, pointPen);
            else
                this._executeErrorCallback(false,'Unsupported GLIF format version: '
                                           + formatVersion + '.');
        }
        finally {
            this._resetErrorCallbackData();
        }
    }
    
    // this method is inherited from the python code
    // it's still there becaue this code could try to set
    // values on an undefined object
    // it's propably a good idea to make it superfluous by not setting
    // values on undefined
    _p._relaxedSetattr = function (object, attr, value) {
        try {
            object[attr] = value;
            return true;
        }
        catch(e) {
            if(!(e instanceof TypeError))
                throw e;
            /*else pass*/
        }
        return false;
    }
    
    _p._relaxedSetattrDict = function (object, dict) {
        for(var k in dict)
            this._relaxedSetattr(object, k, dict[k]);
    }
    
    _p._isDOMElement = function (node) {
        return (
            (node instanceof xml.Node)
            && node.nodeType === xml.Node.ELEMENT_NODE
        );
    }
    
    /**
     * This will yet allow more than the python version, because it uses
     * only Javascripts parseFloat, which is very forgiving
     * 
     * Python docstring:
     * Given a numeric string, return an integer or a float, whichever
     * the string indicates. _toNumber("1") will return the integer 1,
     * _toNumber("1.0") will return the float 1.0.
     * 
     * >>> _toNumber("1")
     * 1
     * >>> _toNumber("1.0")
     * 1.0
     * >>> _toNumber("a")
     * Traceback (most recent call last):
     *     ...
     * GlifLibError: Could not convert a to an int or float.
     */
    _p._toNumber = function (string) {
        var number;
        if(main.isNumber(string))
            return parseFloat(string);
        if(!main.isFloatString(string))
            throw new GlifLibError('Could not convert "' + string
                + '" to an int or float.');
        
        number = parseFloat(string)
        if(!isFinite(number))
            throw new GlifLibError('Could not convert "' + string
                + '" to an int or float.');
        return number;
    }
    
    /**
     * element.getAttribute but with an optional default Value
     * use this like:
     * _getAttribute.call(domElement, 'attrbuteName', 'fallbackValue');
     */
    _p._getAttribute = function (attribute, fallback /* default: null*/) {
        // this method allows undefined as a fallback value
        if(arguments.length < 2)
            fallback = null;
        if(this.hasAttribute(attribute))
            return this.getAttribute(attribute);
        return fallback;
    }
    
    /**
     * Make a list based interface for a function.
     * 
     * Takes a function as input and returns a function that takes an
     * array and applies (using Function.prototype.apply) the array items
     * as arguments to the input function.
     */
    _p._getArrayInterface = function (func) {
        return function(args) {
            return func.apply(this, args);
        }
    }
    
    /**
     * return a real array out of the children of a DOM Element
     */
    _p._listOfChildren = function (element) {
        return [].slice.call(element.children);
    }
    
    _p._attributesDict = function (node) {
        var attributes = {};
        for(var i=0; i<node.attributes.length; i++)
            attributes[node.attributes.item(i).name] = node.attributes.item(i).value;
        return attributes;
    }
    
    _p._checkAttributesWhitelist = function (
        element /* DOM Element*/,
        whitelist /* setLike */
    ) {
        var i=0, attrName;
        for(; i<element.attributes.length; i++) {
            attrName = element.attributes.item(i).name;
            if(!(attrName in whitelist))
                throw new GlifLibError('Unknown attribute (' + attrName
                    + ') in ' + element.tagName + ' element.');
        }
    }
    
    _p._readGlyphFromTreeFormat1 = function (
        glifDoc,
        glyphObject/* undefined */,
        pointPen/* undefined */
    ) {
        var root = glifDoc.documentElement;
        // get the name
        this._relaxedSetattr( glyphObject, 'name', this._readName(root));

        // bind the glyph name so that lower methods don't need it
        this._errorCallbackData.glyphName = glyphObject['name'];

        // populate the sub elements
        var unicodes = {list: [], dict: {}},
            haveSeenAdvance = false,
            haveSeenOutline = false,
            haveSeenLib = false,
            haveSeenNote = false,
            children = this._listOfChildren(root),
            i, node, element, v;
        
        for(i=0; i<children.length; i++) {
            node = children[i];
            element = node.tagName;
            if(element === 'outline') {
                if(haveSeenOutline)
                    throw new GlifLibError('The outline element occurs '
                        + 'more than once.');
                if(node.attributes.length)
                    throw new GlifLibError('The outline element contains '
                        + 'unknown attributes.');
                haveSeenOutline = true;
                if(pointPen !== undefined)
                    this._buildOutlineFormat1(glyphObject, pointPen,
                                        this._listOfChildren(node));
            }
            else if(element === 'advance') {
                if(haveSeenAdvance)
                    throw new GlifLibError('The advance element occurs '
                        + 'more than once.');
                haveSeenAdvance = true;
                this._relaxedSetattrDict(glyphObject, this._readAdvance(node));
            }
            else if(element === 'unicode') {
                v = node.getAttribute('hex');
                v = parseInt(v, 16);
                if(!isFinite(v))
                    throw new GlifLibError('Illegal value for hex '
                        + 'attribute of unicode element.');
                if(!(v in unicodes.dict)) {
                    // Could store indices of unicodes.list here if there
                    // was a need, anyone? This way unicodes.dict is still
                    // useable like a set in python
                    unicodes.dict[v] = true;
                    unicodes.list.push(v);
                }
            }
            else if(element === 'note') {
                if(haveSeenNote)
                    throw new GlifLibError('The note element occurs more '
                        + 'than once.');
                haveSeenNote = true;
                this._relaxedSetattr(glyphObject, 'note', this._readNote(node));
            }
            else if(element === 'lib') {
                if(haveSeenLib)
                    throw new GlifLibError('The lib element occurs more '
                    + 'than once.');
                haveSeenLib = true;
                this._relaxedSetattr(glyphObject, 'lib', this._readLib(node));
            }
            else throw new GlifLibError('Unknown element in GLIF: '
                    + element + '.');
        }
        // set the collected unicodes
        if(unicodes.list.length)
            this._relaxedSetattr(glyphObject, 'unicodes', unicodes.list);
    }
    
    
    _p._readGlyphFromTreeFormat2 = function (
        glifDoc,
        glyphObject/* undefined */,
        pointPen/* undefined */
    ) {
        var root = glifDoc.documentElement;
        // get the name
        this._relaxedSetattr(glyphObject, 'name', this._readName(root));
        this._errorCallbackData.glyphName = glyphObject['name'];

        // populate the sub elements
        var unicodes = {list: [], dict: {}},
            guidelines = [],
            anchors = [],
            haveSeenAdvance = false,
            haveSeenImage = false,
            haveSeenOutline = false,
            haveSeenLib = false,
            haveSeenNote = false,
            identifiers = {}, // set() in python
            children = this._listOfChildren(root),
            i, node, element, attrs, attr, v;
        for(i=0; i<children.length; i++) {
            node = children[i];
            element = node.tagName;
            if(element === 'outline') {
                if(haveSeenOutline)
                    throw new GlifLibError('The outline element occurs '
                        + 'more than once.');
                if(node.attributes.length)
                    throw new GlifLibError('The outline element contains '
                        + 'unknown attributes.');
                haveSeenOutline = true;
                if(pointPen !== undefined)
                    // FIXME: It's wrong to not check the outline here.
                    // Because the glyph could be invalid (duplicate
                    // identifiers for example). However: for some tasks
                    // it would be a performance hit I quess (when only
                    // reading a particular value, there is the rapid value
                    // fetching stuff in GlyphSet, maybe that API or a new
                    // one could be used in these cases). Another option
                    // would be a further optional Argument
                    // for this method.
                    // UFO 2 had no identifiers, and thus not this exact
                    // problem, however, the outline could be malformed in
                    // other ways, too.
                    // The glyph in the case of an invalid outline would
                    // be sometimes valid, when not reading the outline
                    // and sometimes invalid, when reading the outline.
                    // That is a bad thing.
                    // I'm leaving it for now, because the first aim is
                    // to be compatible to robofab.
                    this._buildOutlineFormat2( pointPen, this._listOfChildren(node),
                                              identifiers );
            }
            else if(element === 'advance') {
                if(haveSeenAdvance)
                    throw new GlifLibError('The advance element occurs '
                        + 'more than once.');
                haveSeenAdvance = true;
                this._relaxedSetattrDict(glyphObject, this._readAdvance(node));
            }
            else if(element === 'unicode') {
                v = node.getAttribute('hex');
                v = parseInt(v, 16);
                if(!isFinite(v))
                    throw new GlifLibError('Illegal value for hex '
                        + 'attribute of unicode element.');
                if(!(v in unicodes.dict)) {
                    // Could store indices of unicodes.list here if there
                    // was a need, anyone? This way unicodes.dict is still
                    // useable like a set in python
                    unicodes.dict[v] = true;
                    unicodes.list.push(v);
                }
            }
            else if(element === 'guideline') {
                if (node.childNodes.length)
                    throw new GlifLibError('Unknown children in guideline element.');
                attrs = this._attributesDict(node);
                for(attr in {x: null, y: null, angle: null})
                    if(attr in attrs)
                        attrs[attr] = this._toNumber(attrs[attr]);
                guidelines.push(attrs);
            }
            else if(element === 'anchor') {
                if (node.childNodes.length)
                    throw new GlifLibError('Unknown children in anchor element.')
                attrs = this._attributesDict(node);
                for(attr in {x: null, y: null})
                    if(attr in attrs)
                        attrs[attr] = this._toNumber(attrs[attr]);
                anchors.push(attrs);
            }
            else if(element === 'image') {
                if(haveSeenImage)
                    throw new GlifLibError('The image element occurs '
                        + 'more than once.')
                if (node.childNodes.length)
                    throw new GlifLibError('Unknown children in image '
                        + 'element.');
                haveSeenImage = true;
                this._relaxedSetattr(glyphObject, 'image',this._readImage(node));
            }
            else if(element === 'note') {
                if(haveSeenNote)
                    throw new GlifLibError('The note element occurs more '
                        + 'than once.');
                haveSeenNote = true;
                this._relaxedSetattr(glyphObject, 'note',this._readNote(node));
            }
            else if(element === 'lib') {
                if(haveSeenLib)
                    throw new GlifLibError('The lib element occurs more '
                    + 'than once.');
                haveSeenLib = true;
                this._relaxedSetattr(glyphObject, 'lib', this._readLib(node));
            }
            else throw new GlifLibError('Unknown element in GLIF: '
                    + element + '.');
        }
        // set the collected guidelines
        if(guidelines.length) {
            if(!guidelinesValidator(guidelines, identifiers))
                // FIXME: in case of duolicate identifieres be more clear
                throw new GlifLibError('The guidelines are improperly formatted.')
             this._relaxedSetattr(glyphObject, 'guidelines', guidelines);
        }
        // set the collected anchors
        if(anchors.length) {
            if(!anchorsValidator(anchors, identifiers))
                // FIXME: in case of duolicate identifieres be more clear
                throw new GlifLibError('The anchors are improperly formatted.')
            this._relaxedSetattr(glyphObject, 'anchors', anchors);
        }
        // set the collected unicodes
        if(unicodes.list.length)
            this._relaxedSetattr(glyphObject, 'unicodes', unicodes.list);
    }
    
    _p._readName = function (node) {
        var glyphName = node.getAttribute('name');
        
        if(typeof glyphName !== 'string' || glyphName === '')
            throw new GlifLibError('Empty glyph name in GLIF.');
        return glyphName;
    }
    
    _p._readAdvance = function (node) {
        var values = ['width', 'height']
            .map(node.getAttribute, node)
            .map(function(value){ return value === null ? 0 : value;})
            .map(this._toNumber);
        return {
            width: values[0],
            height: values[1]
        }
    }
    
    _p._readNote = function (node) {
        return this._listOfChildren(node) // array
            .map(function(item){return item.textContent;}) // array
            .join('\n') // string
            .split('\n')// array
            .map(function(str){return str.trim();}) // array
            .join('\n'); // string
    }
    
    _p._readLib = function (node) {
        if(node.children.length !== 1)
            throw new GlifLibError('lib node may have only one child, '
                +'but has ' + node.children.length + '.');
        
        var plistElement = node.firstElementChild || node.children[0],
            lib, validation;
        
        if(plistElement.tagName !== 'dict')
            throw new GlifLibError('The child node of lib must be "dict"'
                +'but is ' + plistElement.tagName + '.');
        
        lib = plistLib.readPlistElement(plistElement);
        validation = glyphLibValidator(lib);
            
        if(!validation[0])
            throw new GlifLibError(validation[1]);
        return lib;
    }
    
    _p._readImage = function (node) {
        var imageData = this._attributesDict(node),
            i=0, attr, value;
        // FIXME: it would be nice to have a single transformation value
        // at this point on the glyphObject instead of all those xScale,
        // xyScale, etc. values. Either as a list or as a new Transform()
        // from tools/misc/transform.
        // That of course would require some refactoring and might break
        // compatibillity to some existing python code, what would be ok
        // I guess???
        for(; i<transformationInfo.length; i++) {
            attr = transformationInfo[i][0];
            value = transformationInfo[i][1];
            if(attr in imageData)
                value = imageData[attr];
            imageData[attr] = this._toNumber(value);
        }
        // needs to happen after parsing, because the type of teh attributes
        // must be number
        if(!imageValidator(imageData))
            throw new GlifLibError('The image element is not properly '
                + 'formatted.');
        return imageData;
    }
    
    // ----------------
    // GLIF to PointPen
    // ----------------
    
    //all of these are defined as set in python
    var contourAttributesFormat2 = main.setLike(['identifier']),
        componentAttributesFormatBaseList = ['base', 'xScale', 'xyScale',
            'yxScale', 'yScale', 'xOffset', 'yOffset'],
        componentAttributesFormat1 = main.setLike(
            componentAttributesFormatBaseList),
        componentAttributesFormat2 = main.setLike(
            componentAttributesFormatBaseList.concat(['identifier'])),
        pointAttributesFormatBaseList = ['x', 'y', 'type', 'smooth',
            'name'],
        pointAttributesFormat1 = main.setLike(
            pointAttributesFormatBaseList),
        pointAttributesFormat2 = main.setLike(
            pointAttributesFormatBaseList.concat(["identifier"])),
        pointSmoothOptions = main.setLike(['no', 'yes']),
        pointTypeOptions = main.setLike(['move', 'line', 'offcurve',
            'curve', 'qcurve'])
        ;
    
    // format 1
    
    _p._buildOutlineFormat1 = function (glyphObject, pen, nodes ) {
        var i = 0,
            anchors = [],
            node, child, anchor;
        for(; i<nodes.length; i++) {
            node = nodes[i];
            if(!this._isDOMElement(node))
                throw new GlifLibError('The outline element is not '
                    + 'properly structured.');
            if(node.tagName == 'contour') {
                if(node.children.length == 1) {
                    // its an anchor
                    child = node.children[0];
                    if(child.tagName == "point") {
                        anchor = this._buildAnchorFormat1(child);
                        if(anchor)
                            anchors.push(anchor);
                    }
                    // FIXME: The Python source allows it when here is
                    // an unknown tag name. Beeing a little more strict
                    // at least our namespace should not be polluted with
                    // undocumented tags give it back to robofab? Its most
                    // probably too late for outline format version 1.
                    // else
                    //     new GlifLibError('Unknown element in contour '
                    //         + 'element: ' + child.tagName);
                }
                else
                    this._buildOutlineContourFormat1(pen, node)
            }
            else if(node.tagName == 'component')
                this._buildOutlineComponentFormat1(pen, node);
            else
                throw new GlifLibError('Unknown element in outline element '
                    +  node.tagName);
        }
        
        // set the collected anchors
        if(anchors.length) {
            if(!anchorsValidator(anchors))
                throw new GlifLibError('GLIF 1 anchors are not properly '
                    + 'formatted.');
            this._relaxedSetattr(glyphObject, 'anchors', anchors);
        }
    }
    
    _p._buildAnchorFormat1 = function (point /* a DOM Node */ ) {
        if( point.getAttribute('type') !== 'move')
            return;
        
        if (!point.hasAttribute('x'))
            throw new GlifLibError('Required x attribute is missing in '
                + 'point element.');
        if (!point.hasAttribute('y'))
            throw new GlifLibError('Required y attribute is missing in '
                + 'point element.');
        return {
            x: this._toNumber(point.getAttribute('x')),
            y: this._toNumber(point.getAttribute('y')),
            name: point.getAttribute('name')
        }
    }
    
    _p._buildOutlineContourFormat1 = function (pen, contour) {
        var children
        if (contour.attributes.length)
            throw new GlifLibError('Unknown attributes in contour element.')
        pen.beginPath();
        if (contour.children.length) {
            children = this._validateAndMassagePointStructures(
                this._listOfChildren(contour),
                pointAttributesFormat1,
                /* openContourOffCurveLeniency */ true )
            this._buildOutlinePointsFormat1(pen, children)
        }
        pen.endPath();
    }
    
    _p._buildOutlinePointsFormat1 = function (pen, points) {
        var i = 0,
            attrs;
        for (; i<points.length; i++) {
            attrs = points[i];
            pen.addPoint(
                [attrs.x, attrs.y],
                attrs.segmentType,
                attrs.smooth,
                attrs.name
            );
        }
    }
    
    _p._buildOutlineComponentFormat1 = function (pen, component) {
        var baseGlyphName,
            transformation;
        
        if (component.children.length)
            throw new GlifLibError('Unknown child elements of component '
                + 'element.');
        
        // throws GlifLibError
        this._checkAttributesWhitelist(component, componentAttributesFormat1);
        
        if(!component.hasAttribute('base'))
            throw new GlifLibError('The base attribute is not defined '
                + 'in the component.');
        baseGlyphName = component.getAttribute('base');
        
        transformation = transformationInfo
            // the contents of transformatiooInfo work well as arguments
            // of _getAttribute
            .map(this._getArrayInterface(this._getAttribute), component)
            .map(this._toNumber);
        pen.addComponent(baseGlyphName, transformation);
    }
    
    // format 2
    
    /**
     * little helper
     */
    _p._processIdentifier = function (identifier, identifiers) {
        if(identifier in identifiers)
            throw new GlifLibError('The identifier "' + identifier
                + '" is used more than once.');
        else if(!identifierValidator(identifier))
            throw new GlifLibError('The identifier "' + identifier
                + '" is not valid.');
        else
            identifiers[identifier] = true;
    }
    
    _p._buildOutlineFormat2 = function (pen, nodes, identifiers ) {
        var anchors = [], node, i=0;
        for (; i<nodes.length; i++) {
            node = nodes[i];
             if(!this._isDOMElement(node))
                throw new GlifLibError('The outline element is not '
                    + 'properly structured.');
            
            if(node.tagName === 'contour')
                this._buildOutlineContourFormat2(pen, node, identifiers )
            else if(node.tagName == 'component')
                this._buildOutlineComponentFormat2(pen, node, identifiers )
            else
                throw new GlifLibError('Unknown element in outline '
                    + 'element: ' + node.tagName);
        }
    }
    
    _p._buildOutlineContourFormat2 = function (pen, contour, identifiers) {
        var identifier, children;
        
        // throws GlifLibError
        this._checkAttributesWhitelist(contour, contourAttributesFormat2);
        if (contour.hasAttribute('identifier')) {
            identifier = contour.getAttribute('identifier');
            this._processIdentifier(identifier, identifiers);
        }
        pen.beginPath({identifier:identifier});
        
        if (contour.children.length) {
            children = this._validateAndMassagePointStructures(
                this._listOfChildren(contour),
                pointAttributesFormat2,
                false
            );
            this._buildOutlinePointsFormat2(pen, children, identifiers);
        }
        pen.endPath()
    }
    
    _p._buildOutlinePointsFormat2 = function (pen, points, identifiers) {
        var i = 0,
            attrs, identifier;
        for (; i<points.length; i++) {
            attrs = points[i];
            
            if(attrs.identifier !== undefined) {
                identifier = attrs.identifier;
                this._processIdentifier(identifier, identifiers);
            }
            pen.addPoint(
                    [attrs.x, attrs.y],
                    attrs.segmentType,
                    attrs.smooth,
                    attrs.name,
                    {identifier: attrs.identifier}
            );
        }
    }
    
    _p._buildOutlineComponentFormat2 = function (pen, component, identifiers ) {
        var baseGlyphName, transformation, identifier;
        
        if (component.children.length)
            throw new GlifLibError('Unknown child elements of component element.')
        
        // throws GlifLibError
        this._checkAttributesWhitelist(component, componentAttributesFormat2);
        
        if(!component.hasAttribute('base'))
            throw new GlifLibError('The base attribute is not defined '
                + 'in the component.');
        baseGlyphName = component.getAttribute('base');
        
        transformation = transformationInfo
            // the contents of transformatiooInfo work well as arguments
            // of _getAttribute
            .map(this._getArrayInterface(this._getAttribute), component)
            .map(this._toNumber);
        
        if (component.hasAttribute('identifier')) {
            identifier = component.getAttribute('identifier');
            this._processIdentifier(identifier, identifiers);
        }
        
        try {
            pen.addComponent(baseGlyphName, transformation, {identifier:identifier});
        // HELP: where is this error supposed to be risen. I can't find a pen that does so.
        }
        catch(e) {
            // FIXME: if there is a pen that is supposed to raise this error
            // in Javascript that has to happen explicitly.
            // TypeError would be still ok to expect
            if(!(e instanceof TypeError))
                throw e;
            pen.addComponent(baseGlyphName, transformation);
            errors.warn('DEPRECATED: The addComponent method needs an '
                + 'identifier kwarg. The component\'s identifier value '
                + 'has been discarded.');
        }
    }
    
    // all formats
    
    _p._validateAndMassagePointStructures = function (
        children /* a list of DOM Elements */,
        pointAttributes /* a setlike Objekt */,
        openContourOffCurveLeniency /* default: False */
    ) {
        // store some data for later validation
        var pointTypes = [],
            resultChildren = [],
            haveOnCurvePoint = false,
            haveOffCurvePoint = false,
            i, point, resultPoint, pointType, segment,
            segmentType, offCurves, k, smooth;
        
        if(!children.length)
            return resultChildren;
        
        // validate and massage the individual point elements
        for (i=0; i<children.length; i++) {
            point = children[i];
            
            // not <point>
            if(point.tagName != 'point')
                throw new GlifLibError('Unknown child element ('
                    + child.tagName + ') of contour element.');
            
            // unknown attributes, throws GlifLibError
            this._checkAttributesWhitelist(point, pointAttributes);
            
            resultPoint = this._attributesDict(point);
            resultChildren.push(resultPoint);
            // search for unknown children
            if(point.children.length)
                throw new GlifLibError('Unknown child elements in point '
                    + 'element.')
            
            // x and y are required
            for(k in {'x':undefined, 'y':undefined}) {
                if(resultPoint[k] === undefined)
                    throw new GlifLibError('Required ' + k +' attribute is '
                        + 'missing in point element.');
                resultPoint[k] = this._toNumber(resultPoint[k]);
            }
            
            // segment type
            pointType = resultPoint.type;
            if(pointType === 'offcurve' || pointType === undefined)
                pointType = null
            if(pointType !== null && !(pointType in pointTypeOptions))
                throw new GlifLibError('Unknown point type: '
                    + pointType);
            resultPoint.segmentType = pointType;
            if(pointType === null)
                haveOffCurvePoint = true;
            else
                haveOnCurvePoint = true;
            pointTypes.push(pointType);
            
            // move can only occur as the first point
            if(pointType === 'move' && i !== 0)
                throw new GlifLibError('A move point occurs after the '
                    + 'first point in the contour.')
            
            // smooth is optional
            smooth = resultPoint.smooth
            if(smooth !== undefined && !(smooth in pointSmoothOptions))
                throw new GlifLibError('Unknown point smooth value: '
                        + smooth);
            resultPoint.smooth = smooth === 'yes';
            
            // smooth can only be applied to curve and qcurve
            // FIXME: so what about "move" and "line"?
            if(resultPoint.smooth && pointType === null)
                throw new GlifLibError('smooth attribute set in an '
                    + 'offcurve point.');
            // name is optional
            if(!('name' in resultPoint))
                resultPoint.name = null;
        }
        
        if(openContourOffCurveLeniency) {
            errors.warn('test this openContourOffCurveLeniency')
            // remove offcurves that precede a move. this is technically
            // illegal, but we let it slide because there are fonts out
            // there in the wild like this.
            if(resultChildren[0].segmentType == 'move') {
                resultChildren.reverse()
                for(i=0; i<resultChildren.length; i++) {
                    if(resultChildren[i].segmentType !== null) {
                        resultChildren = resultChildren.slice(i);
                        break;
                    }
                    else if( resultChildren[i].segmentType === null) {
                        // remove the point
                        pointTypes.pop();
                    }
                }
                resultChildren.reverse();
            }
        }
        // validate the off-curves in the segments
        if(haveOffCurvePoint && haveOnCurvePoint) {
            while (pointTypes[pointTypes.length - 1] === null)
                pointTypes.unshift(pointTypes.pop());
            segment = [];
            for(i=0; i<pointTypes.length; i++) {
                pointType = pointTypes[i];
                segment.push(pointType);
                if(pointType === null)
                    continue;
                if(segment.length > 1) {
                    segmentType = segment[segment.length -1];
                    offCurves = segment.slice(0, -1);
                    // move and line can't be preceded by off-curves
                    if(segmentType === 'move')
                        // this will have been filtered out already
                        throw new GlifLibError('move can not have an '
                            + 'offcurve.');
                    else if(segmentType === 'line')
                        {
                            this._executeErrorCallback(true, 'line can not have an offcurve.');

                            // still here, try to recover.
                            resultChildren = [];
                            return resultChildren;
                        }
                    else if(segmentType === 'curve')
                        if (offCurves.length > 2) {
                            this._executeErrorCallback(true, 'Too many offcurves defined for curve.');

                            // still here, try to recover.
                            resultChildren = [];
                            return resultChildren;
                        }
                //    else if(segmentType === "qcurve")
                //        {/* pass */}
                //    else
                //        // unknown segement type. it'll be caught later.
                //        { /* pass */ }
                }
                // reset
                segment = [];
            }
        }
        return resultChildren;
    }
    
    return {
        fromString: _p.fromString.bind(new ReadGlyph()),
        fromDOM:    _p.fromDOM.bind(new ReadGlyph()),
        ReadGlyph:  ReadGlyph
    }
});

/**
 * Copyright (c) 2012, Lasse Fister lasse@graphicore.de, http://graphicore.de
 *
 * You should have received a copy of the MIT License along with this program.
 * If not, see http://www.opensource.org/licenses/mit-license.php
 *
 * This is a port of glifLib.GLIFPointPen defined in
 * robofab/branches/ufo3k/Lib/ufoLib/gliflib.py
 *
 */

define(
    'ufojs/ufoLib/glifLib/GLIFPointPen',[
        'ufojs/main',
        'ufojs/errors',
        'ufojs/xml/main',
        'ufojs/tools/pens/AbstractPointPen',
        'ufojs/ufoLib/validators',
        './constants'
    ],
    function(
        main,
        errors,
        xml,
        AbstractPointPen,
        validators,
        constants
) {
    
    //shortcuts
    var enhance = main.enhance,
        isNumber = main.isNumber,
        assert = errors.assert,
        GlifLibError = errors.GlifLib,
        identifierValidator = validators.identifierValidator,
        transformationInfo = constants.transformationInfo;

    /*constructor*/

    /**
     * Helper class using the PointPen protocol to write the <outline>
     * part of .glif files.
     */
    function GLIFPointPen(
        element /* DOM Element*/,
        identifiers /* dict optional */,
        formatVersion /*default 2*/
        /* undefined or a dict with optional keys:
         *    precision: number of decimal places to round numbers to
         */
      , options
    ) {

        if(!(element instanceof xml.Node))
            throw new GlifLibError('Element must be an instance of xml.Node.')

        this._element = element;
        this._formatVersion = formatVersion === undefined ? 2 : formatVersion;
        this._identifiers = identifiers || {};

        this._options = options || {};

        this._document = element.ownerDocument;
        this._prevPointTypes = [];
        this._prevOffCurveCount = 0;
        this._currentPath = null;
    }

    /*inheritance*/
    GLIFPointPen.prototype = Object.create(AbstractPointPen.prototype);

    /*definition*/
    enhance(GLIFPointPen, {
        _getPrecision: function() {
            // since a precision of 0 makes totally sense: "no decimal places"
            // we use -1 to turn of rounding
            return (
                this._options.precision !== undefined
                                    && this._options.precision !== -1
                    ? this._options.precision
                    : false
            )
        }
      , get element() {
            return this._element;
        }
      , get identifiers() {
            return this._identifiers;
        }
      , get formatVersion() {
            return this._formatVersion;
        }
      , beginPath: function(kwargs /* optional, object looks for the key 'identifiers'*/) {
            kwargs = kwargs || {}

            assert(this._currentPath === null,
                'currentPath is not null, call endPath');
            this._currentPath = this._document.createElement('contour');
            if(this._checkIdentifier(kwargs.identifier))
                this._currentPath.setAttribute('identifier', kwargs.identifier);
            this._prevOffCurveCount = 0
        },
        endPath: function () {
            assert(this._currentPath !== null,
                'currentPath is null, call beginPath');

            if ( this._prevPointTypes.length
                && this._prevPointTypes[0] === 'move'
                && this._prevPointTypes.slice(-1)[0] == 'offcurve'
            )
                throw new GlifLibError('open contour has loose offcurve point');

            this._element.appendChild(this._currentPath);
            this._currentPath = null;
            this._prevOffCurveCount = 0;
            this._prevPointTypes = [];
        },
        addPoint: function(
            pt,
            segmentType /* default null */,
            smooth /* default false */,
            name /* default null */,
            kwargs /* default an object, javascript has no **kwargs syntax
                looks for the key "identifier"
            */
        ) {
            assert(this._currentPath !== null,
                'currentPath is null, call beginPath');

            segmentType = (segmentType === undefined) ? null : segmentType;
            smooth = (smooth || false);
            name = (name === undefined) ? null : name;
            kwargs = (kwargs || {});//an "options" object

            var point = this._document.createElement('point')
              , precision = this._getPrecision()
              ;

            // coordinates
            if(pt === undefined)
                throw new GlifLibError('Missing point argument');
            if(pt.filter(isNumber).length < 2)
                throw new GlifLibError('coordinates must be int or float')

            // Do any requested rounding
            if(precision !== false)
                pt = main.roundRecursive(pt, precision);

            point.setAttribute('x', pt[0]);
            point.setAttribute('y', pt[1]);

            // segment type
            if (segmentType === 'offcurve')
                segmentType = null
            else if(segmentType == 'move' && this._prevPointTypes.length)
                throw new GlifLibError('move occurs after a point has '
                    +'already been added to the contour.')
            else if(
                segmentType == 'line'
                && this._prevPointTypes.length
                && this._prevPointTypes.slice(-1)[0] === 'offcurve'
            )
                throw new GlifLibError('offcurve occurs before line point.');
            else if (segmentType === 'curve' && this._prevOffCurveCount > 2)
                throw new GlifLibError('too many offcurve points before '
                    + 'curve point.');

            if (segmentType !== null)
                point.setAttribute('type', segmentType);
            else
                segmentType = 'offcurve'

            if (segmentType === 'offcurve')
                this._prevOffCurveCount += 1;
            else
                this._prevOffCurveCount = 0;

            this._prevPointTypes.push(segmentType);

            // smooth
            if(smooth) {
                if(segmentType === 'offcurve')
                    throw new GlifLibError('can\'t set smooth in an '
                        + 'offcurve point.');
                 point.setAttribute('smooth', 'yes');
            }
            // name
            if (name !== null)
                point.setAttribute('name', name);

            // identifier
            if(this._checkIdentifier(kwargs.identifier))
                point.setAttribute('identifier', kwargs.identifier);

            this._currentPath.appendChild(point);
        },
        addComponent: function(glyphName, transformation, kwargs/*optional dict*/) {
            var component = this._document.createElement('component')
              , kwargs = kwargs || {}
              , i=0
              , attr
              , defaultVal
              , precision = this._getPrecision()
              , trans
              ;
            component.setAttribute('base', glyphName);

            // the python code was here:
            // for (attr, default), value in zip(_transformationInfo, transformation):
            // not shure if the python code is right here
            for(;i<transformationInfo.length && i<transformation.length; i++) {
                attr = transformationInfo[i][0];
                defaultVal = transformationInfo[i][1];
                if(!isNumber(transformation[i]))
                    throw new GlifLibError('transformation values must '
                        + 'be int or float');

                trans = precision !== false
                    ? main.round(transformation[i], precision)
                    : transformation[i];
                if(trans !== defaultVal)
                   component.setAttribute(attr, trans);
            }

            if(this._checkIdentifier(kwargs.identifier))
                component.setAttribute('identifier', kwargs.identifier);
            this._element.appendChild(component);
        },
        _checkIdentifier: function(identifier) {
            if(identifier === undefined || this._formatVersion < 2)
                return false;
            if(identifier in this._identifiers)
                throw new GlifLibError('identifier used more than once: '
                    + identifier);
            if(!identifierValidator(identifier))
                throw new GlifLibError('identifier not formatted properly: '
                    +  identifier);
            this._identifiers[identifier] = true;
            return true;
        }
    });

    return GLIFPointPen;
});


/**
 * Copyright (c) 2012, Lasse Fister lasse@graphicore.de, http://graphicore.de
 *
 * You should have received a copy of the MIT License along with this program.
 * If not, see http://www.opensource.org/licenses/mit-license.php
 *
 * This is a port of various functions to write a generic glyph object
 * into a glif xml defined in robofab/branches/ufo3k/Lib/ufoLib/gliflib.py
 *
 * There have been modifications from the python sources because XML is
 * treated with the DOM in here.
 */
define(
    'ufojs/ufoLib/glifLib/writeGlyph',[
        'ufojs/main',
        'ufojs/errors',
        'ufojs/xml/main',
        'ufojs/plistLib/main',
        'ufojs/ufoLib/validators',
        './constants',
        './GLIFPointPen'
    ],
    function(
        main,
        errors,
        xml,
        plistLib,
        validators,
        constants,
        GLIFPointPen
) {
    
    var GlifLibError = errors.GlifLib,
        isNumber = main.isNumber,
        isInt = main.isInt,
        imageValidator = validators.imageValidator,
        guidelinesValidator = validators.guidelinesValidator,
        anchorsValidator =  validators.anchorsValidator,
        glyphLibValidator = validators.glyphLibValidator,
        transformationInfo = constants.transformationInfo;

    /**
     * Return .glif data for a glyph as a UTF-8 encoded string.
     * The 'glyphObject' argument can be any kind of object (even None);
     * the writeGlyphToString() method will attempt to get the following
     * attributes from it:
     *     "width"      the advance width of the glyph
     *     "height"     the advance height of the glyph
     *     "unicodes"   a list of unicode values for this glyph
     *     "note"       a string
     *     "lib"        a dictionary containing custom data
     *     "image"      a dictionary containing image data
     *     "guidelines" a list of guideline data dictionaries
     *     "anchors"    a list of anchor data dictionaries
     *
     * All attributes are optional: if 'glyphObject' doesn't
     * have the attribute, it will simply be skipped.
     *
     * To write outline data to the .glif file, writeGlyphToString() needs
     * a function (any callable object actually) that will take one
     * argument: an object that conforms to the PointPen protocol.
     * The function will be called by writeGlyphToString(); it has to call the
     * proper PointPen methods to transfer the outline to the .glif file.
     *
     * The GLIF format version can be specified with the formatVersion argument.
     */
    function writeGlyphToString (
        glyphName
      , glyphObject /* default = undefined */
      , drawPointsFunc /* default = undefined */
        // the writer argument is not supported yet, here is no such concept
        /* writer default = undefined */
      , formatVersion /* default = 2 */
        /* undefined or a dict with optional keys:
         *    precision: number of decimal places to round numbers to
         */
      , options
    ) {
        var args = Array.prototype.slice.call(arguments)
          , doc = writeGlyphToDOM.apply(undefined, args)
          ;
        return xml.toString(doc);
    }

    function writeGlyphToDOM (
        glyphName
      , glyphObject /* default = undefined */
      , drawPointsFunc /* default = undefined */
        // the writer argument is not supported yet, here is no such concept
        /* writer default = undefined */
      , formatVersion /* default = 2 */
        /* undefined or a dict with optional keys:
         *    precision: number of decimal places to round numbers to
         */
      , options
    ) {
        var identifiers = {},
            doc,
            glyphElement,
            needOutline,
            outlineElement,
            pen;

        // we could also raise an exception on this one, but the docstring
        // says glyphObject is optional
        glyphObject = glyphObject || {}

        options = options || {}

        // start
        if(typeof glyphName !== 'string' && !(glyphName instanceof String))
            throw new GlifLibError('The glyph name is not properly formatted.')
        if(glyphName.length === 0)
            throw new GlifLibError('The glyph name is empty.');

        if(formatVersion === undefined)
            formatVersion = 2;

        doc = xml.createDocument(null, 'glyph', null);
        glyphElement = doc.documentElement;

        glyphElement.setAttribute('name', glyphName);
        glyphElement.setAttribute('format', formatVersion);

        // advance
        glyphElement.appendChild(_writeAdvance(glyphObject, doc, options))

        // unicodes
        if(glyphObject.unicodes !== undefined)
            glyphElement.appendChild(_writeUnicodes(glyphObject.unicodes, doc));

        // note
        if(glyphObject.note !== undefined)
            glyphElement.appendChild(_writeNote(glyphObject.note, doc));

        // image
        if(formatVersion >= 2 && glyphObject.image !== undefined)
            glyphElement.appendChild(_writeImage(glyphObject.image, doc,
                                     options));

        // guidelines
        if(formatVersion >= 2 && glyphObject.guidelines !== undefined)
            glyphElement.appendChild(
                _writeGuidelines(glyphObject.guidelines, doc, identifiers,
                                 options)
            );

        // anchors
        if(formatVersion >= 2  &&  glyphObject.anchors !== undefined)
            glyphElement.appendChild(
                _writeAnchors(glyphObject.anchors, doc, identifiers, options)
            );

        // outline
        needOutline = drawPointsFunc
            || formatVersion == 1 && glyphObject.anchors !== undefined;
        if(needOutline) {
            outlineElement = doc.createElement('outline');
            pen = new GLIFPointPen(outlineElement, identifiers, formatVersion, options);

            if(drawPointsFunc)
                drawPointsFunc(pen);
            if(formatVersion == 1 && glyphObject.anchors !== undefined)
                _writeAnchorsFormat1(pen, glyphObject.anchors);
            glyphElement.appendChild(outlineElement);
        }

        // lib
        if(glyphObject.lib !== undefined)
            glyphElement.appendChild(_writeLib(glyphObject.lib, doc));

        return doc;
    }

    /**
     *  a little helper
     */
    function _setAttributes(dict) {
        for(var k in dict)
            this.setAttribute(k, dict[k]);
    }

    /**
     * Round to 'precision' number decimal places.
     *
     * Since a precision of 0 makes totally sense: "no decimal places"
     * we use -1 to turn of rounding
     */
    function _round(precision, value) {
        if(precision === undefined || precision === -1)
            return value;
        return main.round(value, precision);
    }

    function _writeAdvance(glyphObject, document, options) {
        var keys = { width: undefined, height: undefined }
          , fragment = document.createDocumentFragment()
          , advanceElement = document.createElement('advance')
          , k, val
          ;
        for(k in keys) {
            val = glyphObject[k];
            if(val === undefined || val === 0)
                continue;
            if(!isNumber(val))
                throw new GlifLibError(k + ' attribute must be int or float');
            val = _round(options.precision, val)
            advanceElement.setAttribute(k, val)
        }
        if(advanceElement.attributes.length)
            fragment.appendChild(advanceElement);
        return fragment;
    }

    function _writeUnicodes(unicodes, document) {
        var seen = {}, // like a set
            i = 0,
            code,
            tag,
            hexCode,
            fragment = document.createDocumentFragment();
        // in my opinion unicodes should always be a list, an int would
        // be an error
        if (isInt(unicodes))
            unicodes = [unicodes];

        for(; i<unicodes.length; i++) {
            code = unicodes[i];
            if(!isInt(code))
                throw new GlifLibError('unicode values must be int');
            if(code in seen)
                continue;
            seen[code] = null;
            hexCode = code.toString(16).toUpperCase();
            if(hexCode.length < 4)
                hexCode = ['0', '0', '0', '0', hexCode]
                    .slice(hexCode.length)
                    .join('');
            tag = document.createElement('unicode');
            tag.setAttribute('hex', hexCode);
            fragment.appendChild(tag);
        }
        return fragment;
    }

    function _writeNote(note, document) {
        var noteElement;

        if(typeof note !== 'string')
            throw new GlifLibError('note attribute must be string');

        note = note.split('\n')// array
            .map(function(str){return str.trim();}) // array
            .join('\n'); // string

        noteElement = document.createElement('note');
        noteElement.appendChild(document.createTextNode(note));
        return noteElement;
    }

    function _writeImage(image, document, options) {
        var i=0,
            attr, defaultVal, imageElement, val;

        if(!imageValidator(image))
            throw new GlifLibError('image attribute must be a dict or '
                + 'dict-like object with the proper structure.');

        imageElement = document.createElement('image');
        imageElement.setAttribute('fileName', image.fileName);

        for(; i<transformationInfo.length; i++) {
            attr = transformationInfo[i][0];
            defaultVal = transformationInfo[i][1];
            val = image[attr];
            if(val === undefined) continue;
            val = _round(options.precision, val)
            if(val !== defaultVal)
                imageElement.setAttribute(attr, val);
        }

        if(image.color !== undefined)
            imageElement.setAttribute('color', image.color);

        return imageElement;
    }

    function _writeGuideline(data, document, options) {
        var guidelineElement = document.createElement('guideline')
          , roundAttributes = {'x': null, 'y': null, 'angle': null}
          , k
          , val
          ;
        // 'x', 'y', 'angle', 'name', 'color', 'identifier'
        for(k in data) {
            val = data[k];
            if(k in roundAttributes)
                val = _round(options.precision, val);
            guidelineElement.setAttribute(k, val);
        }
        return guidelineElement;
    }

    function _writeGuidelines(guidelines, document, identifiers, options) {
        var i=0
          , fragment
          ;
        if(!guidelinesValidator(guidelines, identifiers))
            throw new GlifLibError('guidelines attribute does not have '
                + 'the proper structure.');
        fragment = document.createDocumentFragment();
        for (; i<guidelines.length; i++)
            fragment.appendChild(
                    _writeGuideline(guidelines[i], document, options));
        return fragment;
    }

    function _writeAnchorsFormat1(pen, anchors) {
        var i = 0,
            anchor;
        if(!anchorsValidator(anchors))
            throw new GlifLibError('anchors attribute does not have the '
                + 'proper structure.');
        for(; i<anchors.length; i++) {
            anchor = anchors[i];
            pen.beginPath()
            pen.addPoint([anchor.x, anchor.y], "move", false, anchor.name);
            pen.endPath()
        }
    }

    function _writeAnchor(data, document, options) {
        var anchorElement = document.createElement('anchor')
          , roundAttributes = {'x': null, 'y': null}
          , k
          , val
          ;
        for(k in data) {
            val = data[k];
            if(k in roundAttributes)
                val = _round(options.preciosion, val);
            anchorElement.setAttribute(k, val);
        }
        return anchorElement;
    }

    function _writeAnchors(anchors, document, identifiers, options) {
        var i=0, fragment;
        if(!anchorsValidator(anchors, identifiers))
            throw new GlifLibError('anchors attribute does not have the '
                + 'proper structure.');

        fragment = document.createDocumentFragment();
        for (; i<anchors.length; i++)
            fragment.appendChild(_writeAnchor(anchors[i], document, options))
        return fragment;
    }

    function _writeLib(lib, document) {
        var validation, libElement;

        validation = glyphLibValidator(lib);
        if(!validation[0])
            throw new GlifLibError(validation[1]);
        libElement = document.createElement('lib');
        libElement.appendChild(
            plistLib.createPlistElement(document, lib)
        );
        return libElement;
    }

    return {
        toString: writeGlyphToString,
        toDOM: writeGlyphToDOM
    }
});


/**
 * Copyright (c) 2012, Lasse Fister lasse@graphicore.de, http://graphicore.de
 * 
 * You should have received a copy of the MIT License along with this program.
 * If not, see http://www.opensource.org/licenses/mit-license.php
 * 
 * This is a port of various functions for "rapid value fetching" defined in
 * robofab/branches/ufo3k/Lib/ufoLib/gliflib.py
 * 
 * it uses XPATH and DOM Documents, so its very different to the python
 * code.
 */
define(
    'ufojs/ufoLib/glifLib/rapidValueFetching',[
    'ufojs/main',
    'ufojs/xml/main'
    ],
    function(
        main,
        xml
) {
    
    
    var evaluateXPath = xml.evaluateXPath;
    
    function _getAttributeValue(attribute) {
        return attribute.value;
    }
    
    var x_unicodes = '/glyph/unicode/@hex'
      , x_components = '/glyph/outline[1]/component/@base'
        // NOTE: jsdom of nodejs converts the search attribute name fileName to
        // lowercase and matches only lowercase "filename" not "fileName"
        // in the document!
        // unless this is fixed we do a workaround here
      , x_image_fileName = '/glyph/image[1]/@fileName' // <= not workin with js DOM
      , x_image = '/glyph/image[1]'
      ;
    
    /**
     * Get a list of unicodes listed in glif
     */
    function fetchUnicodes(doc) {
        var results = evaluateXPath(doc, x_unicodes).map(_getAttributeValue),
            unicodes = { dict: {}, list: [] },
            i = 0,
            v;
        for(; i<results.length; i++) {
            v = parseInt(results[i], 16);
            if(!isFinite(v) || v in unicodes.dict) continue;
            unicodes.dict[v] = true;
            unicodes.list.push(v);
        }
        return unicodes.list;
    }
    
    /**
     * The image file name (if any) from glif.
     */
    function fetchImageFileName(doc) {
        return evaluateXPath(doc, x_image)
        .filter(function(elem){ return elem.hasAttribute('fileName'); })
        .map(function(elem){ return elem.getAttribute('fileName'); })
    }
    
    /**
     * Get a list of component base glyphs listed in glif.
     */
    function fetchComponentBases(doc) {
        return evaluateXPath(doc, x_components).map(_getAttributeValue);
    }
    
    return {
        fetchUnicodes: fetchUnicodes,
        fetchImageFileName: fetchImageFileName,
        fetchComponentBases: fetchComponentBases
    }
});

/**
 * Copyright (c) 2012,2014 Lasse Fister lasse@graphicore.de, http://graphicore.de
 *
 * You should have received a copy of the MIT License along with this program.
 * If not, see http://www.opensource.org/licenses/mit-license.php
 *
 * This is a port of glifLib.Glyph defined in robofab/branches/ufo3k/Lib/ufoLib/gliflib.py
 *
 * Modifications were made in order to use DOM Methods with the glifs.
 * Because there is no native SAX parser in the Browser, we parse the glifs
 * completely, not just partly on some operations as the Python
 * implementation does.
 *
 * added a method:
 *     getGLIFDocumnet
 *
 * The file reading/writing methods use the io module to abstract file writing.
 * TODO: use dependency injection to set up I/O on a per-GlyphSet-instance
 * basis.
 *
 * I implemented all otherwise blocking methods using obtainJS to provide
 * a switch beteween synchronous/asynchronous execution. See obtainJS for
 * details.
 *
 */


 /**
  * GlyphSet manages a set of .glif files inside one directory.
  *
  * GlyphSet's constructor takes a path to an existing directory as its
  * first argument. Reading glyph data can either be done through the
  * readGlyph() method, or by using GlyphSet's dictionary interface, where
  * the keys are glyph names and the values are (very) simple glyph objects.
  *
  * Use Glyphset.factory to create a ready to use instance! Or, invoke
  * glyphSet.rebuildContents after using the constructor directly. This
  * is a restriction to enable an asynchronous API.
  *
  * To write a glyph to the glyph set, you use the writeGlyph() method.
  * The simple glyph objects returned through the dict interface do not
  * support writing, they are just a convenient way to get at the glyph data.
  */
define(
    'ufojs/ufoLib/glifLib/GlyphSet',[
        'ufojs/main'
      , 'ufojs/errors'
      , 'obtain/obtain'
      , 'ufojs/xml/main'
      , 'ufojs/plistLib/main'
      , './constants'
      , './misc'
      , './Glyph'
      , './readGlyph'
      , './writeGlyph'
      , './rapidValueFetching'

    ],
    function(
        main
      , errors
      , obtain
      , xml
      , plistLib
      , constants
      , misc
      , Glyph
      , readGlyph
      , writeGlyph
      , rapidValueFetching
) {
    
    var enhance = main.enhance
      , GlifLibError = errors.GlifLib
      , KeyError = errors.Key
      , IONoEntryError = errors.IONoEntry
      , glyphNameToFileName = misc.glyphNameToFileName
      , layerInfoVersion3ValueData = misc.layerInfoVersion3ValueData
      , validateLayerInfoVersion3Data = misc.validateLayerInfoVersion3Data
      , readPlistFromString = plistLib.readPlistFromString
      , writePlistToString = plistLib.createPlistString
      , fetchUnicodes = rapidValueFetching.fetchUnicodes
      , fetchImageFileName = rapidValueFetching.fetchImageFileName
      , fetchComponentBases = rapidValueFetching.fetchComponentBases
        // This are wrappers that enable us to use io functions
        // with less hassle in an obtain.factory context
        // note that the host object must provide an I/O module itself _io
        // Todo: think about common an useful mixins!
      , _writeFile = obtain.factory(
            {
                write: ['path', 'data', function(path, data) {
                    return this._io.writeFile(false, path, data);
                }]
            }
          , {
                write: ['path', 'data', function(path, data){
                    return this._io.writeFile(true, path, data);
                }]
            }
          , ['path', 'data']
          , function(obtain){ return obtain('write'); }
        )
      , _unlink = obtain.factory(
            {
                unlink: ['path', function(path) {
                    return this._io.unlink(false, path);
                }]
            }
          , {
                unlink: ['path', function(path) {
                    return this._io.unlink(true, path);
                }]
            }
          , ['path']
          , function(obtain){ return obtain('unlink'); }
        )

        // internal methods

        /**
         * reads a plist from path synchronously or asynchronously
         * using obtainJS for the switch.
         */
      , _readPlist = obtain.factory(
          {
              // a constructor for a lib of shared methods
              // this is a bit hackish, should maybe become formalized
              lib: [function() {
                  return {
                      makeError: function(error, path) {
                          if(error instanceof IONoEntryError)
                              return error;
                          return new GlifLibError(
                              ['The file "', path ,'" could not be read.('
                              , error.message,')'].join(''), error.stack);
                      }
                  }
              }]
            , plist: ['plistString', 'path', 'lib',
              function(string, path, lib) {
                  try {
                      return readPlistFromString(string);
                  } catch(e) {
                      throw lib.makeError(e, path);
                  }
              }]
            , plistString: ['path', 'lib', function(path, lib) {
                  try {
                      return this._io.readFile(false, path);
                  } catch(e) {
                      throw lib.makeError(e, path);
                  }
              }]
          }
        , {
              plistString: ['path', 'lib', '_callback', '_errback',
              function(path, lib, callback, errback)
              {
                  this._io.readFile(true, path)
                      .then(callback, function(error) {
                          errback(lib.makeError(error, path))
                      })
              }]
          }
        , ['path']
        , function(obtain, path) {return obtain('plist');}
      );

    // ---------
    // Glyph Set
    // ---------

    /**
     * 'dirName' should be a path to an existing directory.
     * The optional 'glyphNameToFileNameFunc' argument must be a callback
     * function that takes two arguments: a glyph name and the GlyphSet
     * instance. It should return a file name (including the .glif
     * extension). The glyphNameToFileName function is called whenever
     * a file name is created for a given glyph name.
     */
    function GlyphSet(
        /* The IO module to use is dependency injected, because we need
         * greater flexibility than a static io module can provide. For
         * one point for testing, the other point is that we can easily
         * adapt our persistency mechanism to all needs
         */
        io,
        dirName,
        glyphNameToFileNameFunc /* undefined */,
        ufoFormatVersion /* 3 */,
        options /* object default undefined, 
                   optional, readErrorCallback: see readGlyph/ReadGlyph
                */
    ) {
        if(io === undefined)
            throw new GlifLibError('GlyphSet I/O module missing');
        this._io = io;
        this._options = options || {};
        this._glyphReader = new readGlyph.ReadGlyph(this._options.readErrorCallback)

        if(dirName === undefined)
            throw new GlifLibError('GlyphSet: dirName is missing');
        this.dirName = dirName;

        ufoFormatVersion = (ufoFormatVersion !== undefined)
                ? ufoFormatVersion
                : 3;
        if(!(ufoFormatVersion in constants.supportedUFOFormatVersions))
            throw new GlifLibError("Unsupported UFO format version: "
                                    + ufoFormatVersion);
        this.ufoFormatVersion = ufoFormatVersion;
        this.glyphNameToFileName = (glyphNameToFileNameFunc !== undefined)
                ? glyphNameToFileNameFunc
                : glyphNameToFileName;

        this.contents = undefined;
        this._reverseContents = undefined;
        this._glifCache = {};


        // because of the async/sync switch we run this externally
        // use GlyphSet.factory for a one call solution
        // this.rebuildContents();
    }

    GlyphSet.factory = obtain.factory(
        {
            instance: ['io', 'dirName', 'glyphNameToFileNameFunc', 'ufoFormatVersion', 'options',
                function(i, d, g, u, o) { return new GlyphSet(i, d, g, u, o); }]
          , init: ['instance', function(instance) {
                                    instance.rebuildContents(false);}]
        }
      , {
            init: ['instance', function(instance) {
                                    // returns a promise
                                    return instance.rebuildContents(true);}]
        }
      , ['io', 'dirName', 'glyphNameToFileNameFunc', 'ufoFormatVersion','options']
      , function(obtain) {
            obtain('init');
            return obtain('instance');
        }
    )

    var _p = GlyphSet.prototype;
    _p.constructor = GlyphSet;


    _p.GlyphClass = Glyph;

    _p._writeFile = _writeFile;
    _p._unlink = _unlink;

    _p._readPlist = _readPlist;

    /**
     * Rebuild the contents dict by loading contents.plist.
     */

    _p.rebuildContents = obtain.factory(
        {
            contentsPath: [function() {
                return [this.dirName, 'contents.plist'].join('/');
            }]
          , contentsPlist: [false, 'contentsPath', _p._readPlist]
          , filePaths: ['contentsPlist', function(contents) {
                if( plistLib.getType(contents) !== 'dict' )
                    throw new GlifLibError('contents.plist is not properly '
                        + 'formatted');
                var name
                  , fileName
                  , paths = []
                  ;

                for(name in contents) {
                    fileName = contents[name];
                    // name is always string
                    if(typeof fileName !== 'string')
                        throw new GlifLibError('contents.plist is not '
                            + 'properly formatted the value at "' + name
                            + '" is not string but:'+ typeof fileName);
                    paths.push([this.dirName, fileName].join('/'));
                }
                return paths;
            }]
          , validContents: ['contentsPlist', 'filePaths',
            function(contentsPlist, filePaths) {
                var i=0;
                for(;i<filePaths.length; i++)
                    if(!this._io.pathExists(false, filePaths[i]))
                        throw new GlifLibError('contents.plist references a '
                        + 'file that does not exist: ' + filePaths[i]);
                return contentsPlist;
            }]
        }
      , {
            contentsPlist: [true, 'contentsPath', _p._readPlist]
          , validContents: ['contentsPlist', 'filePaths', '_callback',
                            '_errback',
            function(contentsPlist, filePaths, callback, errback) {
                var i = 0
                    // we'll use this to determine if the test passed
                  , requested = 0
                  , failed = false // ioCallback will change this
                  , ioCallback = function(path, exists) {
                        requested -= 1;
                        // if it failed once we won't have to use the
                        // callbacks anymore, although it may be an option
                        // to write this to the logs in the future
                        if(failed)
                            return;
                        if(!exists) {
                            failed = true;
                            errback(new GlifLibError('contents.plist '
                                + 'references a file that does not exist: '
                                + path))
                            return;
                        }
                        if(requested === 0) {
                            // all requested files where found
                            callback(contentsPlist);
                        }
                    }
                ;
                // if there was no filePath
                if(filePaths.length === 0) {
                    setTimeout(function(){callback(contentsPlist)}, 0)
                    return;
                }
                // we just fire all now. the idea is that the io module
                // will have to throttle stuff like this in the future
                // (and should provide an api to cancel the already fired
                // requests, when possible)
                for(;i<filePaths.length; i++) {
                    requested += 1;
                    this._io.pathExists(true, filePaths[i])
                        .then(ioCallback.bind(null, filePaths[i]))
                }
            }]
        }
      , []
      , function(obtain) {
            this.contents = obtain('validContents');
            this._reverseContents = undefined;
        }
    )
    /**
     * Return a reversed dict of self.contents, mapping file names to
     * glyph names. This is primarily an aid for custom glyph name to file
     * name schemes that want to make sure they don't generate duplicate
     * file names. The file names are converted to lowercase so we can
     * reliably check for duplicates that only differ in case, which is
     * important for case-insensitive file systems.
     */
    _p.getReverseContents = function() {
        if(this._reverseContents === undefined){
            var d = {}, k;
            for(k in this.contents)
                d[this.contents[k].toLowerCase()] = k;
            this._reverseContents = d;
        }
        return this._reverseContents;
    }
    /**
     * Write the contents.plist file out to disk. Call this method when
     * you're done writing glyphs.
     */
    _p.writeContents = obtain.factory(
        {
            path: [function(){return [this.dirName, 'contents.plist'].join('/')}]
          , data: [function(){return writePlistToString(this.contents)}]
          , write: [false, 'path', 'data', _p._writeFile]
        }
      , {
            write: [true, 'path', 'data', _p._writeFile]
        }
      , []
      , function(obtain) { return obtain('write'); }
    )

    /**
     * layer info
     * read the layerinfo.plist and set its values to the info object
     * info object is the only argument of this method
     *
     * obtainJS sync/async api.
     */
    _p.readLayerInfo = obtain.factory(
        {
            path: [function() {
                return [this.dirName, constants.LAYERINFO_FILENAME].join('/');
            }]
          , infoDict: ['path', function(path) {
                var exists = true
                  , result
                  ;
                try {
                    result = this._readPlist(false, path);
                }
                catch(error){
                    if(error instanceof IONoEntryError)
                        return [false, undefined];
                    throw error;
                }
                return [true, result];
            }]

        }
      , {
            infoDict: ['path', '_callback', '_errback',
            function(path, callback, errback) {
                this._readPlist(true, path)
                .then(
                    function(result){callback([true, result])}
                  , function(error) {
                        if(error instanceof IONoEntryError)
                            callback([false, undefined]);
                        else
                            errback(error);
                    }
                )
            }]

        }
      , ['info']
      , function(obtain, info) {
            var infoDict = obtain('infoDict')
              , attr
              ;
            if(infoDict[0] === false)
                return info;
            if(plistLib.getType(infoDict[1])  !== 'dict')
                throw new GlifLibError('layerinfo.plist is not properly formatted.');
            infoDict = validateLayerInfoVersion3Data(infoDict[1]);
            for (attr in infoDict)
                info[attr] = infoDict[attr];
            // I can't imagine the equivalent exception in javaScript
            // and we do not have a setattribute function
            // maybe the caller should check the attributes of info
            // value = infoDict[attr];
            // try:
            //     setattr(info, attr, value)
            // except AttributeError:
            //     raise GlifLibError("The supplied layer info object does not support setting a necessary attribute (%s)." % attr)
            return info;
        }
    )
    /**
     * write the contents of the info argument to a string and return it
     */
    _p.writeLayerInfoToString = function(info) {
        if(this.ufoFormatVersion < 3)
            throw new GlifLibError('layerinfo.plist is not allowed in UFO '
                + this.ufoFormatVersion + '.');
        // gather data
        var infoData = {}, attr;
        for (attr in layerInfoVersion3ValueData){
            if(!(attr in info) || info[attr] === undefined)
                continue;
            infoData[attr] = info[attr];
        }

        // validate
        infoData = validateLayerInfoVersion3Data(infoData);
        return writePlistToString(infoData);
    }
    /**
     * write the contents of the info argument to LAYERINFO_FILENAME
     * writing to files is not implemented yet
     */
    _p.writeLayerInfo = obtain.factory(
        {
            data: ['info', _p.writeLayerInfoToString]
          , path: [function()
            {
                return [this.dirName, constants.LAYERINFO_FILENAME]
                        .join('/');
            }]
          , write: [false, 'path', 'data', _p._writeFile]
        }
      , {
            write: [true, 'path', 'data', _p._writeFile]
        }
      , ['info']
      , function(obtain, info) { return obtain('write'); }
    )

    /**
     * Read the glif from I/O and cache it. Return a reference to the
     * cache object: [text, mtime, glifDocument(if alredy build by this.getGLIFDocument)]
     *
     * Has the obtainJS sync/async api.
     *
     * Does something with mtimes to check if the cache needs invalidation.
     * I'm not shure whether its a good idea to implement this with all
     * the calls to mtime, but its done.
     */
    _p._getGLIFcache =  obtain.factory(
        { //sync
            fileName: ['glyphName', function fileName(glyphName) {
                var name = this.contents[glyphName];
                if(!(glyphName in this.contents) || this.contents[glyphName] === undefined)
                    throw new KeyError(glyphName);
                return this.contents[glyphName]
            }]
          , glyphNameInCache: ['glyphName', function(glyphName) {
                return glyphName in this._glifCache;
            }]
          , path: ['fileName', function(fileName) {
                return [this.dirName, fileName].join('/');
            }]
          , mtime: ['path', 'glyphName', function(path, glyphName) {
                try {
                    return this._io.getMtime(false, path);
                }
                catch(error) {
                    if(error instanceof IONoEntryError)
                        error = new KeyError(glyphName, error.stack);
                    throw error;
                }
            }]
          , text: ['path', 'glyphName', function(path, glyphName) {
                try {
                    return this._io.readFile(false, path);
                }
                catch(error) {
                    if(error instanceof IONoEntryError)
                        error = new KeyError(glyphName, error.stack);
                    throw error;
                }
            }]
          , refreshedCache: ['glyphName', 'text', 'mtime',
            function(glyphName, text, mtime) {
                return (this._glifCache[glyphName] = [text, mtime]);
            }]
        }
        //async getters
      , {
            mtime: ['path', 'glyphName', '_callback',
            function(path, glyphName, callback) {
                var _callback = function(error, result){
                    if(error instanceof IONoEntryError)
                        error = new KeyError(glyphName, error.stack);
                    callback(error, result)
                }
                this._io.getMtime({unified: _callback}, path);
            }]
          , text: ['path', 'glyphName', '_callback',
            function(path, glyphName, callback){
                var _callback = function(error, result) {
                    if(error instanceof IONoEntryError)
                        error = new KeyError(glyphName, error.stack);
                    callback(error, result)
                }
                this._io.readFile({unified: _callback}, path);
            }
          ]
        }
        , ['glyphName']
        , function job(obtain, glyphName) {
            if(obtain('glyphNameInCache')) {
                if(obtain('mtime').getTime() === this._glifCache[glyphName][1].getTime()) {
                    // cache is fresh
                    return this._glifCache[glyphName];
                }
            }
            // still here? need read!
            // refreshing the cache:
            obtain('refreshedCache')
            return this._glifCache[glyphName];
        }
    )

    /**
     * This uses synchronous and asynchronous IO
     *
     * The python docstring reads:
     * Get the raw GLIF text for a given glyph name. This only works
     * for GLIF files that are already on disk.
     *
     * This method is useful in situations when the raw XML needs to be
     * read from a glyph set for a particular glyph before fully parsing
     * it into an object structure via the readGlyph method.
     *
     * Internally, this method will load a GLIF the first time it is
     * called and then cache it. The next time this method is called
     * the GLIF will be pulled from the cache if the file's modification
     * time has not changed since the GLIF was cached. For memory
     * efficiency, the cached GLIF will be purged by various other methods
     * such as readGlyph.
     */
    _p.getGLIF = obtain.factory(
        {cache:[false, 'glyphName', _p._getGLIFcache]}
      , {cache:[true, 'glyphName', _p._getGLIFcache]}
      , ['glyphName']
      , function(obtain) {
            return obtain('cache')[0]
        }
     )
    _p.getGLIFDocument = obtain.factory(
        {cache: [false, 'glyphName', _p._getGLIFcache]}
      , {cache: [true, 'glyphName', _p._getGLIFcache]}
      , ['glyphName']
      , function(obtain) {
            var cache = obtain('cache')
              , parser
              , glifDoc
              ;
            if(cache[2] === undefined)
                cache[2] = xml.parseXMLString(cache[0]);
            return cache[2];
        }
    )
    /**
     * used for convinience with the getUnicodes etc. methods
     */
    _p._getGLIFDocuments = obtain.factory(
        {
            glyphNames: ['requested', function(requested) {
                if(requested !== undefined)
                    return main.setLike(requested);
                return  this.contents;
            }]
          , docs: ['glyphNames', function(glyphNames) {
                var name
                  , docs = {}
                  ;
                for(name in glyphNames)
                    docs[name] = this.getGLIFDocument(false, name);
                return docs;
            }]
        }
      , {
            docs: ['glyphNames', '_callback', '_errback',
            function(glyphNames, callback, errback) {
                var name
                  , docs = {}
                  , failed = false
                  , requested = 0
                  , ioCallback = function(boundName, error, result) {
                        requested -= 1;
                        // if it failed once we won't have to use the
                        // callbacks anymore, although it may be an
                        // option to write this to the logs in the future
                        if(failed)
                            return;
                        if(error) {
                            failed = true;
                            errback(error)
                            return;
                        }
                        docs[boundName] = result;
                        if(requested === 0)
                            // all requested files where found
                            callback(docs);
                    }
                  ;
                // we just fire all now. the idea is that the io module
                // will have to throttle stuff like this in the future
                // (and should provide an api to cancel the already fired
                // requests, when possible)
                for(name in glyphNames) {
                    requested += 1;
                    this.getGLIFDocument(
                        {unified:ioCallback.bind(null, name)}, name);
                }
                // if there was no glyphName
                if(requested === 0)
                    setTimeout(function(){callback(docs)}, 0);
            }]
        }
      , ['requested']
      , function(obtain, requested){return obtain('docs');}
    )
    /**
     * Get the modification time (as reported by os.path.getmtime)
     * of the GLIF with glyphName.
     */
    _p.getGLIFModificationTime = obtain.factory(
        {cache: [false, 'glyphName', _p._getGLIFcache]}
      , {cache: [true, 'glyphName', _p._getGLIFcache]}
      , ['glyphName']
      , function(obtain, glyphName) {
            return obtain('cache')[1]
    })
    _p._purgeCachedGLIF = function(glyphName) {
        if(glyphName in this._glifCache)
            delete this._glifCache[glyphName];
    }
    // reading/writing API
    /**
     * Read a .glif file for 'glyphName' from the glyph set. The
     * 'glyphObject' argument can be any kind of object (even None);
     * the readGlyph() method will attempt to set the following
     * attributes on it:
     *     "width"      the advance with of the glyph
     *     "height"     the advance height of the glyph
     *     "unicodes"   a list of unicode values for this glyph
     *     "note"       a string
     *     "lib"        a dictionary containing custom data
     *     "image"      a dictionary containing image data
     *     "guidelines" a list of guideline data dictionaries
     *
     * All attributes are optional, in two ways:
     *     1) An attribute *won't* be set if the .glif file doesn't
     *     contain data for it. 'glyphObject' will have to deal
     *     with default values itself.
     *     2) If setting the attribute fails with an AttributeError
     *     (for example if the 'glyphObject' attribute is read-
     *     only), readGlyph() will not propagate that exception,
     *     but ignore that attribute.
     *
     * To retrieve outline information, you need to pass an object
     * conforming to the PointPen protocol as the 'pointPen' argument.
     * This argument may be None if you don't need the outline data.
     *
     * readGlyph() will raise KeyError if the glyph is not present in
     * the glyph set.
     */
    _p.readGlyph = obtain.factory(
        {glifDoc:[false, 'glyphName', _p.getGLIFDocument]}
      , {glifDoc:[true, 'glyphName', _p.getGLIFDocument]}
      , ['glyphName', 'glyphObject', 'pointPen']
      , function(obtain, glyphName, glyphObject/* undefined */,
                 pointPen/* undefined */)
        {
            var glifDoc, formatVersions;
            glifDoc = obtain('glifDoc');
            // purging the cache seems not always desireable
            // I wish here was more control over this.
            this._purgeCachedGLIF(glyphName);
            formatVersions = this.ufoFormatVersion < 3
                    ? [1]
                    : [1, 2];

            this._glyphReader.fromDOM(glifDoc, glyphObject, pointPen, formatVersions);
            return glyphObject;
        }
    )

    /**
     * Write a .glif file for 'glyphName' to the glyph set. The
     * 'glyphObject' argument can be any kind of object (even None);
     * the writeGlyph() method will attempt to get the following
     * attributes from it:
     *     "width"      the advance with of the glyph
     *     "height"     the advance height of the glyph
     *     "unicodes"   a list of unicode values for this glyph
     *     "note"       a string
     *     "lib"        a dictionary containing custom data
     *     "image"      a dictionary containing image data
     *     "guidelines" a list of guideline data dictionaries
     *
     * All attributes are optional: if 'glyphObject' doesn't
     * have the attribute, it will simply be skipped.
     *
     * To write outline data to the .glif file, writeGlyph() needs
     * a function (any callable object actually) that will take one
     * argument: an object that conforms to the PointPen protocol.
     * The function will be called by writeGlyph(); it has to call the
     * proper PointPen methods to transfer the outline to the .glif file.
     *
     * The GLIF format version will be chosen based on the ufoFormatVersion
     * passed during the creation of this object. If a particular format
     * version is desired, it can be passed with the formatVersion argument.
     *
     * Exposes an obtainJS sync/async API
     *
     * @obtainAPI: sync/async switch
     * @glyphName: string
     * @glyphObject: object|undefined
     * @drawPointsFunc: function|undefined
     * @formatVersion: int|undefined
     */
    _p.writeGlyph = obtain.factory(
        {
            checkedFormatVersion: ['formatVersion',
            function(formatVersion) {
                if(formatVersion === undefined) {
                    if(this.ufoFormatVersion >= 3)
                        return 2;
                    return 1;
                }
                if(!(formatVersion in constants.supportedGLIFFormatVersions))
                    throw new GlifLibError('Unsupported GLIF format version: '
                        + formatVersion);
                if(formatVersion == 2 && this.ufoFormatVersion < 3)
                    throw new GlifLibError('Unsupported GLIF format version ('
                        + formatVersion + ') for UFO format version '
                        + this.ufoFormatVersion + '.');
                return formatVersion;
            }]
          , data: ['glyphName', 'glyphObject', 'drawPointsFunc'
                            , 'checkedFormatVersion' , 'options', writeGlyph.toString]
          , fileName: ['glyphName', function(glyphName) {
                var fileName = this.contents[glyphName];
                if(fileName === undefined) {
                    fileName = this.glyphNameToFileName(glyphName, this);
                    this.contents[glyphName] = fileName;
                    if(this._reverseContents !== undefined)
                        this._reverseContents[fileName.toLowerCase()] = glyphName;
                }
                return fileName;
            }]
          , path: ['fileName', function(fileName) {
                return [this.dirName, fileName].join('/');
            }]
          , oldData: ['path', function(path) {
                try {
                    return this._io.readFile(false, path);
                }
                catch(error) {
                    if(error instanceof IONoEntryError)
                        return null;
                    throw error;
                }
            }]
          , dataHasChanged: ['data', 'oldData', function(data, oldData) {
                return data !== oldData;
            }]
          , write: [false, 'path', 'data', _p._writeFile]
        }
      , {
            oldData: ['path', '_callback',
            function(path, callback) {
                var _callback = function(error, result) {
                    if(error instanceof IONoEntryError){
                        error = undefined;
                        result = null;
                    }
                    callback(error, result);
                }
                this._io.readFile({unified: _callback}, path)
            }]
          , write: [true, 'path', 'data', _p._writeFile]
        }
      , ['glyphName', 'glyphObject', 'drawPointsFunc', 'formatVersion', 'options']
      , function(obtain, glyphName, glyphObject/*undefined*/,
            drawPointsFunc/*undefined*/, formatVersion/*undefined*/,
            options/*undefined*/)
        {
            this._purgeCachedGLIF(glyphName);
            // TOOD: Check if it's wise to load the old data here
            // it just fragments the process.
            if(!obtain('dataHasChanged'))
                return;
            return obtain('write');
        }
    )
    /**
     * Exposes an obtainJS sync/async API
     *
     * Permanently delete the glyph from the glyph set on disk. Will
     * raise KeyError if the glyph is not present in the glyph set.
     */
    _p.deleteGlyph = obtain.factory(
        {
            path: ['glyphName', function(glyphName){
                var fileName = this.contents[glyphName];
                return [this.dirName, fileName].join('/');
            }]
          , delete: [false, 'path', _p._unlink]
        }
      , {
            delete: [true, 'path', _p._unlink]
        }
      , ['glyphName']
      , function (obtain, glyphName) {
            this._purgeCachedGLIF(glyphName);
            obtain('delete');
            if(this._reverseContents !== undefined)
                delete this._reverseContents[this.contents[glyphName].toLowerCase()];
            delete this.contents[glyphName];
        }
    )

    // dict-like support 
    // there is no magic happening like in python, but we do something
    // in the same mind when possible.

    /**
     * def keys(self):
     *  return self.contents.keys()
     * use:
     *
     * for(var k in glyphSet.contents);
     *
     * in python the keys method is used like the following most of the time
     *
     * for k in glyphSet.keys():
     *      pass
     */
    _p.keys = function() {
        return Object.keys(this.contents);
    }

    /**
     * the same as:
     *     glyphName in this.contents
     */
    _p.has_key = function(glyphName) {
        return glyphName in this.contents;
    }

    /**
     * count the items in this.contents
     */
    _p.getLength = function() {
        var length = 0;
        for(var k in this.contents)
            length += 1;
        return length;
    }

    // removed, because the length property indicates an array-like inteface
    // at least an interface that can be used with Array-Generics, which is
    // not the case at all!
    // Object.defineProperty(_p, 'length', {
    //     get: function() {
    //         return this.getLength();
    //     }
    // })
    /**
     * this is magic, too
     * Notice that the glyphClass is initialized here.
     */
    _p.get = function(glyphName) {
        if(!(glyphName in this.contents))
            throw new KeyError(glyphName);
        return new this.GlyphClass(glyphName, this);
    }
    /**
     * @mapper: function that takes a glyph document and returns a result
     * @glyphNames: a list of glyph names or undefined
     *
     * Returns a dict with the glyphNames as key and the results of
     * mapper as values.
     *
     * Exposes an obtainJS sync/async API
     */
    _p._mapGLIFDocuments = obtain.factory(
        {docs: [false, 'glyphNames', _p._getGLIFDocuments]}
      , {docs: [true, 'glyphNames', _p._getGLIFDocuments]}
      , ['glyphNames', 'mapper']
      , function(obtain, glyphNames, mapper) {
            var result = {}
              , glyphName
              , docs
              ;
            docs = obtain('docs');
            for(glyphName in docs)
                result[glyphName] = mapper(docs[glyphName]);
            return result;
        }
    )
    // quickly fetch unicode values
    /**
     * Exposes an obtainJS sync/async API
     *
     * not shure if this makes sense in our scenario ... parsing files
     * partially etc.
     *
     * Return a dictionary that maps glyph names to lists containing
     * the unicode value[s] for that glyph, if any. This parses the .glif
     * files partially, so it is a lot faster than parsing all files completely.
     * By default this checks all glyphs, but a subset can be passed with glyphNames.
     */
    _p.getUnicodes = function(obtainAsyncSwitch, glyphNames) {
        return this._mapGLIFDocuments(obtainAsyncSwitch, glyphNames,
                                                      fetchUnicodes)
    }

    /**
     * Exposes an obtainJS sync/async API
     *
     * Return a dictionary that maps glyph names to lists containing the
     * base glyph name of components in the glyph. This parses the .glif
     * files partially, so it is a lot faster than parsing all files completely.
     * By default this checks all glyphs, but a subset can be passed with glyphNames.
     */

    _p.getComponentReferences = function(obtainAsyncSwitch, glyphNames) {
        return this._mapGLIFDocuments(obtainAsyncSwitch, glyphNames,
                                                fetchComponentBases)
    }
    /**
     * Exposes an obtainJS sync/async API
     *
     * Return a dictionary that maps glyph names to the file name of the image
     * referenced by the glyph. This parses the .glif files partially, so it is a
     * lot faster than parsing all files completely.
     * By default this checks all glyphs, but a subset can be passed with glyphNames.
     */
    _p.getImageReferences = function(obtainAsyncSwitch, glyphNames) {
        return this._mapGLIFDocuments(obtainAsyncSwitch, glyphNames,
                                                fetchImageFileName)
    }

    return GlyphSet;
});

/**
 * Copyright (c) 2011, Lasse Fister lasse@graphicore.de, http://graphicore.de
 * 
 * You should have received a copy of the MIT License along with this program.
 * If not, see http://www.opensource.org/licenses/mit-license.php
 * 
 * The functions decomposeSuperBezierSegment and decomposeQuadraticSegment 
 * are a translation of the equally named functions defined in
 * fontTools/pens/basePen.py The svn revision of the source file in
 * trunk/Lib/ was 498 from 2005-04-10 15:18:42 +0200
 * 
 * I even copied the docstrings and comments! (These may still refer to the Python code)
 * 
 * //////////////////////////////////////////////
 * 
 * straight from fontTools/pens/basePen.py
 * fontTools.pens.basePen.py -- Tools and base classes to build pen objects.
 * 
 * The Pen Protocol
 * 
 * A Pen is a kind of object that standardizes the way how to "draw" outlines:
 * it is a middle man between an outline and a drawing. In other words:
 * it is an abstraction for drawing outlines, making sure that outline objects
 * don't need to know the details about how and where they're being drawn, and
 * that drawings don't need to know the details of how outlines are stored.
 * 
 * The most basic pattern is this:
 * 
 *     outline.draw(pen)  # 'outline' draws itself onto 'pen'
 * 
 * Pens can be used to render outlines to the screen, but also to construct
 * new outlines. Eg. an outline object can be both a drawable object (it has a
 * draw() method) as well as a pen itself: you *build* an outline using pen
 * methods.
 * 
 * The AbstractPen class defines the Pen protocol. It implements almost
 * nothing (only no-op closePath() and endPath() methods), but is useful
 * for documentation purposes. Subclassing it basically tells the reader:
 * "this class implements the Pen protocol.". An examples of an AbstractPen
 * subclass is fontTools.pens.transformPen.TransformPen.
 * 
 * The BasePen class is a base implementation useful for pens that actually
 * draw (for example a pen renders outlines using a native graphics engine).
 * BasePen contains a lot of base functionality, making it very easy to build
 * a pen that fully conforms to the pen protocol. Note that if you subclass
 * BasePen, you _don't_ override moveTo(), lineTo(), etc., but _moveTo(),
 * _lineTo(), etc. See the BasePen doc string for details. Examples of
 * BasePen subclasses are fontTools.pens.boundsPen.BoundsPen and
 * fontTools.pens.cocoaPen.CocoaPen.
 * 
 * Coordinates are usually expressed as (x, y) tuples, but generally any
 * sequence of length 2 will do.
 */
define('ufojs/tools/pens/main',['ufojs/main', 'ufojs/errors'], function(main, errors){
    
    var assert = errors.assert,
        range = main.range;
    
    /**
     * Split the SuperBezier described by 'points' into a list of regular
     * bezier segments. The 'points' argument must be a list with length
     * 3 or greater, containing [x, y] coordinates. The last point is the
     * destination on-curve point, the rest of the points are off-curve points.
     * The start point should not be supplied.
     * 
     * This function returns a list of [pt1, pt2, pt3] lists, which each
     * specify a regular curveto-style bezier segment.
     */
    function decomposeSuperBezierSegment(points) {
        var n = points.length - 1,
            bezierSegments = [],
            pt1 = points[0],
            pt2 = null,
            pt3 = null,
            i, j, nDivisions, factor, temp1, temp2, temp;
        
        assert(n > 1, 'Expecting at least 3 Points here');
        
        for (i in range(2, n+1))
        {
            i -= 0;//cast this to int
            // calculate points in between control points.
            nDivisions = Math.min(i, 3, n - i + 2);
            // used to be d = float(nDivisions) in the python source but
            // in js all numbers are float and there is no integer division
            // thing like in the older versions of python:
            //    e.g. 2 / 3 = 0 but 2 / 3.0 = 0.6666666666666666
            // so I'll use nDivision throughout
            for (j in range(1, nDivisions))
            {
                j -= 0;//cast this to int
                factor = j / nDivisions;
                temp1 = points[i-1];
                temp2 = points[i-2];
                temp = [
                    temp2[0] + factor * (temp1[0] - temp2[0]),
                    temp2[1] + factor * (temp1[1] - temp2[1])
                ];
                if (pt2 === null) {
                    pt2 = temp;
                } else {
                    pt3 = [
                        0.5 * (pt2[0] + temp[0]),
                        0.5 * (pt2[1] + temp[1])
                    ];
                    bezierSegments.push([pt1, pt2, pt3]);
                    pt1 = temp;
                    pt2 = null;
                    pt3 = null;
                }
            }
        }
        bezierSegments.push([pt1, points[points.length-2], points[points.length-1]]);
        return bezierSegments;
    };
    
   /**
    * Split the quadratic curve segment described by 'points' into a list
    * of "atomic" quadratic segments. The 'points' argument must be a list
    * with length 2 or greater, containing [x, y] coordinates. The last point
    * is the destination on-curve point, the rest of the points are off-curve
    * points. The start point should not be supplied.
    * 
    * This function returns a list of [pt1, pt2] lists, which each specify a
    * plain quadratic bezier segment.
    */
    function decomposeQuadraticSegment(points) {
        var n = points.length - 1,
            quadSegments = [],
            i, x, y, nx, ny, impliedPt;
        assert(n > 0, 'Expecting at least 2 Points here');
        for (i in range(n - 1))
        {
            //the keys of the list are strings, what makes i+1 == '01'
            i -= 0;//cast this to int
            x = points[i][0];
            y = points[i][1];
            nx = points[i+1][0];
            ny = points[i+1][1];
            impliedPt = [0.5 * (x + nx), 0.5 * (y + ny)];
            quadSegments.push([points[i], impliedPt]);
        }
        quadSegments.push( [points[points.length-2], points[points.length-1]] );
        return quadSegments;
    };
    return {
        decomposeSuperBezierSegment: decomposeSuperBezierSegment,
        decomposeQuadraticSegment: decomposeQuadraticSegment
    };
})
;
/**
 * Copyright (c) 2011, Lasse Fister lasse@graphicore.de, http://graphicore.de
 * 
 * You should have received a copy of the MIT License along with this program.
 * If not, see http://www.opensource.org/licenses/mit-license.php
 * 
 * This is a translation of AbstractPen defined in fontTools/pens/basePen.py
 * The svn revision of the source file in trunk/Lib/ was 498 from 2005-04-10 15:18:42 +0200
 * 
 * I even copied the docstrings and comments! (These may still refer to the Python code)
 */
define('ufojs/tools/pens/AbstractPen',['ufojs/main', 'ufojs/errors'], function(main, errors) {
    
    var enhance = main.enhance;
    //shortcuts
    var NotImplementedError = errors.NotImplemented;
    
    /*constructor*/
    var AbstractPen = function(){};

    /*inheritance*/
    //pass

    /*definition*/
    enhance(AbstractPen, {
        /**
         * Begin a new sub path, set the current point to 'pt'. You must
         * end each sub path with a call to pen.closePath() or pen.endPath().
         */
        moveTo: function(pt)
        {
            throw new NotImplementedError('AbstractPen has not implemented'
            +' moveTo');
        },
        /**
         * Draw a straight line from the current point to 'pt'.
         */
        lineTo: function(pt)
        {
             throw new NotImplementedError('AbstractPen has not implemented'
            +' lineTo');
        },
        /**
         * Draw a cubic bezier with an arbitrary number of control points.
         *
         * The last point specified is on-curve, all others are off-curve
         * (control) points. If the number of control points is > 2, the
         * segment is split into multiple bezier segments. This works
         * like this:
         *
         * Let n be the number of control points (which is the number of
         * arguments to this call minus 1). If n==2, a plain vanilla cubic
         * bezier is drawn. If n==1, we fall back to a quadratic segment and
         * if n==0 we draw a straight line. It gets interesting when n>2:
         * n-1 PostScript-style cubic segments will be drawn as if it were
         * one curve. See decomposeSuperBezierSegment().
         *
         * The conversion algorithm used for n>2 is inspired by NURB
         * splines, and is conceptually equivalent to the TrueType "implied
         * points" principle. See also decomposeQuadraticSegment().
         */
        curveTo: function(/* *points */)
        {
            throw new NotImplementedError('AbstractPen has not implemented'
            +' curveTo');
        },
        /**
         * Draw a whole string of quadratic curve segments.
         * 
         * The last point specified is on-curve, all others are off-curve
         * points.
         * 
         * This method implements TrueType-style curves, breaking up curves
         * using 'implied points': between each two consequtive off-curve points,
         * there is one implied point exactly in the middle between them. See
         * also decomposeQuadraticSegment().
         * 
         * The last argument (normally the on-curve point) may be None.
         * This is to support contours that have NO on-curve points (a rarely
         * seen feature of TrueType outlines).
         */
        qCurveTo: function (/* *points */)
        {
            throw new NotImplementedError('AbstractPen has not implemented'
            +' qCurveTo');
        },
        /**
         * Close the current sub path. You must call either pen.closePath()
         * or pen.endPath() after each sub path.
         */
        closePath: function()
        {
            //pass
        },
        /**
         * End the current sub path, but don't close it. You must call
         * either pen.closePath() or pen.endPath() after each sub path.
         */
        endPath: function()
        {
            //pass
        },
        /**
         * Add a sub glyph. The 'transformation' argument must be a 6-tuple
         * containing an affine transformation, or a Transform object from the
         * fontTools.misc.transform module. More precisely: it should be a
         * sequence containing 6 numbers.
         */
        addComponent: function(glyphName, transformation)
        {
            throw new NotImplementedError('AbstractPen has not implemented'
            +' addComponent');
        }
    });
    return AbstractPen;
});

/**
 * Copyright (c) 2011, Lasse Fister lasse@graphicore.de, http://graphicore.de
 * 
 * You should have received a copy of the MIT License along with this program.
 * If not, see http://www.opensource.org/licenses/mit-license.php
 * 
 * This is a translation of TransformPen defined in fontTools/pens/transformPen.py
 * The svn revision of the source file in trunk/Lib/ was 453 from 2003-09-16 12:14:48 +0200
 * 
 * I even copied the docstrings and comments! (These may still refer to the Python code)
 */

define(
    'ufojs/tools/pens/TransformPen',[
        'ufojs/main',
        './AbstractPen',
        '../misc/transform'
    ],
    function(
        main,
        AbstractPen,
        transform
    )
{
    
    var enhance = main.enhance,
        Transform = transform.Transform;
    /**
     * Pen that transforms all coordinates using a Affine transformation,
     * and passes them to another pen.
     */
     
    /*constructor*/
    /**
     * The 'outPen' argument is another pen object. It will receive the
     * transformed coordinates. The 'transformation' argument can either
     * be a six-element Array, or a tools.misc.transform.Transform object.
     */
    function TransformPen(outPen, transformation) {
        if( transformation instanceof Array)
            transformation = new Transform(transformation);
        this._transformation = transformation;
        this._transformPoint = function(pt) {
            return transformation.transformPoint(pt);
        }
        this._outPen = outPen;
        this._stack = [];
    };

    /*inheritance*/
    TransformPen.prototype = new AbstractPen;

    /*definition*/
    enhance(TransformPen, {
        moveTo: function(pt)
        {
            this._outPen.moveTo(this._transformPoint(pt));
        },
        lineTo: function(pt)
        {
            this._outPen.lineTo(this._transformPoint(pt));
        },
        curveTo: function(/* *points */)
        {
            var points = [].slice.call(arguments);//transform arguments to an array
            this._outPen.curveTo.apply(this._outPen, this._transformPoints(points));
        },
        qCurveTo: function (/* *points */)
        {
            var points = [].slice.call(arguments);//transform arguments to an array
            if (points[points.length -1] === null) {
                points = this._transformPoints(points.slice(0, -1));
                points.push(null);
            } else {
                points = this._transformPoints(points);
            }
            this._outPen.qCurveTo.apply(this._outPen, points);
        },
        _transformPoints: function(points)
        {
            return points.map(this._transformPoint);
        },
        closePath: function()
        {
            this._outPen.closePath();
        },
        addComponent: function(glyphName, transformation)
        {
            transformation = this._transformation.transform(transformation);
            this._outPen.addComponent(glyphName, transformation);
        }
    });

    return TransformPen;
});

/**
 * Copyright (c) 2011, Lasse Fister lasse@graphicore.de, http://graphicore.de
 * 
 * You should have received a copy of the MIT License along with this program.
 * If not, see http://www.opensource.org/licenses/mit-license.php
 * 
 * This is a translation of BasePen defined in fontTools/pens/basePen.py
 * The svn revision of the source file in trunk/Lib/ was 498 from 2005-04-10 15:18:42  +0200
 * 
 * I even copied the docstrings and comments! (These may still refer to the Python code)
 */
define(
    'ufojs/tools/pens/BasePen',[
        'ufojs/main',
        'ufojs/errors',
        './main',
        './AbstractPen',
        './TransformPen'
    ],
    function(
        mainmain,
        errors,
        main,
        AbstractPen,
        TransformPen
) {
    
    var enhance = mainmain.enhance,
        NotImplementedError = errors.NotImplemented,
        AssertionError = errors.Assertion,
        decomposeSuperBezierSegment = main.decomposeSuperBezierSegment,
        decomposeQuadraticSegment = main.decomposeQuadraticSegment,
        assert = errors.assert;
    /**
     * Base class for drawing pens. You must override _moveTo, _lineTo and
     * _curveToOne. You may additionally override _closePath, _endPath,
     * addComponent and/or _qCurveToOne. You should not override any other
     * methods.
     */
    /*constructor*/
    function BasePen (glyphSet) {
        this.glyphSet = glyphSet;
        this.__currentPoint = null;
    };

    /*inheritance*/
    BasePen.prototype = Object.create(AbstractPen.prototype);

    /*definition*/
    enhance(BasePen, {
        
        // must override
        
        _moveTo: function(pt, kwargs/* optional, object contour attributes*/)
        {
            throw new NotImplementedError('implement _moveTo');
        },
        _lineTo: function(pt)
        {
            throw new NotImplementedError('implement _lineTo');
        },
        _curveToOne: function(pt1, pt2, pt3)
        {
            throw new NotImplementedError('implement _curveToOne');
        },
        
        // may override
        
        _closePath: function()
        {
            //pass
        },
        _endPath: function()
        {
            //pass
        },
        /**
         * This method implements the basic quadratic curve type. The
         * default implementation delegates the work to the cubic curve
         * function. Optionally override with a native implementation.
         */
        _qCurveToOne: function(pt1, pt2)
        {
            var pt0x = this.__currentPoint[0],
                pt0y = this.__currentPoint[1],
                pt1x = pt1[0],
                pt1y = pt1[1],
                pt2x = pt2[0],
                pt2y = pt2[1],
                mid1x = pt0x + 0.66666666666666667 * (pt1x - pt0x),
                mid1y = pt0y + 0.66666666666666667 * (pt1y - pt0y),
                mid2x = pt2x + 0.66666666666666667 * (pt1x - pt2x),
                mid2y = pt2y + 0.66666666666666667 * (pt1y - pt2y);
            this._curveToOne([mid1x, mid1y], [mid2x, mid2y], pt2)
        },
        /**
         * This default implementation simply transforms the points
         * of the base glyph and draws it onto self.
         */
        addComponent: function(glyphName, transformation, kwargs /*optional, object*/)
        {
            var glyph = (typeof this.glyphSet.get === 'function')
                ? this.glyphSet.get(glyphName)
                : this.glyphSet[glyphName];
            if(glyph !== undefined) {
                var tPen = new TransformPen(this, transformation);
                // using the synchronous call!
                // load components before drawing the glyph if this is
                // not good for your case!
                // addComponent can't get a asynchronous api because
                // we would break the pen protocol then
                glyph.draw(false, tPen);
            }
        },
        
        // don't override
        
        /**
         * Return the current point. This is not part of the public
         * interface, yet is useful for subclasses.
         */
        _getCurrentPoint: function()
        {
            return this.__currentPoint;
        },
        closePath: function()
        {
            this._closePath();
            this.__currentPoint = null;
        },
        endPath: function()
        {
            this._endPath();
            this.__currentPoint = null;
        },
        moveTo: function(pt, kwargs/* optional, object contour attributes*/)
        {
            this._moveTo.apply(this, arguments);
            this.__currentPoint = pt;
        },
        lineTo: function(pt)
        {
            this._lineTo(pt);
            this.__currentPoint = pt;
        },
        curveTo: function(/* *points */)
        {
            var points = [].slice.call(arguments),//transform arguments to an array
                n = points.length - 1;// 'n' is the number of control points
            assert(n >= 0, 'curveTo needs at least one point');
            if (n == 2) {
                // The common case, we have exactly two BCP's, so this is a standard
                // cubic bezier. Even though decomposeSuperBezierSegment() handles
                // this case just fine, we special-case it anyway since it's so
                // common.
                this._curveToOne.apply(this, points);
                this.__currentPoint = points[points.length - 1];
            } else if (n > 2) {
                // n is the number of control points; split curve into n-1 cubic
                // bezier segments. The algorithm used here is inspired by NURB
                // splines and the TrueType "implied point" principle, and ensures
                // the smoothest possible connection between two curve segments,
                // with no disruption in the curvature. It is practical since it
                // allows one to construct multiple bezier segments with a much
                // smaller amount of points.
                var _curveToOne = this._curveToOne,
                    segments = decomposeSuperBezierSegment(points),
                    segment, i;
                for (i in segments) {
                    segment = segments[i];
                    //var pt1 = segment[0];
                    //var pt2 = segment[1];
                    //var pt3 = segment[2];
                    _curveToOne.apply(this ,segment);
                    this.__currentPoint = segment[2];//pt3
                }
            } else if (n == 1) {
                this.qCurveTo.apply(this, points);
            } else if (n == 0) {
                this.lineTo(points[0]);
            } else {
                throw new AssertionError("curveTo() can't get there from here");
            }
        },
        qCurveTo: function(/* *points */)
        {
            var points = [].slice.call(arguments),//transform arguments to an array
                n = points.length - 1; //'n' is the number of control points
            assert(n >= 0, 'qCurveTo needs at least one point');
            if (points[points.length -1] === null) {
                // Special case for TrueType quadratics: it is possible to
                // define a contour with NO on-curve points. BasePen supports
                // this by allowing the final argument (the expected on-curve
                // point) to be null. We simulate the feature by making the implied
                // on-curve point between the last and the first off-curve points
                // explicit.
                var x = points[points.length -2][0], // last off-curve point x
                    y = points[points.length -2][1], // last off-curve point y
                    nx = points[0][0], // first off-curve point x
                    ny = points[0][1], // first off-curve point y
                    impliedStartPoint = [ 0.5 * (x + nx), 0.5 * (y + ny) ];
                this.__currentPoint = impliedStartPoint;
                this._moveTo(impliedStartPoint);
                points.splice(-1, 1, impliedStartPoint);//splice syntax is: index, howMany, *elements to insert
            }
            if (n > 0) {
                // Split the string of points into discrete quadratic curve
                // segments. Between any two consecutive off-curve points
                // there's an implied on-curve point exactly in the middle.
                // This is where the segment splits.
                var _qCurveToOne = this._qCurveToOne,
                    segments = decomposeQuadraticSegment(points),
                    segment, i;
                for (i in segments) {
                    segment = segments[i];
                    //var pt1 = segment[0];
                    //var pt2 = segment[1];
                    _qCurveToOne.apply(this, segment);
                    this.__currentPoint = segment[1]; //pt2
                }
            } else {
                this.lineTo(points[0]);
            }
        }
    });

    return BasePen;
});

define('metapolator/project/import/SegmentPoint',[
    'metapolator/errors'
  , 'metapolator/math/Vector'
], function(
    errors
  , Parent
) {
    
    var DeprecatedError = errors.Deprecated;

    function SegmentPoint(xy, smooth, name, kwargs) {
        Parent.apply(this, xy);

        this.smooth = smooth;
        this.name = name;

        // I expect the 'identifier' keyword here, but that kwds syntax
        // could bring in even more names.
        this.kwargs = kwargs || {};
    }

    SegmentPoint.factory = function(xy, smooth, name, kwargs) {
        return new SegmentPoint(xy, smooth, name, kwargs);
    };

    var _p = SegmentPoint.prototype = Object.create(Parent.prototype);

    _p.toString = function() {
        return '<SegmentPoint'
            + (this.name ? ' ' + this.name : '')
            + ' ' + this.valueOf() +'>';
    };

    Object.defineProperty(_p, 'vector', {
        get: function() {
            throw new DeprecatedError('SegmentPoint is now a subclass of '
                +' metapolator/math/Vector don\'t use this property.');
        }
    });

    return SegmentPoint;
});

/**
 * Copyright (c) 2011, Lasse Fister lasse@graphicore.de, http://graphicore.de
 *
 * You should have received a copy of the MIT License along with this program.
 * If not, see http://www.opensource.org/licenses/mit-license.php
 *
 * This is a translation of BasePen defined in fontTools/pens/basePen.py
 * The svn revision of the source file in trunk/Lib/ was 498 from 2005-04-10 15:18:42  +0200
 *
 * I even copied the docstrings and comments! (These may still refer to the Python code)
 */
define('metapolator/project/import/SegmentPen',[
    'ufojs/tools/pens/BasePen'
  , 'metapolator/errors'
  , './SegmentPoint'

], function(
    Parent
  , errors
  , Point
) {
    

    /*constructor*/
    function SegmentPen() {
        this._currentContour = null;
        this.contours = [];

        Parent.apply(this, [{}].concat(arguments));
    }

    /*inheritance*/
    var _p = SegmentPen.prototype = Object.create(Parent.prototype);
    _p.constructor = SegmentPen;

    _p._PointConstructor = Point;

    _p._pointFactory = function(val) {
        return (val instanceof Array)
            ? new this._PointConstructor(val)
             // expect it is already a Point
            : val;
    };

    _p._newContour = function(kwargs) {
        errors.assert(this._currentContour === null,
                                'this._currentContour should be null');
        this._currentContour = {
            commands: []
          , type: 'contour'
          , closed: undefined
          , kwargs: kwargs
        };
    };

    _p._closeContour = function() {
        // maybe if the contour is empty, this might happen ???
        // please report if you have trouble with this assertion
        errors.assert(this._currentContour !== null,
                                'this._currentContour should NOT be null');
        this.contours.push(this._currentContour);
        this._currentContour = null;
    };

    _p._endPath = function() {
        // assert this._currentContour !== null
        this._currentContour.closed = false;
        this._closeContour();
    };

    _p._closePath = function() {
        this._currentContour.closed = true;
        this._closeContour();
    };

    _p.flush = function() {
        var contours = this.contours;
        this.contours = [];
        this._currentContour = null;
        return contours;
    };

    _p._moveTo = function(pt, kwargs/* optional, object contour attributes*/) {
        this._newContour(kwargs);
        pt = this._pointFactory(pt);
        this._currentContour.commands.push(['moveTo', pt]);
    };

    _p._lineTo = function(pt)
    {
        pt = this._pointFactory(pt);
        this._currentContour.commands.push(['lineTo', pt]);
    };

    _p._curveToOne = function(pt1, pt2, pt3)
    {
        pt1 = this._pointFactory(pt1);
        pt2 = this._pointFactory(pt2);
        pt3 = this._pointFactory(pt3);
        this._currentContour.commands.push(['curveTo', pt1, pt2, pt3]);
    };

    _p.addComponent = function(glyphName, transformation, kwargs)
    {
        var component = {
            type:             'component'
            , transformation: transformation
            , glyphName:      glyphName
            , kwargs:         kwargs
        };
        this.contours.push(component);
    };

    return SegmentPen;
});

define(
    'metapolator/project/import/ImportOutlinePen',[
        'ufojs/main'
      , 'ufojs/errors'
      , 'ufojs/tools/pens/BasePointToSegmentPen'
      , './SegmentPoint'
    ],
    function(
        ufoJSUtils
      , errors
      , Parent
      , Point
) {
    
    var enhance = ufoJSUtils.enhance,
        assert = errors.assert;

    /*constructor*/
    /**
     * Based of a copy of PointToSegmentPen:
     * Adapter class that converts the PointPen protocol to the
     * (Segment)Pen protocol.
     */
    function ImportOutlinePen(
        segmentPen,
        outputImpliedClosingLine /* default: false*/
    ) {
        Parent.call(this);
        this.pen = segmentPen;
        this.outputImpliedClosingLine = (outputImpliedClosingLine || false);
    }

    /*inheritance*/
    ImportOutlinePen.prototype = Object.create(Parent.prototype);
    ImportOutlinePen.prototype.constructor = ImportOutlinePen;

    /*definition*/
    enhance(ImportOutlinePen, {
        _flushContour: function(segments, contour_kwargs)
        {
            assert(segments.length >= 1, 'Less than one segment');
            var pen = this.pen
              , closed, points, point, movePt, smooth, name, kwargs, segmentType
              ;
            if( segments[0][0] == "move" ) {
                // It's an open path.
                closed = false;
                points = segments[0][1];
                assert(points.length === 1, 'Points length is not 1');
                point = points[0];
                movePt = [0];
                smooth = points[0][1];
                name = points[0][2];
                kwargs = points[0][3];
                segments.splice(0, 1);
            } else {
                // It's a closed path, do a moveTo to the last
                // point of the last segment.
                closed = true;
                var segment = segments[segments.length - 1];
                segmentType = segment[0];
                points = segment[1];
                point = points[points.length - 1];
                movePt = point[0];
                smooth = point[1];
                name = point[2];
                kwargs = point[3];
            }
            if(movePt === null) {
                // quad special case: a contour with no on-curve points
                // contains one "qcurve" segment that ends with a point
                // that's null. We must not output a moveTo() in that case.
                // pass
            } else {
                pen.moveTo(new Point(movePt, smooth, name, kwargs), contour_kwargs);
            }
            var outputImpliedClosingLine = this.outputImpliedClosingLine,
                nSegments = segments.length;
            for(var i = 0; i < nSegments; i++) {
                segmentType = segments[i][0];
                points = [];
                for(var n = 0; n < segments[i][1].length; n++)
                    points.push(Point.factory.apply(null, segments[i][1][n]));

                if(segmentType == 'line') {
                    assert(points.length === 1, 'Points length is not 1');
                    var pt = points[0];
                    if(i + 1 != nSegments
                    || outputImpliedClosingLine
                    || !closed)
                        pen.lineTo(pt);
                } else if(segmentType == 'curve') {
                    pen.curveTo.apply(pen, points);
                } else if(segmentType == 'qcurve') {
                    pen.qCurveTo.apply(pen, points);
                } else {
                    throw new errors.Type('illegal segmentType: '
                        + segmentType);
                }
            }
            if(closed)
                pen.closePath();
            else
                pen.endPath();
        },
        addComponent: function(glyphName, transform)
        {
            this.pen.addComponent(glyphName, transform);
        }
    });
    return ImportOutlinePen;
});

define('metapolator/project/import/tools',[
    './SegmentPoint'
], function(
    Point
) {
    

    function line2curve(p0, p3) {
        var p1, p2
          , distance = (p3['-'](p0))['*'](0.33333)
          , newCurve = ['curveTo']
          ;
        // at a third between p0 and p3
        p1 = new Point(p0['+'](distance));
        // at 2 thirds between p3 and p0
        p2 = new Point(p3['-'](distance));

        newCurve.push(p1, p2, p3);
        newCurve.wasLine = true;
        return newCurve;
    }

    function getCenter(l, r) {
        return l['+'](r)['*'](0.5);
    }

    function makeNameDict(str) {
        var result = {};
        ((str || '').match(/\S+/g) || [])
            .forEach(function(piece){ this[piece] = null;}, result);
        return result;
    }

    /**
     * if a name/class/key "example" is only in left it becomes: "left-example"
     * if a name/class/key "example" is only in right it becomes: "right-example"
     * if a name/class/key "example" is in both it stays: "example"
     *
     * so if left is "hello world" and right is "hello univers" the result
     * will be: "hello left-world right-univers"
     */
    function mergeNames(LeftName, RightName) {
        var left = makeNameDict(LeftName)
          , right =  makeNameDict(RightName)
          , merged = {}
          , k
          ;

        for(k in left)
            if(k in right) {
                merged[k] = null;
                // it's in both, no need to see it again
                delete right[k];
            }
            else
                merged['left-' + k] = null;
        for(k in right)
            merged['right-' + k] = null;
        return Object.keys(merged).join(' ') || null;
    }

    function getCenterPoint(l, r) {
        return new Point(getCenter(l, r), undefined
                       , mergeNames(l.name, r.name));
    }

    function getCenterSegment(left, right) {
        var result = [left[0]], i=1;
        for(;i<left.length;i++)
            result.push(getCenterPoint(left[i], right[i]));
        return result;
    }

    /**
     * see the docstring of StrokeContoue._findNextDirection
     */
    function getDirection(point, firstRound, lastRound, testDirection,
                                                        test, control) {
        var testPointKeys, testPointKey, testPoint, offset;

        if(!firstRound || !lastRound)
            testPointKeys = testDirection === 1
                ? {out:true, on:true, 'in':true}
                : {'in':true, on:true, out:true}
                ;
        else if(firstRound)
            testPointKeys = testDirection === 1
                ? {out: true}
                : {'in': true}
                ;
        else // lastRound == true
            testPointKeys = testDirection === 1
                ? {'in': true}
                : {out: true}
                ;
        for(testPointKey in testPointKeys) {
            testPoint = test[testPointKey];
            offset = control === 'out'
                ? testPoint['-'](point.on)// point.out['-'](point.on)
                : point.on['-'](testPoint)// point.on['-'](point['in']);
                ;
            if(offset.magnitude())
                return offset.angle();
        }
        return false;
    }

    return {
        line2curve: line2curve
      , getCenter: getCenter
      , getCenterPoint: getCenterPoint
      , getCenterSegment: getCenterSegment
      , getDirection: getDirection
    };
});

define('metapolator/project/import/StrokeContour',[
    'metapolator/errors'
  , './tools'
  , 'metapolator/math/hobby'
], function(
    errors
  , tools
  , hobby
) {
    
    var AssertionError = errors.Assertion
      , ImportPenstroke = errors.ImportPenstroke
      , line2curve = tools.line2curve
      , getCenterPoint = tools.getCenterPoint
      , getDirection = tools.getDirection
      ;

    /**
     * This methods expects an input-contour like a SegementPen produces it.
     *
     * The 'implied' closing line argument of SegementPen must be included
     * which is *not* the default when using a ufoJS like PointToSegmentPen!
     * See the outputImpliedClosingLine of the PointToSegmentPen constructor.
     *
     * The input-contour must be a closed contour.
     *
     * The minimal length of the input-contour is 3 which yields in a one
     * item result.
     *
     * The input-contour is expected to have an uneven number of segments:
     * An initial 'moveTo' segment and an even number of either 'lineTo'
     * or 'curveTo' segments.
     *
     * This method treats the first on curve point as first point on
     * the right side and the on curve point before the last on curve
     * point as the first point on the left side. Each segement has one
     * on curve point and 0 or 3 off curve points.
     *
     * The last segment and segment with the index (contour.length-1)/2.
     * are used to reconstruct the imported shape using opening and closing
     * terminals.
     *
     * The result of this method is an array of arrays of left and right segment
     * pairs.
     *
     * The resulting left segments are a direction reversed representation
     * of the input-contours left-side segments. So the results left
     * and right side contours share the same direction.
     *
     * EXMAPLE:
     * A contour of length 11: 1 moveto  + 10 segments:
     *  [moveto, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
     *
     * left    4    right
     *         _
     *      5 | | 3
     *      6 | | 2
     *      7 | | 1
     *      8 |_| 0
     *           *
     *         9
     *
     * (*) moveTo is the point in the lower right corner.
     *
     *     result = [
     *        [openingTerminalSegment, openingTerminalSegment]
     *        [8, 0]
     *        [7, 1]
     *        [6, 2]
     *        [5, 3]
     *        [closingTerminalSegment, closingTerminalSegment]
     *     ]
     */
    function StrokeContour(contour) {
        this.length = 0;
            // skip the first moveto
        var right = 1
            // -1 for length to index translation,
            // -1 because the very last segment is the vector of the
            // pen, not part of the stroke
          , left = contour.length-2
          , zLength = (contour.length-1)*0.5
          , leftSegment, points
          , terminals = this._getTerminals(contour)
          ;

        // add the information needed for the opening terminal
        this._push([
            [undefined, terminals[0][1], contour[left].slice(-1).pop()]
          , [undefined, terminals[0][2], terminals[0][3]]
        ]);

        for(;right<zLength; right++, left--) {
            // the problem is, that the left contour is in the wrong
            // direction. so we have to reverse its direction:
            leftSegment = contour[left].slice(1,-1).reverse();
            // oncurve point of the previous segment
            leftSegment.push(contour[left-1].slice(-1).pop());

            this._push([leftSegment, contour[right].slice(1)]);
        }

        // add the information needed for the closing terminal
        this._push([
            [terminals[1][2], undefined, undefined]
          , [terminals[1][1], undefined, undefined]
        ]);
    }

    var _p = StrokeContour.prototype;
    _p.constructor = StrokeContour;

    /**
     * Return the control points for both terminal lines.
     * the direction for the stroke beginning terminal line left to right
     * the direction for the stroke ending terminal line is right to left.
     *
     * returns: [ beginning_segment, ending_segment ]
     */
    _p._getTerminals = function (contour) {
        var beginningIndex = contour.length-1
          , endingIndex = (contour.length-1) * 0.5
          , beginning = contour[beginningIndex]
          , ending = contour[endingIndex];

        if(beginning[0] !== 'curveTo') {
            beginning = line2curve(
                contour[beginningIndex-1].slice(-1).pop()
              , beginning[1]
            );
        }
        if(ending[0] !== 'curveTo') {
            ending = line2curve(
                contour[endingIndex-1].slice(-1).pop()
              , ending[1]
            );
        }

        return [beginning, ending];
    };

    _p._push = function(/* ... */) {
        var args = Array.prototype.slice.apply(arguments)
          , i=0, j
          , segments
          , segment
          ;
        for(;i<args.length;i++) {
            // args[i] === [leftSegment, rightSegment]
            segments = [];
            for(j=0;j<2;j++) {
                // Convert ALL lineTo to curveTo;
                // line2curve marks the new segment is marked with
                // segment.wasLine = true;
                if(args[i][j].length === 1) {
                    segment = line2curve(
                        this[this.length-1][j].slice(-1).pop()
                      , args[i][j][0]
                    );
                    // remove the segmentType
                    segment.shift();
                }
                else if(args[i][j].length === 3)
                    segment = args[i][j];
                else
                    // This means that probably  the code that created
                    // the contour argument for StrokeContour is faulty
                    // and must be repaired.
                    throw new AssertionError('A segment is expected to '
                        + ' have 3 items at this stage, but this has '
                        + args[i][j].length + ' items. '
                        + 'Segment: ' + args[i][j].join(', '));
                segments.push(segment);
            }
            Array.prototype.push.call(this, segments);
        }
    };

    /**
     * Returns a list of points like following:
     *
     * the coordinates are absolute.
     *
     * // one "point"
     *  {
     *      l: {
     *          in: Vector
     *        , out: Vector
     *        , on: Vector
     *        , wasLine: true|false
     *      }
     *    , r: {
     *          in: Vector
     *        , out: Vector
     *        , on: Vector
     *        , wasLine: true|false
     *      }
     *    , z: {
     *          in: Vector
     *        , out: Vector
     *        , on: Vector
     *        , wasLine: true|false
     *      }
     * }
     */

    _p._getMetapolatorPoint = function(i) {
        var point, left=0, right =1;

        // i   [[ , leftIn, leftOn], [ , rightIn, rightOn]]
        // i+1 [[leftOut , , ], [rightOut, , ]]

        point = {
            l: {
                'in': this[i][left][1]
               , on: this[i][left][2]
               , out: this[i+1][left][0]
               , wasLine: !!this[i][left].wasLine
            }
          , r: {
                'in': this[i][right][1]
              , on: this[i][right][2]
              , out: this[i+1][right][0]
              , wasLine: !!this[i][right].wasLine
            }
          , z: {}
        };

        point.z.on = getCenterPoint(point.l.on, point.r.on);
        point.z['in'] = getCenterPoint(point.l['in'], point.r['in']);
        point.z.out = getCenterPoint(point.l.out, point.r.out);
        point.z.wasLine = point.l.wasLine && point.r.wasLine;

        return point;
    };

    _p._getPenStroke = function() {
        var i
            // end is the element before the last element, because the last
            // element is just for the ending terminal of interest
          , end = this.length-1
          , result = []
          ;

        for(i=0; i<end; i++)
            result.push(this._getMetapolatorPoint(i));
        return result;
    };

    function _extractKey(key, value) {
        return value[key];
    }

    function _setKey(stroke, key, value, index) {
        stroke[index][key] = value;
    }

    /**
     * Find directions for any control point even when the naive approach
     * has no direction, because the distance of the offset to the on
     * curve point is 0.
     *
     * The algorithm finds the next point in control direction
     * (in|on|out OR out|on|in) that has a different position than
     * point.on and returns that direction in radians.
     *
     * In the normal case, just the direction of the control point is
     * returned.
     *
     * If the control shares the position with the on curve point,
     * i.e. point.on - point[control] === Vector 0, 0
     * the search t traverses the whole path until a direction can be
     * returned.
     * For the left and right path it traces the whole outline, for
     * the centerline it looks only at that. Not too many steps should be
     * needed to find a direction, but in the worst case -- when all
     * points are on the same position -- this will return false.
     *
     * Arguments:
     *
     * `stroke` is a stroke array as returned by StrokeContour._getPenStroke
     *
     * `pointIndex` is the numeric index of the stroke point in `stroke`
     *
     * `key` is 'l' (left), 'z' (center) or 'r' (right)
     *
     * `point` equals stroke[pointIndex][key]
     *
     * `control` is 'out' or 'in' to indicate in which direction we
     *      are searching. This means that we are searching an angle
     *      from `point.on` to 'point[control]' and if there is no
     *      natural angle for that point we go on and look at the next
     *      coordinate the path.
     */
    function _findNextDirection(stroke, pointIndex, key, point, control) {
        var normalIncrement = control === 'out' ? 1 : -1
          , increment = normalIncrement
          , i = pointIndex
          , countourKey = key
          , firstRound = true
          , lastRound
          , result
          ;

        while(true) {
            lastRound = i === pointIndex && !firstRound;
            result = getDirection(point, firstRound, lastRound,
                            increment, stroke[i][countourKey], control);
            firstRound = false;
            if(result !== false || lastRound)
                return result;

            // iterate
            if(key === 'z') {
                // we only change i
                if(increment === 1 && i === stroke.length-1)
                    i = 0;
                else if (increment === -1 && i === 0)
                    i = stroke.length-1;
                else
                    i += increment;
            }
            else { // key is 'l' or 'r'
                increment = (countourKey === key)
                    ? normalIncrement
                    : normalIncrement * -1
                    ;

                if((increment === 1 && i === stroke.length-1)
                                    || (increment === -1 && i === 0)) {
                    // switch to the other side of the stroke;
                    // i stays the same
                    countourKey = key === 'l' ? 'r':'l';
                    increment = increment * -1;
                }
                else
                    i += increment;
            }
        }
    }

    // TODO: Take care of contours marked as smooth, when the obvious
    // direction of a control point was not available. Then we could
    // improve the result of _findNextDirection by returning a smooth
    // connection.
    // If only one direction is a normal direction, the other
    // should be the inverse of that direction.
    // If both directions are 'artificial' the result should be averaged
    // to create a smooth direction.
    function _setPolarControls(stroke, key, point, index, contour) {
        var outVector, inVector, dir;
        outVector = point.out['-'](point.on);
        point.outLength = outVector.magnitude();
        dir = _findNextDirection(stroke, index, key, point, 'out');
        if(dir === false)
            throw new ImportPenstroke('can\'t find a outgoing direction '
                                        +'for point['+index+'].'+key);
        point.outDir = dir;
        inVector = point.on['-'](point['in']);
        point.inLength = inVector.magnitude();
        dir = _findNextDirection(stroke, index, key, point, 'in');
        if(dir === false)
            throw new ImportPenstroke('can\'t find a incoming direction '
                                        +'for point['+index+'].'+key);
        point.inDir = dir;
        return point;
    }

    function _setTensions(stroke, key, metapoint, index, contour) {
        var next
          , uv
          , point = metapoint[key]
          ;
        if(index !== contour.length-1) {
            next = contour[index+1][key];
            uv = hobby.magnitude2tension(
                                    point.on, point.outDir, point.outLength,
                                    next.inLength, next.inDir, next.on);
            point.outTension = uv[0];
            next.inTension = uv[1];
        }

        if(index === 0 && key === 'l') {
            // beginning terminal
            // only handled on the left side for both: 'l' and 'r'
            next =  metapoint.r;
            uv = hobby.magnitude2tension(
                                    point.on, point.inDir  + Math.PI, point.inLength,
                                    next.inLength, next.inDir, next.on);
            point.inTension = uv[0];
            next.inTension = uv[1];
        }
        else if(index === contour.length-1 && key === 'r') {
            // ending terminal
            // only handled on the right side for both: 'l' and 'r'
            next =  metapoint.l;
            uv = hobby.magnitude2tension(
                                    point.on, point.outDir, point.outLength,
                                    next.outLength, next.outDir + Math.PI, next.on);
            point.outTension = uv[0];
            next.outTension = uv[1];
        }
    }

    /**
     * Returns a list of points like following:
     *
     * the coordinates are absolute.
     *
     * // one "point"
     *  {
     *      l: {
     *          in: Vector
     *        , out: Vector
     *        , on: Vector
     *        , wasLine: true|false
     *        , outLength: real number
     *        , outDir: , angle in radians
     *        , inLength: real number
     *        , inDir: real number, angle in radians
     *        , outTension: real number or Infinity if outLength === 0
     *        , inTension: real number or Infinity if inLength === 0
     *      }
     *    , r: {
     *          in: Vector
     *        , out: Vector
     *        , on: Vector
     *        , wasLine: true|false
     *        , outLength: real number
     *        , outDir: , angle in radians
     *        , inLength: real number
     *        , inDir: real number, angle in radians
     *        , outTension: real number or Infinity if outLength === 0
     *        , inTension: real number or Infinity if inLength === 0
     *      }
     *    , z: {
     *          in: Vector
     *        , out: Vector
     *        , on: Vector
     *        , wasLine: true|false
     *        , outLength: real number
     *        , outDir: , angle in radians
     *        , inLength: real number
     *        , inDir: real number, angle in radians
     *      }
     * }
     */
    _p.getPenStroke = function() {
        var stroke = this._getPenStroke();
        stroke.map(_extractKey.bind(null,'l'))
              .map(_setPolarControls.bind(null, stroke,'l'))
              .forEach(_setKey.bind(null, stroke,'l'))
              ;
        stroke.map(_extractKey.bind(null,'r'))
              .map(_setPolarControls.bind(null, stroke,'r'))
              .forEach(_setKey.bind(null, stroke,'r'))
              ;

        stroke.map(_extractKey.bind(null,'z'))
              .map(_setPolarControls.bind(null, stroke,'z'))
              .forEach(_setKey.bind(null, stroke,'z'))
              ;

        stroke.forEach(_setTensions.bind(null, stroke,'l'));
        stroke.forEach(_setTensions.bind(null, stroke,'r'));
        return stroke;
    };

    return StrokeContour;
});

define('metapolator/project/import/contourFromContour',[
    'metapolator/errors'
  , './tools'
], function(
    errors
  , tools
) {
    
    var AssertionError = errors.Assertion
      , ImportContourError = errors.ImportContour
      , line2curve = tools.line2curve
      , getDirection = tools.getDirection
      ;

    /* Convert all lineTo to curveTo */
    function _all2CurveTo(contour) {
        var i, result = [], previousSegment, segment;

        previousSegment = contour.length - 1;
        for(i=0;i<contour.length;i++) {

            if(contour[i].length === 4)
                // [command, point, point, point]
                segment = contour[i];
            else if(contour[i].length === 2) {
                // [command, point]
                segment = line2curve (
                      // previous on-curve point
                      contour[previousSegment].slice(-1).pop()
                    , contour[i][1]
                );
            }
            else
                // This means that probably  the code that created
                // the contour argument for is faulty and must be repaired.
                throw new AssertionError('A segment is expected to '
                        + ' have 3 items at this stage, but this has '
                        + contour[i].length + ' items. '
                        + 'Segment: ' + contour[i].join(', '));
            segment.shift(); // remove the segmentType
            result.push(segment);
            previousSegment = i;
        }
        return result;
    }

    function _getMetapolatorPoint(item, i, contour) {
        var outIndex = i === contour.length-1
            ? 0
            : i+1
            ;
        return {
            'in': item[1]
          , on: item[2]
          , out: contour[outIndex][0]
          , wasLine: !!item.wasLine
        };
    }

    /**
     * This is a trimmed copy of the equivalent function in StrokeContour.
     * The purpose is to fined a fallback direction, if the contour did
     * not come with something useful
     * See the other docstring for more info.
     *
     */
    function _findNextDirection(contour, pointIndex, point, control) {
        var normalIncrement = control === 'out' ? 1 : -1
          , increment = normalIncrement
          , i = pointIndex
          , firstRound = true
          , lastRound
          , result
          ;

        while(true) {
            lastRound = i === pointIndex && !firstRound;
            result = getDirection(point, firstRound, lastRound,
                            increment, contour[i], control);
            firstRound = false;
            if(result !== false || lastRound)
                return result;

            // iterate
            if(increment === 1 && i === contour.length-1)
                i = 0;
            else if (increment === -1 && i === 0)
                i = contour.length-1;
            else
                i += increment;
        }
    }

    function _setPolarControls(point, index, contour) {
        var outVector, inVector, dir;
        outVector = point.out['-'](point.on);
        point.outLength = outVector.magnitude();
        dir = _findNextDirection(contour, index, point, 'out');
        if(dir === false)
            throw new ImportContourError('Can\'t find an outgoing direction '
                                        + 'for point at contour['+index+'].');
        point.outDir = dir;
        inVector = point.on['-'](point['in']);
        point.inLenght = inVector.magnitude();
        dir = _findNextDirection(contour, index, point, 'in');
        if(dir === false)
            throw new ImportContourError('can\'t find an incoming direction '
                                        +'for point at contour['+index+'].');
        point.inDir = dir;
        return point;
    }

    function contourFromContour(contour) {
        return _all2CurveTo(contour)
               .map(_getMetapolatorPoint)
               .map(_setPolarControls)
               ;
    }

    return contourFromContour;
});

define('metapolator/project/ImportController',[
    'metapolator/errors'
  , 'ufojs/ufoLib/glifLib/GlyphSet'
  , './import/SegmentPen'
  , './import/ImportOutlinePen'
  , './import/StrokeContour'
  , './import/contourFromContour'

  , 'metapolator/models/CPS/elements/ParameterCollection'
  , 'metapolator/models/CPS/elements/AtNamespaceCollection'
  , 'metapolator/models/CPS/elements/Rule'
  , 'metapolator/models/CPS/elements/ParameterDict'
  , 'metapolator/models/CPS/elements/Parameter'
  , 'metapolator/models/CPS/elements/ParameterName'
  , 'metapolator/models/CPS/elements/ParameterValue'
  , 'metapolator/math/Vector'

  , 'metapolator/models/CPS/parsing/parseSelectorList'
  , 'ufojs/errors'

], function(
    errors
  , GlyphSet
  , SegmentPen
  , ImportOutlinePen
  , StrokeContour
  , contourFromContour

  , ParameterCollection
  , AtNamespaceCollection
  , Rule
  , ParameterDict
  , Parameter
  , ParameterName
  , ParameterValue
  , Vector

  , parseSelectorList
  , ufojsErrors
) {
    
    /*global console:true*/
    /*jshint  sub:true*/

    var GlifLibError = ufojsErrors.GlifLib;

    function ImportController(log, project, masterName, sourceUFODir) {
        this._project = project;
        this._log = log;
        this._masterName = masterName;

        if(this._project.hasMaster(masterName))
            this._master = this._project.getMaster(masterName);
        else
            this._master = this._project.createMaster(masterName,
                                                      masterName + '.cps',
                                                      'skeleton.' + masterName);
        this._sourceUFODir = sourceUFODir;
        this._sourceGlyphSet = undefined;
    }
    var _p = ImportController.prototype;

    /**
     * NOTE: This performs synchronous IO via this._project.getGlyphSet
     */
    _p._getSourceGlyphSet = function() {
        var options;
        if(!this._sourceGlyphSet) {
            // tell us about errors instead of throwing it away
            options = {
                readErrorCallback: function( projectMaster, metadata ) {
                    this._log.warning("ImportController: Got an error loading glyph '"
                                    + metadata.glyphName + "' reason:" + metadata.message );
                    // try to continue
                    return true;
                }.bind( null, this._master )
            };
            this._sourceGlyphSet = this._project.getGlyphSet(
                        false, this._sourceUFODir, undefined, options);
        }
        return this._sourceGlyphSet;
    };

    _p['import'] = function(glyphs) {
        var missing, i=0
          , rules = []
          , cps
          , sourceGlyphSet = this._getSourceGlyphSet(false)
          ;

        if(!glyphs)
            glyphs = sourceGlyphSet.keys();
        else {
            missing = glyphs.filter(function(name) {
                        return !sourceGlyphSet.has_key(name);}, this);
            if(missing.length)
                throw new errors.Key('Some glyphs requested for import '
                                    +'are missing in the source GlyphSet: '
                                    +missing.join(', '));
        }
        console.warn('importing ...');
        for(;i<glyphs.length;i++) {
            var glyphName = glyphs[i];
            try {
                var g = this.importGlyph(glyphName);
                Array.prototype.push.apply(rules, g);
            }
            catch(error) {
                if(error instanceof GlifLibError) {
                    // we have already recorded this in the error
                    // callback function
                } else {
                    throw error;
                }
            }
        }

        this._master.glyphSet.writeContents(false);

        cps = new ParameterCollection(rules);

        // This just overrides the local CPS file
        // We might come up with some smart merging in the future, so that
        // it is possible to import changed glyphs into an existing CPS
        // files, changing only the new glyphs and keeping the old ones. But
        // that ain't gonna be easy.
        this._master.saveCPS(this._masterName + '.cps', '@import "' + this._project.cpsOutputConverterFile + '";\n@import "' + this._project.cpsGlobalFile + '";\n\n' + cps);
    };

    _p._readGlyphFromSource = function(glyphName) {
        var sourceGlyphSet = this._getSourceGlyphSet(false)
          , glyph = sourceGlyphSet.get(glyphName)
          , segmentPen = new SegmentPen()
          , pen = new ImportOutlinePen(segmentPen, true)
          ;

        glyph.drawPoints(false, pen);
        return {data:glyph, contours:segmentPen.flush()};
    };

    _p.importGlyph = function(glyphName) {
        console.warn('> importing glyph:', glyphName);
        var sourceGlyph = this._readGlyphFromSource(glyphName)
          , targetGlyph
          , contours = []
          , item
          , i=0
            // the index at which the contour will be addressable in CPS
          , parentIndex = 0
          , rules = []
          , id
          // If the identifier starts with C: (for *C*ontour)
          , contourIndicator = 'C:'
          ;
        for(;i<sourceGlyph.contours.length;i++) {
            item = sourceGlyph.contours[i];

            // component
            if(item.type == 'component' ) {
                contours.push(item);
                parentIndex += 1;
                continue;
            }

            if(!item.closed) {
                console.warn('    skipping contour '+ i +' because it is open.');
                continue;
            }

            // import as contour
            id = undefined;
            try {
                id = item.kwargs.identifier;
            }
            catch(error) {
                //TypeError: Cannot read property 'identifier' of undefined
                if(!(error instanceof TypeError))
                    throw error;
            }
            if(id && id.slice(0, contourIndicator.length) === contourIndicator) {
                Vector.prototype._cps_whitelist.inspect = 'inspect';
                console.warn('importing contour '+ i + ' as contour');
                var contourData = contourFromContour(item.commands);
                contours.push({
                      type:'contour'
                    , data: contourData
                    , kwargs: item.kwargs
                });
                rules.push(makeCPSContourRule(contourData, parentIndex));
                parentIndex += 1;
                continue;
            }

            // import as penstroke if possible
            if(item.commands.length < 5) {
                console.warn('    skipping contour '+ i +' because it has less '
                                            +'than 4 on-curve points.');
                continue;
            }
            if(item.commands.length % 2 === 0) {
                 console.warn('    skipping contour '+ i +' because count of '
                                            +'on-curve points is uneven');
                continue;
            }
            console.warn('importing contour '+ i + ' as penstroke');
             // the z points of this stroke can go directly to the skeleton glyph
            var penStrokeData = new StrokeContour(item.commands).getPenStroke();
            // this goes into the glyph/skeleton
            contours.push({
                  type:'penstroke'
                , data:penStrokeData
                , kwargs: item.kwargs
            });

            // this goes into the glyph
            // returns an atNamespaceRule(penstroke:i({parentIndex})){ points ... }
            rules.push(makeCPSPenStrokeRule(penStrokeData, parentIndex));
            parentIndex += 1;
        }

        this._master.glyphSet.writeGlyph(false, glyphName, sourceGlyph.data,
            // draw the outline to the new glif
            draw.bind(null, contours)
        );

        return [new AtNamespaceCollection(
                    'namespace'
                  , parseSelectorList.fromString('glyph#'+(glyphName.replace('.', '\\.')))
                  , rules)
                ];
    };

    function draw(contours, pen) {
        var i=0, j, segmentType, point, item, command;

        for(;i<contours.length;i++) {
            item = contours[i];
            if( item.type == 'component' ) {
                pen.addComponent( item.glyphName, item.transformation, item.kwargs );
            }
            else if(item.type == 'contour') {
                // everything is a curve, so this is easy
                pen.beginPath(item.kwargs);
                for(j=0;j<item.data.length;j++) {
                    point = item.data[j]['in'];
                    pen.addPoint(point.valueOf(), undefined, undefined, point.name);
                    point = item.data[j]['on'];
                    pen.addPoint(point.valueOf(), 'curve', undefined, point.name);
                    point = item.data[j]['out'];
                    pen.addPoint(point.valueOf(), undefined, undefined, point.name);
                }
                pen.endPath();
            }
            else { // item.type === 'penstroke'
                pen.beginPath(item.kwargs);
                // draw just the centerline
                for(j=0;j<item.data.length;j++) {
                    if(j===0)
                        // this is a non closed path
                        segmentType = 'move';
                    else {
                        segmentType = 'curve';

                        point = item.data[j-1].z.out;
                        pen.addPoint(point.valueOf(), undefined
                                     , undefined, point.name);

                        point = item.data[j].z['in'];
                        pen.addPoint(point.valueOf(), undefined
                                     , undefined, point.name);
                    }
                    // we don't have line segments on skeletons
                    //    segmentType = 'line';
                    point = item.data[j].z.on;
                    pen.addPoint(point.valueOf(), segmentType
                                 , undefined, point.name);
                }
                pen.endPath();
            }
        }
    }

    function parameterDictFromObject(obj) {
        var items = []
          , k
          , name
          , value
          ;

        for(k in obj) {
            if(obj[k] === undefined)
                continue;
            name = new ParameterName(k, []);
            value = new ParameterValue([
                ( obj[k] instanceof Vector
                    ? 'Vector ' + [obj[k].real, obj[k].imag].join(' ')
                    : obj[k] )], []);
            items.push(new Parameter(name, value));
        }

        return new ParameterDict(items);
    }
    /**
     * returns a Rule point:i({index}){ ... data ... }
     *
     * This is VERY special knowledge about the structure of CPS CompoundValues
     * It knows for example how the CompoundValues are configured, etc.
     * This should be in a package together with the configuration
     * keyword: import plugins
     *
     * For terminals inDir and outDir are imported instead of inDirIntrinsic
     * and outDirIntrinsic, because they cannot be relative to the skeleton.
     *
     * If we can't extract useful values for controls, we create a rule
     * that places the control in question directly on the on-curve point
     * "in: on;" OR "out: on;" thus overriding the general rule here,
     * because we are very specific.
     */
    function makeCPSPointRules(point, index, length) {
        var rules = []
          , left={}, center={}, right={}
          , selectorList
          , rightOnIntrinsic
          ;

        // center
        // there's not much to import for center
        selectorList = parseSelectorList.fromString('point:i('+index+') > center');
        // In cases where the general rules:
        //     inDir: (on - in):angle;
        //     outDir: (out - on):angle;
        // produce worse results
        if(point.z.inLenght === 0) {
            center.inDir = point.z.inDir;
            center['in'] = 'on';
        }
        if(point.z.outLenght === 0){
            center.outDir = point.z.outDir;
            center.out = 'on';
        }
        if(Object.keys(center).length)
            rules.push(
                new Rule(selectorList, parameterDictFromObject(center)));


        rightOnIntrinsic = point.r.on['-'](point.z.on);
        // TODO: we could import onLength and onDir in ./tools/StrokeContour?
        // TODO: in rare cases this may be 0, we could still try to create
        //       a meaningful direction. StrokeContour does alredy something
        //        similar in its _findNextDirection function.
        // Don't import these values for left because they are dependent
        // on their right side counterpart in the defaults.cps setup.
        // left.onDir is defined as the inverse of right.onDir (+ deg 180)
        // left.onLength is defined being equal to right.onLength
        right.onLength = rightOnIntrinsic.magnitude();
        right.onDir = rightOnIntrinsic.angle();

        if(index === 0) {
            // opening terminal is not relative to skeleton
            left.inDir = point.l.inDir;
            right.inDir = point.r.inDir;
        }
        else {
            left.inDirIntrinsic = point.l.inDir - point.z.inDir;
            right.inDirIntrinsic = point.r.inDir - point.z.inDir;
        }
        if(index === length-1) {
            // ending terminal is not relative to skeleton
            left.outDir = point.l.outDir;
            right.outDir = point.r.outDir;
        }
        else {
            left.outDirIntrinsic = point.l.outDir - point.z.outDir;
            right.outDirIntrinsic = point.r.outDir - point.z.outDir;
        }

        left.inTension = point.l.inTension;
        right.inTension = point.r.inTension;

        left.inLength = point.l.inLength;
        right.inLength = point.r.inLength;

        if(point.l.inLength === 0)
            left['in'] = 'on';
        if(point.r.inLength === 0)
            right['in'] = 'on';

        left.outTension = point.l.outTension;
        right.outTension = point.r.outTension;

        left.outLength = point.l.outLength;
        right.outLength = point.r.outLength;

        if(point.l.outLength === 0)
            left.out = 'on';
        if(point.r.outLength === 0)
            right.out = 'on';

        selectorList = parseSelectorList.fromString('point:i('+index+')>left');
        rules.push(
            new Rule(selectorList, parameterDictFromObject(left)));
        selectorList = parseSelectorList.fromString('point:i('+index+')>right');
        rules.push(
            new Rule(selectorList, parameterDictFromObject(right)));

        return rules;
    }

    /**
     * returns an atNamespaceRule(penstroke:i({penStrokeIndex}))
     */
    function makeCPSPenStrokeRule(penStrokeData, index) {
        var name = 'namespace'
          , selectorList = parseSelectorList.fromString('penstroke:i('+index+')')
          , i = 0
          , items = []
          ;
        for(;i<penStrokeData.length;i++)
            Array.prototype.push.apply(
                items, makeCPSPointRules(penStrokeData[i], i, penStrokeData.length));

        return new AtNamespaceCollection(name, selectorList, items);
    }

    function makeCPSContourPointRules(point, index, length) {
        var rules = []
          , dict={}
          , selectorList
          , rightOnIntrinsic
          ;
        // there's not much to import for `p` (for *p*oint)
        selectorList = parseSelectorList.fromString('p:i('+index+')');
        // In cases where the general rules:
        //     inDir: (on - in):angle;
        //     outDir: (out - on):angle;
        // produce worse results
        if(point.inLenght === 0) {
            dict.inDir = point.inDir;
            dict['in'] = 'on';
        }
        if(point.outLenght === 0) {
            dict.outDir = point.outDir;
            dict.out = 'on';
        }
        if(Object.keys(dict).length)
            rules.push(
                new Rule(selectorList, parameterDictFromObject(dict)));
        return rules;
    }

    function makeCPSContourRule(contourData, index) {
        var name = 'namespace'
          , selectorList = parseSelectorList.fromString('contour:i('+index+')')
          , i = 0
          , items = []
          ;
        for(;i<contourData.length;i++)
            Array.prototype.push.apply(
                items, makeCPSContourPointRules(contourData[i], i));


        return new AtNamespaceCollection(name, selectorList, items);
    }

    return ImportController;
});


define('metapolator/project/MetapolatorProject',[
    'metapolator/errors'
  , 'util-logging/util-logging'
  , 'logging/callbackhandler'
  , 'logging/yamlformatter'
  , 'logging/logger-patch'
  , 'ufojs/errors'
  , 'obtain/obtain'
  , 'ufojs/plistLib/main'
  , 'ufojs/plistLib/IntObject'
  , './ProjectMaster'
  , './parameters/registry'
  , './parameters/outputConverter'
  , 'metapolator/models/MOM/Univers'
  , 'metapolator/models/Controller'
  , 'metapolator/models/CPS/RuleController'
  , 'ufojs/ufoLib/glifLib/GlyphSet'
  , './ImportController'
  , './ExportController'
  , 'yaml'
], function(
    errors
  , log
  , CallbackHandler
  , YAMLFormatter
  , LoggerRelog
  , ufoErrors
  , obtain
  , plistLib
  , IntObject
  , ProjectMaster
  , parameterRegistry
  , defaultParameters
  , Univers
  , ModelController
  , RuleController
  , GlyphSet
  , ImportController
  , ExportController
  , yaml
) {
    

        // FIXME: make this available for browsers too
    // Specify formatVersion as an int, as required by
    // unifiedfontobject.org, otherwise it becomes a 'real' in the plist.
    var metainfoV3 = {
            creator: 'org.ufojs.lib'
          , formatVersion: new IntObject(3)
        }
      , metainfoV2 = {
            creator: 'org.ufojs.lib'
          , formatVersion: new IntObject(2)
        }
      , // fontforge requires a fontinfo.plist that defines unitsPerEm
        minimalFontinfo = {unitsPerEm: new IntObject(1000)}
      , ProjectError = errors.Project
      , KeyError = errors.Key
      , IONoEntryError = ufoErrors.IONoEntry
      ;

    function MetapolatorProject(io, baseDir) {
        this._io = io;
        this._data = {
            masters: {}
        };
        this._cache = {
            masters: {}
          , glyphClasses:{}
          , fontinfo: null
        };

        this.baseDir = baseDir || '.';

        Object.defineProperty(this, 'ruleController', {
            value: new RuleController(io, parameterRegistry, this.cpsDir)
        });

        this._controller = new ModelController(this.ruleController);
        this._log = new log.Logger().setLevel(log.Level.INFO);
        this._log.addHandler(new log.Handler());

        this._momCache = Object.create(null);
    }

    var _p = MetapolatorProject.prototype;
    _p.constructor = MetapolatorProject;
    Object.defineProperty(_p, 'dataDir', {
        get: function(){ return this.baseDir + '/data/com.metapolator';}
    });

    Object.defineProperty(_p, 'projectFile', {
        get: function(){ return this.dataDir + '/project.yaml';}
    });

    Object.defineProperty(_p, 'cpsDir', {
        get: function(){ return this.dataDir + '/cps';}
    });

    Object.defineProperty(_p, 'cpsOutputConverterFile', {
        get: function(){ return 'centreline-skeleton-to-symmetric-outline.cps'; }
    });

    Object.defineProperty(_p, 'cpsGlobalFile', {
        get: function(){ return 'global.cps'; }
    });

    Object.defineProperty(_p, 'layerContentsFile', {
        get: function(){ return this.baseDir+'/layercontents.plist'; }
    });

    Object.defineProperty(_p, 'groupsFileName', {
        value: 'groups.plist'
    });
    Object.defineProperty(_p, 'fontinfoFileName', {
        value: 'fontinfo.plist'
    });


    Object.defineProperty(_p, 'groupsFile', {
        get: function(){ return this.baseDir+'/' + this.groupsFileName; }
    });
    Object.defineProperty(_p, 'fontinfoFile', {
        get: function(){ return this.baseDir+'/' + this.fontinfoFileName; }
    });

    Object.defineProperty(_p, 'logFile', {
        get: function(){ return this.dataDir + '/log.yaml';}
    });

    _p.getNewGlyphSet = function(async, dirName, glyphNameFunc, UFOVersion, options) {
        return GlyphSet.factory(
                    async, this._io, dirName, glyphNameFunc, UFOVersion, options);
    };

    _p._readPlist = obtain.factory(
        {
            'path': ['ufoDir', 'fileName',
                function(ufoDir, fileName){ return [ufoDir, fileName].join('/'); }]
          , 'data': ['contents', plistLib.readPlistFromString.bind(plistLib)]
          , 'contents': ['path',
                function(path){ return this._io.readFile(false, path);}]
        }
      , {
            'contents': ['path',
                function(path){ return this._io.readFile(true, path);}]
        }
      , ['ufoDir', 'fileName']
      , function(obtain){ return obtain('data'); }
    );

    _p._readUFOFormatVersion = obtain.factory(
        {
            'metainfo': [false, 'ufoDir', new obtain.Argument('metainfo.plist'), _p._readPlist]
          , 'formatVersion': ['metainfo', function(data){return data.formatVersion;}]
        }
      , {
            'metainfo': [true, 'ufoDir', new obtain.Argument('metainfo.plist'), _p._readPlist]
        }
      , ['ufoDir']
      , function(obtain){ return obtain('formatVersion'); }
    );

    /**
     * Initialize a GlyphSet for the UFO at `ufoDir`. Read the
     * ufo format version before, to load the glyphset the right way.
     *
     * If the ufo version is 3 `layername` can be given as argument,
     * it defaults to the ufo v3 default "public.default"
     *
     * FIXME: Once ufoJS finished porting ufoLib/UFOReader, this functionality
     * will large be located there.
     */
    _p.getGlyphSet = obtain.factory(
        {
            'UFOVersion': [false, 'ufoDir', _p._readUFOFormatVersion]
          , 'dirName': ['ufoDir', 'layer', function(ufoDir, layer) {
                                    return [ufoDir, layer].join('/');}]
          , 'layer': ['UFOVersion', 'ufoDir', 'layerName',
            function(UFOVersion, ufoDir, layerName) {
                var layerContents;
                if(UFOVersion < 3)
                    return 'glyphs';
                layerContents = this._readPlist(false, ufoDir, 'layercontents.plist');
                return _getLayerDir(layerContents, layerName || 'public.default');
            }]
          , 'GlyphSet': [false, 'dirName', 'glyphNameFunc', 'UFOVersion', 'options', _p.getNewGlyphSet]
        }
      , {
            'UFOVersion': [true, 'ufoDir', _p._readUFOFormatVersion]
          , 'layer':['UFOVersion', 'ufoDir', 'layerName', '_callback', '_errback',
            function(UFOVersion, ufoDir, layerName, callback, errback) {
                if(UFOVersion < 3) {
                    setTimeout(callback.bind('glyphs'));
                    return;
                }
                this._readPlist(true, ufoDir, 'layercontents.plist')
                .then(function(layerContents) {
                    callback(_getLayerDir(layerContents, layerName || 'public.default'));
                })
                .then(undefined, errback);
            }]
          , 'GlyphSet': [true, 'dirName', 'glyphNameFunc', 'UFOVersion', 'options', _p.getNewGlyphSet]
        }
      , ['ufoDir', 'glyphNameFunc'/*optional*/, 'options'/*optional*/
                    , 'layerName'/*optional default: 'public.default'*/]
      , function(obtain) {return obtain('GlyphSet');}
    );

    _p.init = function() {
        // FIXME: all I/O is synchronous for now

        this._io.mkDir(false, this.baseDir);

        // create baseDir/metainfo.plist
        this._io.writeFile(false, this.baseDir+'/metainfo.plist'
                                , plistLib.createPlistString(metainfoV3));

        // create dir baseDir/data
        this._io.mkDir(false, this.baseDir+'/data');
        // create dir baseDir/data/com.metapolator
        this._io.mkDir(false, this.dataDir);

        // project file:
        // create this.dataDir/project.yaml => yaml({})
        this._io.writeFile(false, this.projectFile, yaml.safeDump(this._data));

        // create dir this.dataDir/cps
        this._io.mkDir(false, this.cpsDir);

        // create layercontents.plist
        this._io.writeFile(false, this.layerContentsFile,
                                        plistLib.createPlistString([]));

        // the glyphs dir must be there to make the UFO valid, but we don't
        // use it currently :-(
        // create dir baseDir/glyphs
        this._createGlyphLayer('public.default', 'glyphs');

        // create default CPS output stage
        // this is the standard wiring of cps compounds etc.
        // we include it, so it can be studied and if needed changed
        this._io.writeFile(false, [this.cpsDir, '/', this.cpsOutputConverterFile].join(''),
                                        this.getDefaultCPS().toString());

        // this can be empty, all masters will use this by default
        this._io.writeFile(false, [this.cpsDir, '/', this.cpsGlobalFile].join(''),
                            '/* all masters use this CPS file by default*/');
    };

    _p.load = function() {
        // the files created in _p.init need to exist
        // however, we try to load only
        // this.baseDir+'/data/com.metapolator/project.yaml' as an indicator
        this._log.debug('loading ' + this.projectFile);
        var dataString = this._io.readFile(false, this.projectFile)
          , fh
          ;
        this._log.debug('loaded ' + dataString);
        this._data = yaml.safeLoad(dataString);

        // Add ConsoleHandler for debugging (also replays existing entries)
        this._log.addHandler(new log.ConsoleHandler());

        // Reload any saved log entries before adding CallbackHandler for new entries
        var logText, logRecords;
        try {
            logText = this._io.readFile(false, this.logFile);
        }
        catch (error) { // Ignore file not found
            if(!(error instanceof IONoEntryError))
                throw error;
        }
        try {
            logRecords = yaml.safeLoad(logText || "");
        }
        catch(e) { // Translate YAML errors
            throw new ProjectError('Invalid log file ' + e);
        }
        if(logRecords) {
            logRecords.forEach(function (obj) {
                this._log.relog(log.LogRecord.prototype.fromObject(obj));
            }, this);
        }

        // Add CallbackHandler to log to add new entries to the log file
        fh = new CallbackHandler(this._io.appendFile.bind(this._io, true, this.logFile));
        fh.setFormatter(new YAMLFormatter());
        this._log.addHandler(fh);
    };

    /**
     * return a ParameterCollection with the default CPS wiring, as the
     * importer expects it.
     */
    _p.getDefaultCPS = function() {
        return defaultParameters;
    };

    _p.hasMaster = function(masterName) {
        return masterName in this._data.masters;
    };

    Object.defineProperty(_p, 'masters', {
        get: function(){ return Object.keys(this._data.masters); }
    });

    Object.defineProperty(_p, 'controller', {
        get: function(){ return this._controller; }
    });

    _p._createGlyphLayer = function(name, layerDirName) {
        if(layerDirName === undefined)
            layerDirName = 'glyphs.' + name;

        var layerDir = [this.baseDir,'/',layerDirName].join('');

        // read layercontents.plist
        var layercontents = plistLib.readPlistFromString(
                this._io.readFile(false, this.layerContentsFile));

        // see if there is a layer with this name
        for(var i=0;i<layercontents.length;i++)
            if(layercontents[i][0] === name)
                throw new ProjectError('A glyph layer with name "'+name
                                                +'" already exists.');

        // create new layer dir
        this._io.mkDir(false, layerDir);

        // store layer in layercontents
        layercontents.push([name, layerDirName]);
        this._io.writeFile(false, this.layerContentsFile,
                                    plistLib.createPlistString(layercontents));

        // create empty layerDir/contents.plist
        this._io.writeFile(false, layerDir + '/contents.plist',
                                        plistLib.createPlistString({}));
    };

    /**
     * Delete a glyph layer.
     *
     * FIXME: Currently, only works properly if no glyphs are defined:
     * simply removes the plist and then tries to delete the directory.
     * Also removes the glyph layer from layercontents.plist.
     *
     */
    _p._deleteGlyphLayer = function(name) {
        var layerDir = this._getLayerDir(name)
          , layerIndex;

        // Read layercontents.plist
        var layercontents = plistLib.readPlistFromString(
                this._io.readFile(false, this.layerContentsFile));

        // Find the layer with this name
        layerIndex = null;
        for(var i=0;i<layercontents.length;i++) {
            if(layercontents[i][0] === name) {
                layerIndex = i;
                break;
            }
        }
        if (layerIndex === null)
            throw new ProjectError('No such glyph layer "'+name+'".');
        layercontents.splice(layerIndex, 1);

        // Update layercontents
        this._io.writeFile(false, this.layerContentsFile,
                           plistLib.createPlistString(layercontents));

        // Remove layer dir and its contents
        this._io.rmDirRecursive(false, layerDir);
    };

    /**
     * lookup a name in a laycontents list as defined for layercontents.plist
     */
    function _getLayerDir(layercontents, name) {
        var layerDir;
        for(var i=0;i<layercontents.length;i++)
            if(layercontents[i][0] === name) {
                layerDir = layercontents[i][1];
                break;
            }
        if(!layerDir)
            throw new KeyError('Layer named "' + name + '" not found.');
        return layerDir;
    }
    /**
     * Returns the path needed to instantiate a GlyphSet for this project
     */
    _p._getLayerDir = function(name) {
        // read layercontents.plist
        var layercontents = plistLib.readPlistFromString(
                this._io.readFile(false, this.layerContentsFile))
          , layerDir = [this.baseDir, _getLayerDir(layercontents, name)].join('/')
          ;
        if(!this._io.pathExists(false, layerDir + '/'))
            throw new KeyError('Layer directory "' + layerDir
                                + '" does not exist, but is mentioned in '
                                +'layercontents.plist.');
        return layerDir;
    };

    /**
     * Create a master entry for this masterName, with the given cpsFile
     * and skeleton.
     *
     * Also creates an entry in layercontents.plist: `skeleton`,
     * glyphs.`skeleton`
     *
     * If any element does not exist, it is assumed the caller will create
     * it before attempting to use the font.
     *
     */
    _p.createMaster = function(masterName, cpsFile, skeleton) {
        // get the name for this master from the CLI
        if(this.hasMaster(masterName))
            throw new ProjectError('Master "'+masterName+'" already exists.');
        var master = {cpsFile: cpsFile};
        this._data.masters[masterName] = master;

        // create a skeleton layer for this master
        master.skeleton = skeleton;
        if (skeleton === 'skeleton.' + masterName)
            this._createGlyphLayer(master.skeleton);

        this._io.writeFile(false, this.projectFile, yaml.safeDump(this._data));

        return this.getMaster(masterName);
    };

    /**
     * delete a master entry for this masterName
     *
     * and remove entry in layercontents.plist:
     * skeleton.masterName, glyphs.skeleton.masterName
     *
     */
    _p.deleteMaster = function(masterName) {
        // get the name for this master from the cli
        if(!this.hasMaster(masterName))
            throw new ProjectError('No such Master "'+masterName+'".');
        var master = this._data.masters[masterName];

        // Remove CPS file
        this.getMaster(masterName).deleteCPS(masterName + '.cps');

        // Remove skeleton layer for this master
        if (master.skeleton === 'skeleton.' + masterName)
            this._deleteGlyphLayer(master.skeleton);

        // Remove project entry
        delete this._data.masters[masterName];

        // Update project file
        this._io.writeFile(false, this.projectFile, yaml.safeDump(this._data));

        // FIXME: Check we successfully deleted it
        return true;
    };

    _p._getMaster = function(masterName) {
        var master =  this._data.masters[masterName]
          , glyphSetDir = this._getLayerDir(master.skeleton)
          ;
        return new ProjectMaster(this._io, this, masterName, glyphSetDir, master.cpsFile);
    };

    _p.getMaster = function(masterName) {
        if(!this.hasMaster(masterName))
            throw new KeyError('Master "'+masterName+'" not in project');
        if(!this._cache.masters[masterName]) {
            this._cache.masters[masterName] = this._getMaster(masterName);
        }
        return this._cache.masters[masterName];
    };

    _p.open = function(masterName) {
        if(!this._controller.hasMaster(masterName)) {
            // this._log.warning('open', masterName)
            var master = this.getMaster(masterName)
            , skeleton = this._data.masters[masterName].skeleton
            , sourceMOM
            , momMaster
            ;
            // FIXME: Bad implementation, we need much better management
            // for masters etc. ALSO, if skeleton is the same, we should
            // rather try to have a single MOM object for this, maybe with
            // some kind of proxying to enable different "master.id"s
            sourceMOM = this._momCache[skeleton];
            if(!sourceMOM)
                sourceMOM = this._momCache[skeleton] = master.loadMOM();
            momMaster = sourceMOM.clone();

            momMaster.id = masterName;
            this._controller.addMaster(momMaster, master._cpsFile);
        }
        return this._controller;
    };

    _p.import = function(masterName, sourceUFODir, glyphs) {
        var importer = new ImportController( this._log, this,
                                             masterName, sourceUFODir);
        importer.import(glyphs);

        this._importGroupsFile(sourceUFODir, false);
        this._importFontInfoFile(sourceUFODir, false);
    };

    /**
     * If there is no 'targetFile' in the project but the import
     * has one, we do the import.
     *
     * If there is a 'targetFile' in the project and overide is true
     * we overide by doing the import.
     * Otherwise, we skip importing the file.
     *
     * This rule may get changed in the future, but having the first
     * possible file also imported into the project is better than not
     * having it to happen.
     *
     * Also, ufoJS can't validate this file at the moment
     * however, we can try to parse it with plistlib and see if it works.
     */
    _p._importPListFile = function(sourceUFODir, override, filename, targetFile ) {
        var sourceFile = [sourceUFODir, filename].join('/')
          , targetExists
          , content
          ;

        targetExists = this._io.pathExists(false, targetFile);
        if(targetExists && !override) {
            this._log.warning(filename + ' exists in the project, skipping import.');
            return;
        }

        if(!this._io.pathExists(false, sourceFile)) {
            this._log.warning('No ' + filename + ' found for import.');
            return;
        }

        this._log.warning('Importing '+filename+' into the project.');
        if(targetExists)
            this._log.warning('The existing '+filename+' will be overridden.');

        content = this._io.readFile(false, sourceFile);
        try {
            // Just a rough look if we can parse it, we are not interested
            // in the result of parsing at the moment.
            // TODO: validation (this is a task for ufoJS)
            plistLib.readPlistFromString(content);
        }
        catch(error) {
            this._log.warning('Import of '+filename+' failed when trying to '
                                    +'parse it as a plist:\n'+ error);
        }
        this._io.writeFile(false, targetFile, content);
        this._log.warning('Import of '+filename+' OK.\n');
    };


    /**
     * Only imports groups.plist if we don't have one already and
     * !override.
     *
     * @see _importPListFile
     */
    _p._importGroupsFile = function(sourceUFODir, override) {
        this._importPListFile( sourceUFODir, override,
                               this.groupsFileName, this.groupsFile );
    };

    /**
     * Only imports fontinfo.plist if we don't have one already and
     * !override.
     *
     * @see _importPListFile
     */
    _p._importFontInfoFile = function(sourceUFODir, override) {
        this._importPListFile( sourceUFODir, override,
                               this.fontinfoFileName, this.fontinfoFile );
    };

    _p.exportInstance = function(masterName, instanceName, precision) {
        // returns a models/Controller
        var model = this.open(masterName)
          , master = model.query('master#' + masterName)
          , dirName = instanceName
          , glyphSet
          , exportController
          ;

        // create a bare ufoV2 directory
        this._io.mkDir(false, dirName);

        // create dirName/metainfo.plist
        this._io.writeFile(false, dirName+'/metainfo.plist'
                                , plistLib.createPlistString(metainfoV2));

        // fontforge requires a fontinfo.plist that defines unitsPerEm
        this._io.writeFile(false, dirName+'/fontinfo.plist'
                                , plistLib.createPlistString(minimalFontinfo));

        this._io.mkDir(false, dirName+'/glyphs');
        this._io.writeFile(false, dirName+'/glyphs/contents.plist', plistLib.createPlistString({}));

        glyphSet = this.getNewGlyphSet(
                                false, dirName +'/glyphs', undefined, 2);

        exportController = new ExportController(master, model, glyphSet, precision);
        exportController.export();
    };

    _p._getGlyphClassesReverseLookup = function() {
        var result = {}
          , data
          , groups
          , group, i, glyphName
          ;
        try {
            data = this._io.readFile(false,  this.groupsFile);
        }
        catch(error) {
            if(error instanceof IONoEntryError) {
                // this is legal, we simply have no groups file
                this._log.warning('No groups.plist file found, thus no glyph classes are defined.');
                return result;
            }
            throw error;
        }
        groups = plistLib.readPlistFromString(data);

        for(group in groups) {
            for(i=0;i<groups[group].length;i++) {
                glyphName = groups[group][i];
                if(!(glyphName in result))
                    result[glyphName] = [];
                result[glyphName].push(group);
            }
        }
        return result;
    };

    _p.getGlyphClassesReverseLookup = function() {
        if(!this._cache.glyphClasses.reverseLookup)
            this._cache.glyphClasses.reverseLookup = this._getGlyphClassesReverseLookup();

        return this._cache.glyphClasses.reverseLookup;
    };

    _p._getFontinfo = function() {
        var data;
        try {
            data = this._io.readFile(false,  this.fontinfoFile);
        }
        catch(error) {
            if(error instanceof IONoEntryError) {
                // this is legal, we have no fontinfo
                this._log.warning('No fontinfo found, fallback to minimal (builtin) fontinfo.');
                return minimalFontinfo;
            }
            throw error;
        }
        return plistLib.readPlistFromString(data);
    };

    _p.getFontinfo = function() {
        var fontinfo = this._cache.fontinfo;
        if(!fontinfo)
            this._cache.fontinfo = fontinfo = this._getFontinfo();
        return fontinfo;
    };

    return MetapolatorProject;
});

/**
 * This describes the API that is expected of all I/O modules.
 * 
 * It makes heavy use of obtainJS.
 * 
 * You can and should use this module as prototype for your implementation
 * (if there is inheritance). We might use that as a base for unit-testing,
 * however ufoJS will use ducktyping and just expect your implementation
 * to work.
 * 
 * All methods raise errors.NotImplemented
 * 
 * This API is by no means fixed! It's still in exploring state, AFAIK
 * there is no good cross plattform solution for I/O. So we move slow and
 * see what we need to do.
 */
define('ufojs/tools/io/_base',[
    'ufojs/errors'
  , 'obtain/obtain'

], function(
    errors
  , obtain
) {
    
    
    var NotImplementedError = errors.NotImplemented
      , Parent = Object
      ;

    function io() {
        /*jshint validthis:true */
        Parent.call(this);
    }

    var _p = io.prototype = Object.create(Parent.prototype);

    /**
     * raises IONoEntry when path is not found.
     */
    _p.readFile = obtain.factory(
        {
            readFile:['path', function(path) {
                throw new NotImplementedError('readFile');
            }]
        }
      , {/* no need for async here */}
      , ['path']
      , function(obtain){ return obtain('readFile'); }
    );
    
    /**
     * raises IONoEntry when points to a non-existent directory
     */
    _p.writeFile = obtain.factory(
        {
            writeFile:['path', 'data', function(path, data) {
                throw new NotImplementedError('writeFile');
            }]
        }
      , {/* no need for async here */}
      , ['path', 'data']
      , function(obtain){ return obtain('writeFile'); }
    );
    
    /**
     * raises IONoEntry when points to a non-existent directory
     */
    _p.appendFile = obtain.factory(
        {
            appendFile:['path', 'data', function(path, data) {
                throw new NotImplementedError('appendFile');
            }]
        }
      , {/* no need for async here */}
      , ['path', 'data']
      , function(obtain){ return obtain('appendFile'); }
    );

    /**
     * raises IONoEntry when path is not found.
     */
    _p.unlink = obtain.factory(
        {
            unlink:['filename', function(filename) {
                throw new NotImplementedError('unlink');
            }]
        }
      , {/* no need for async here */}
      , ['filename']
      , function(obtain){ return obtain('unlink'); }
    );
    
    _p.readBytes = obtain.factory(
        {
            readBytes:['path', 'bytes', function(path, bytes) {
                throw new NotImplementedError('readBytes');
            }]
        }
      , {/* no need for async here */}
      , ['path', 'bytes']
      , function(obtain){ return obtain('readBytes'); }
    );
    
    /**
     * raises IONoEntry when path is not found.
     */
    _p.stat = obtain.factory(
        {
            stat:['path', function(path) {
                throw new NotImplementedError('stat');
            }]
        }
      , {/* no need for async here */}
      , ['path']
      , function(obtain){ return obtain('stat'); }
    );

    /**
     * Don't use this method to check whether something exists before doing
     * an operation on it, that only creates a race condition.
     */
    _p.pathExists = obtain.factory(
        {
            pathExists:['path', function(path) {
                throw new NotImplementedError('pathExists');
            }]
        }
      , {/* no need for async here */}
      , ['path']
      , function(obtain){ return obtain('pathExists'); }
    );
    
    /**
     * raises IONoEntry when path is not found.
     */
    _p.getMtime = obtain.factory(
        {
            getMtime:['path', function(path) {
                throw new NotImplementedError('getMtime');
            }]
        }
      , {/* no need for async here */}
      , ['path']
      , function(obtain){ return obtain('getMtime'); }
    );
    
    /**
     * Returns a list of file-names and directory-names.
     * Directory-names must end with a slash, while file-names must not.
     *
     * Raises IOError if dir doesn't exist
     */
    _p.readDir = obtain.factory(
        {
            readDir:['path', function(path) {
                throw new NotImplementedError('readDir');
            }]
        }
      , {/* no need for async here */}
      , ['path']
      , function(obtain){ return obtain('readDir'); }
    );

    /**
     * raises IOError if dir can't be created, or already exists
     */
    _p.mkDir = obtain.factory(
        {
            mkDir:['path', function(path) {
                throw new NotImplementedError('mkDir');
            }]
        }
      , {/* no need for async here */}
      , ['path']
      , function(obtain){ return obtain('mkDir'); }
    );

    /**
     * raises IOError if dir can't be created.
     *
     * Note that you can't rely on the directory actually existing after a
     * successful call: it may have been removed by the time you try to use
     * it.
     */
    _p.ensureDir = obtain.factory(
        {
            ensureDir:['path', function(path) {
                throw new NotImplementedError('ensureDir');
            }]
        }
      , {/* no need for async here */}
      , ['path']
      , function(obtain){ return obtain('ensureDir'); }
    );

    /**
     * raises IOError if dir can't be deleted
     */
    _p.rmDir = obtain.factory(
        {
            rmDir:['path', function(path) {
                throw new NotImplementedError('rmDir');
            }]
        }
      , {/* no need for async here */}
      , ['path']
      , function(obtain){ return obtain('rmDir'); }
    );

    /**
     * Implemented in terms of other io methods
     */
    _p.rmDirRecursive = obtain.factory(
        {
            rmDirRecursive:['dir', function(dir) {
                var objs = this.readDir(false, dir);
                for(var i = 0; i < objs.length; i++) {
                    var obj = dir + '/' + objs[i]; // path.join is node-specific
                    (this.stat(false, obj).isDirectory() ? this.rmDirRecursive : this.unlink)(false, obj);
                }
                this.rmDir(false, dir);
            }]
        }
      // For an async implementation, try starting here:
      // https://gist.github.com/yoavniran/adbbe12ddf7978e070c0
      , {/* no need for async here */}
      , ['dir']
      , function(obtain){ return obtain('rmDirRecursive'); }
    );

    /**
     * when name ends with a slash it is a directory name
     */
    function _isDirName(name) {
        return name.slice(-1) === '/';
    }

    _p.copyRecursive = obtain.factory(
        {
            names: ['sourcePath', function(path) {
                return this.readDir(false, path);
            }]
          , copyDir: ['names', 'targetIO', 'targetPath', 'sourcePath',
            function(names, targetIO, targetPath, sourcePath) {
                var i
                  , name
                  , fullTargetPath
                  , fullSourcePath
                  , data
                  ;
                for(i=0;i<names.length;i++) {
                    name = names[i];
                    fullTargetPath = [targetPath, name].join('/');
                    fullSourcePath = [sourcePath, name].join('/');
                    // FIXME: alternatively readFile(); should fail with
                    // IOIsDir if we don't use trailing slashes for directory
                    // names in readDir
                    if(_isDirName(name)) {
                        targetIO.mkDir(false, fullTargetPath);
                        this.copyRecursive(false, fullSourcePath.slice(0, -1)
                                           , targetIO, fullTargetPath.slice(0, -1));
                    }
                    else {
                        data = this.readFile(false, fullSourcePath);
                        targetIO.writeFile(false, fullTargetPath, data);
                    }
                }
                return true;
            }]
        }
      , {
            names: ['sourcePath', function(path) {
                return this.readDir(true, path);
            }]
          , copyDir: ['names', 'targetIO', 'targetPath', 'sourcePath' , '_callback',
            function(names, targetIO, targetPath, sourcePath , callback) {
                var i
                  , name
                  , loaded = 0
                  , fullTargetPath
                  , fullSourcePath
                  , failed = false
                  , promise
                  ;
                function finalize() {
                    if(failed) return;
                    loaded++;
                    if(loaded === names.length)
                        callback(null, true);
                }
                function fail(error) {
                    failed = true;
                    callback(error, null);
                }
                for(i=0;i<names.length;i++) {
                    name = names[i];
                    fullTargetPath = [targetPath, name].join('/');
                    fullSourcePath = [sourcePath, name].join('/');
                    if(_isDirName(name))
                        promise = targetIO.mkDir(true, fullTargetPath)
                        .then(this.copyRecursive.bind(this, true
                            , fullSourcePath.slice(0, -1)
                            , targetIO, fullTargetPath.slice(0, -1)));
                    else
                        promise = this.readFile(true, fullSourcePath)
                        .then(targetIO.writeFile.bind(targetIO, true
                                , fullTargetPath /*data is inserted by the promise*/));
                    promise.then(finalize, fail);
                }
            }]
        }
      , ['sourcePath', 'targetIO', 'targetPath']
      , function(obtain){return obtain('copyDir');}
    );

    return io;
});

/**
 * This is a REST implementation of io/_base.
 */
define('ufojs/tools/io/staticBrowserREST',[
    'ufojs/errors'
  , 'obtain/obtain'
  , './_base'
], function(
    errors
  , obtain
  , Parent
) {
    
    /*global XMLHttpRequest: true*/
    /*global ArrayBuffer: true*/
    /*global Uint8Array: true*/
    
    var IOError = errors.IO
      , IONoEntry = errors.IONoEntry
      , IOEntryExists = errors.IOEntryExists
      ;

    function Io() {
        Parent.call(this);
    }

    var _p = Io.prototype = Object.create(Parent.prototype);


    // Utility functions to build the file methods
       
    var _errorMessageFromRequest = function(request) {
        return ['Status', request.status, request.statusText].join(' ');
    };

    // Don't use this method for non-error statuses!
    var _errorFromRequest = function(request) {
        var message = _errorMessageFromRequest(request);
        var err;
        if(request.status === 404)
            err = new IONoEntry(message);
        else
            err = new IOError(message);
        err.request = request;
        return err;
    };
    
    var _path2uri = function(path) {
        return path.split('/').map(encodeURIComponent).join('/');
    };

    // We signal a directory to the REST endpoint by adding a / suffix
    var _dirify = function (f) {
        function decorate (path){return path + (path.slice(-1) !== '/' ? '/' : '');}
        return function (async, path /*, data? ... */) {
            var args = Array.prototype.slice.call(arguments);
            // decorate path
            args[1] = decorate(args[1]);
            return f.apply(this, args);
        };
    };

    // Perform a synchronous or asynchronous request
    // FIXME: once ES6 arrives, use separate resolve/reject handlers
    // instead of resultFilter
    var _obtainRequestFactory = function (method, responseType, okStatus
                                    , resultFilter, resultFilterArgs) {
        var dataArg = (method in {'PUT': true, 'POST': true}) ? 'data': undefined
          , api = ['path']
          ;
        resultFilter = resultFilter || function (err, request) { return [err, !!err]; };
        okStatus = okStatus || {200: true};
        if(dataArg)
            api.push(dataArg);
        resultFilterArgs = resultFilterArgs || [];
        Array.prototype.push.apply(api, resultFilterArgs);

        // return the send request (with response available)
        // do it async if callback is present, otherwise return directly
        function doRequest(path, data, callback) {
            var request = new XMLHttpRequest();
            request.open(method, _path2uri(path), !!callback);
            if(callback) {
                // Firefox: Use of XMLHttpRequest's responseType attribute
                // is no longer supported in the synchronous mode in window
                // context
                request.responseType = responseType;
                request.onreadystatechange = function (aEvt) {
                    if (request.readyState != 4 /*DONE*/)
                        return;
                    callback(null, request);
                };
            }
            else {
                // because setting response type is not possible in sync mode
                // we have to add a workaround by hand:
                if(responseType === 'arraybuffer')
                    // so there is no conversion by the browser
                    request.overrideMimeType('text/plain; charset=x-user-defined');
            }
            request.send(data);
            if(!callback)
                return request;
        }

        function job(obtain/*, [api ...] */) {
            var request = obtain('request')
                , error
                , result
                , callFilterArgs
                ;
            if(!(request.status in okStatus))
                error = _errorFromRequest(request);
            callFilterArgs = [error, request];
            Array.prototype.push.apply(callFilterArgs,
                // extract the resultFilterArgs from this method's arguments
                Array.prototype.slice.call(arguments, -resultFilterArgs.length));
            result = resultFilter.apply(null, callFilterArgs);
            if(result[0])
                throw result[0];
            return result[1];
        }

        return obtain.factory(
            {request: ['path', dataArg, doRequest]}
          , {request: ['path', dataArg, '_callback', doRequest]}
          , api
          , job
        );
    };

    // The file methods
    _p.readFile = _obtainRequestFactory('GET', undefined, undefined, function(error, request) {
        var result = !error ? request.responseText : undefined;
        return [error, result];
    });

    _p.writeFile = _obtainRequestFactory('PUT', undefined, {200: true, 204: true});

    // We don't read the LOCATION headers of the response, as the expected
    // behavior of the server is to create or to append to the effective
    // request URI.
    _p.appendFile = _obtainRequestFactory('POST', undefined, undefined);

    _p.unlink = _obtainRequestFactory('DELETE', undefined, {200: true, 204: true});

    // takes as a seccond argument "bytes" which is the amount of bytes to read!
    _p.readBytes = _obtainRequestFactory('GET', 'arraybuffer', undefined, function (error, request, bytes) {
        var result, chunk, rawChunk;
        if(error){}// pass
        // synchronous requests can't set request.responseType = 'arraybuffer'
        else if(request.response instanceof ArrayBuffer)
            chunk = new Uint8Array(request.response, 0, bytes);
        else {
            rawChunk = request.response.slice(0, bytes),
            chunk = new Uint8Array(bytes);
            // throw away high-order bytes (F7)
            for(var i=0; i<rawChunk.length; i++)
                chunk[i] = rawChunk.charCodeAt(i);
        }
        if(!error)
            result = String.fromCharCode.apply(null, chunk);
        return [error, result];
    }, ['bytes']);

    _p.fileExists = _obtainRequestFactory('HEAD', undefined, undefined, function (error, request) {
        return [(error instanceof IONoEntry) ? null : error, !(error instanceof IONoEntry)];
    });
    _p.dirExists = _dirify(_p.fileExists);
    _p.pathExists = _p.fileExists; // DEPRECATED: use dirExists or fileExists

    _p.getMtime = _obtainRequestFactory('HEAD', undefined, undefined, function (error, request) {
        var result = !error ? new Date(request.getResponseHeader('Last-Modified')) : undefined;
        return [error, result];
    });

    _p.readDir = _dirify(_obtainRequestFactory('GET', undefined, undefined, function (error, request) {
        var result = !error ? request.responseText.split('\n').filter(function(line){return !!line;}) : undefined;
        return [error, result];
    }));

    _p.mkDir = _dirify(_obtainRequestFactory('PUT', undefined, {200: true, 201: true, 204: true}, function (error, result) {
        if (result.status == 405)
            error = new IOEntryExists(_errorMessageFromRequest(result));
        return [error, !!error];
    }));

    _p.ensureDir = _dirify(_obtainRequestFactory('PUT', undefined, {200: true, 201: true, 204: true, 405: true}));

    _p.rmDir = _dirify(_p.unlink);

    return new Io(); // Single instance of static type
});

(function (root, factory) {
  if (typeof define === 'function' && define.amd) {
    // AMD. Register as an anonymous module.
    define('EventEmitter',[], function () {
      return (root.returnExportsGlobal = factory());
    });
  } else if (typeof exports === 'object') {
    // Node. Does not work with strict CommonJS, but
    // only CommonJS-like enviroments that support module.exports,
    // like Node.
    module.exports = factory();
  } else {
    root['EventEmitter'] = factory();
  }
}(this, function () {

/*!
 * event-emitter.js
 * 
 * Copyright (c) 2014
 */
var eventEmitter;
eventEmitter = function () {
  /* -----------------------------------------------------------------------------
   * scope
   * ---------------------------------------------------------------------------*/
  var root = this;
  /* -----------------------------------------------------------------------------
   * EventEmitter
   * ---------------------------------------------------------------------------*/
  /**
   * Lightweight EventEmitter Class.
   *
   * @example
   * var emitter = new EventEmitter(settings);
   *
   * @public
   * @constructor
   */
  var EventEmitter = function () {
    this.events = {};
  };
  /**
   * Add event listener and handler to emitter isntance.
   *
   * @example
   * emitter.on('event', this.doSomething, this);
   *
   * @public
   *
   * @param {string} name - Name of event to listen for.
   * @param {function} handler - Function to call when event is triggered.
   * @param {object} context - Context in which to execute handler. 
   *
   * @returns emitter instance (allows chaining).
   */
  EventEmitter.prototype.on = function (name, handler, context) {
    (this.events[name] = this.events[name] || []).unshift({
      fn: handler,
      context: context || root
    });
    return this;
  };
  /**
   * Remove event lister from instance. If no arguments are passed,
   * all events will be remove from the instance. If only name is
   * passed, all handlers will be remove from the specified event.
   * If name and handler are passed, only the handler will be
   * removed from the specified event.
   *
   * @example
   * emitter.off('event');
   * // removes all handlers from `event`
   *
   * @public
   *
   * @param {string} name - Name of event to remove listener from.
   * @param {function} handler - Function handler to remove from event.
   *
   * @returns emitter instance (allows chaining).
   */
  EventEmitter.prototype.off = function (name, handler) {
    // Remove all events
    if (!name) {
      this.events = {};
    } else if (!handler) {
      delete this.events[name];
    } else {
      this._loopSubscribers(name, function (subscribers, i) {
        if (subscribers[i] === handler) {
          subscribers.splice(i, 1);
        }
      });
    }
    return this;
  };
  /**
   * Calls handler for all event subscribers.
   *
   * @example
   * emitter.trigger('event');
   * // removes all handlers from `event`
   *
   * @public
   *
   * @param {string} name - Name of event to remove listener from.
   *
   * @returns emitter instance (allows chaining).
   */
  EventEmitter.prototype.trigger = function (name) {
    var args = Array.prototype.slice.call(arguments, 1);
    this._loopSubscribers(name, function (subscribers, i) {
      var handler = subscribers[i];
      handler.fn.apply(handler.context, args);
    });
    return this;
  };
  /**
   * Helper method to call specified fn for each event
   * subscriber.
   *
   * @private
   *
   * @param {string} name - Name of event to remove listener from.
   * @param {function} fn - Name of event to remove listener from.
   */
  EventEmitter.prototype._loopSubscribers = function (name, fn) {
    var subscribers = this.events[name] || [], l = subscribers.length;
    while (l--) {
      fn(subscribers, l);
    }
  };
  /* -----------------------------------------------------------------------------
   * export
   * ---------------------------------------------------------------------------*/
  return EventEmitter;
}();

return eventEmitter;


}));
define('metapolator/io/InMemory',[
    'ufojs/errors'
  , 'ufojs/tools/io/_base'
  , 'obtain/obtain'
  , 'path'
  , 'EventEmitter'
], function(
    errors
  , Parent
  , obtain
  , path
  , EventEmitter
) {
    

    /*global process: true*/
    /*global setTimeout: true*/

    var NotImplementedError = errors.NotImplemented
      , IOError = errors.IO
      , IONotDirError = errors.IONotDir // node error: ENOTDIR
      , IOIsDirError = errors.IOIsDir // node error: EISDIR
      , IONoEntryError = errors.IONoEntry // node error: ENOENT
      , IOEntryExistsError = errors.IOEntryExists // node error: EEXIST
      , IONotEmptyError = errors.IONotEmpty // ENOTEMPTY
      , assert = errors.assert
      , Argument = obtain.Argument
      ;
    /*** lower level ***/

    var next = (typeof process !== 'undefined' && typeof process.nextTick === 'function')
            ?   process.nextTick.bind(process)
            :   function(cb){ setTimeout(cb, 0); }
            ;

    function Path(pathStr) {
        var _path;
        this.normalPath = path.normalize(pathStr);
        this.rawPath = pathStr;
        if(this.normalPath[0] === '/')
            this.normalPath = this.normalPath.slice(1);

        if(this.normalPath.slice(-1) === '/')
            this.normalPath = this.normalPath.slice(0,-1);

        this.basename = path.basename(this.normalPath);

        // if(this.basename = '' && this.normalPath '')
        _path = (this.normalPath !== "")
                    ? path.dirname(this.normalPath).split('/')
                    : []
                    ;
        if(this.basename !== '')
            _path.push(this.basename);

        if(_path[0] === '.')
            _path.shift();
        if(_path[0] === '..')
            throw new TypeError('Path "' + this.normalPath +'" is above root.');
        if(_path.length === 1 && _path[0] === 1)
            _path = [];
        Object.defineProperty(this, 'path'
                        , {get: Array.prototype.slice.bind(_path)});
        Object.defineProperty(this, 'directory'
                        , {get: Array.prototype.slice.bind(_path, 0, -1)});
        Object.seal(this);
    }
    Path.factory = function(pathString){ return new Path(pathString); };

    function Node (mtime) {
        this.modified(undefined, mtime);
    }
    Node.prototype = Object.create(null);

    Node.prototype.modified = function(event, mtime) {
        this.mtime = mtime || new Date();
        this._parent = undefined;
    };
    Node.prototype.setParent = function(parent) {
        assert(!this._parent, 'Node has a parent.');
        assert(parent instanceof Directory, '"parent" must be a Directory');
        assert(parent.isChild(this), 'This is not child of "parent".');
        this._parent = parent;
    };
    Node.prototype.unsetParent = function() {
        if(!this._parent) return;
        assert(!this._parent.isChild(this), 'This is still a child of "parent".');
        this._parent = undefined;
    };
    Node.prototype.hasParent = function() {
        return !!this._parent;
    };

    function File(content, mtime) {
        Node.call(this, mtime);
        this._content = content || "";
    }
    File.prototype = Object.create(Node.prototype);

    Object.defineProperty(File.prototype, 'content', {
        set: function(content) {
            this._content = content;
            this.modified();
        }
      , get: function() {
            return this._content;
        }
    });

    function Directory(mtime) {
        Node.call(this, mtime);
        this._content = Object.create(null);
        this._index = new Map();
    }
    Directory.prototype = Object.create(Node.prototype);

    Directory.prototype.lookup = function (/* names */) {
        var names = Array.prototype.slice.call(arguments, 1)
          , name = arguments[0]
          , item
          , relatives = {'.': this, '..': this._parent}
          ;
        if(arguments.length === 0)
            return this;

        if(typeof name !== 'string' || name === '')
            throw new TypeError('A name must be a none empty string, '
                                                +'but it is: "'+name+'"');

        if(relatives.hasOwnProperty(name))
            item = relatives[name];
        else if(name in this._content)
            item = this._content[name];
        // If relatives this._parent is not set, item is also undefined.
        // Thus, this MUST NOT be an `else` clause.
        if(!item)
            throw new IONoEntryError(name);

        if(item instanceof Directory)
            return item.lookup.apply(item, names);

        if (names.length)
            throw new IONotDirError(name);

        return item;
    };

    Directory.prototype.getItem = function(type, names) {
        var item = this.lookup.apply(this, names);
        if(type === Directory && !(item instanceof Directory))
            throw new IONotDirError('"' +names.join('/') + '" is not a directory');
        else if(type === File && (item instanceof Directory))
            throw new IOIsDirError('"' +names.join('/') + '" is not a file');
        else if(type && !(item instanceof type))
            throw new IOError('"' +names.join('/') + '" is not a type of: ' + type);
        return item;
    };

    Directory.prototype.isChild = function(item) {
        return this._index.has(item);
    };

    Directory.prototype.setItem = function(name, item) {
        var target;
        if(!(item instanceof Node))
            throw new TypeError('"item" must be an Node');

        target = this._content[name];
        if(target instanceof Directory){
            if(item instanceof File)
                throw new IOIsDirError('"'+name+'" is a directory');
            throw new IOEntryExistsError('directory "'+name+'" exists');
        }
        else if (target instanceof File && item instanceof Directory)
            throw new IOEntryExistsError('file "'+name+'" exists');
        else if(item.hasParent())
            throw new IOError('item "'+name+'" has a parent already');
        else if(item === this)
            throw new IOError('item is this directory');

        this._content[name] = item;
        this._index.set(item, name);
        item.setParent(this);
        this.modified();
    };

    Directory.prototype.isEmpty = function() {
        // this._index.size is not yet supported in in Node v0.10.25 with --harmony
        for(var k in this._content) return false;
        return true;
    };

    Directory.prototype.removeItem = function(type, name) {
        var item = this.getItem(type, [name]);
        if(item instanceof Directory && !item.isEmpty())
            throw new IONotEmptyError(' "'+ name +'" directory is not empty');

        if(!this.isChild(item))
            throw new IOError(' "'+ name +'" is not a child.');
        delete this._content[name];
        this._index['delete'](item);
        item.unsetParent(this);
        this.modified();
    };

    Object.defineProperty(Directory.prototype, 'entries', {
        get: function() {
            var k, results = [];
             for(k in this._content)
                 results.push(this._content[k] instanceof Directory ? k+'/' : k);
            return results;
        }
    });

    /*** higher level ***/
    function InMemory() {
        Parent.call(this);
        this._root = new Directory();
        this._events = new EventEmitter();
    }

    var _p = InMemory.prototype = Object.create(Parent.prototype);

    _p.on = function() {
        this._events.on.apply(this._events, arguments);
    };
    _p.off = function() {
        this._events.off.apply(this._events, arguments);
    };

    _p._emit = function(name, data /* , more, data, ... */) {
        // don't do this synchronously. So anyone can finish their current business
        var args = [this._events], func;
        Array.prototype.push.apply(args, arguments);
        func = Function.prototype.bind.apply(this._events.trigger, args);
        next(func);
    };

    _p._trigger = function(name, path) {
        this._emit(name, path);
        this._emit('all', Object.freeze({event: name, path: path}));
    };

    _p._getItem = function(path, type, property) {
        var item = this._root.getItem(type || Node, path.path);
        return (property === undefined ? item : item[property]);
    };

    _p._writeFile = function(path, content, append) {
        var dir = this._root.getItem(Directory, path.directory)
          , file;
        try {
            file = dir.getItem(File, [path.basename]);
            if(append)
                file.content += content;
            else
                file.content = content;
            this._trigger('change', path.normalPath);
        }
        catch(error) {
            if(!(error instanceof IONoEntryError))
                throw error;
            file = new File(content);
            dir.setItem(path.basename, new File(content));
            this._trigger('add', path.normalPath);
        }
    };

    _p._delete = function(path, type) {
        var dir = this._root.getItem(Directory, path.directory);
        dir.removeItem(type, path.basename);
        this._trigger('unlink' + (type === Directory ? 'Dir' : ''), path.normalPath);
    };

    _p._pathExists = function(path) {
        try {
            return !!this._getItem(path);
        }
        catch(error) {
            if(!(error instanceof IONoEntryError))
                throw error;
        }
        return false;
    };
    _p._mkDir = function(path) {
        var dir = this._root.getItem(Directory, path.directory);
        dir.setItem(path.basename, new Directory());
        this._trigger('addDir', path.normalPath);
    };

    function _obtainRequestFactory(extraAPI, request) {
        var api = ['pathString'];
        if(extraAPI)
            Array.prototype.push.apply(api,
                        extraAPI instanceof Array ? extraAPI : [extraAPI]);
        return obtain.factory(
            {
                path: ['pathString', Path.factory]
              , request: request
            }
          , {}
          , api
          , function(obtain){ return obtain('request'); }
        );
    }

    _p.readFile = _obtainRequestFactory(undefined, ['path', File, new Argument('content'), _p._getItem]);
    _p.getMtime = _obtainRequestFactory(undefined, ['path', undefined, new Argument('mtime'), _p._getItem]);
    _p.readDir = _obtainRequestFactory(undefined, ['path', Directory, new Argument('entries'), _p._getItem]);
    _p.pathExists = _obtainRequestFactory(undefined, ['path', _p._pathExists]);

    _p.writeFile = _obtainRequestFactory('data', ['path', 'data', false, _p._writeFile]);
    _p.appendFile = _obtainRequestFactory('data', ['path', 'data', true, _p._writeFile]);
    _p.unlink = _obtainRequestFactory(undefined, ['path', File, _p._delete]);
    _p.rmDir = _obtainRequestFactory(undefined, ['path', Directory, _p._delete]);
    // `readBytes` is not implemented
    _p.mkDir = _obtainRequestFactory(undefined, ['path', _p._mkDir]);
    _p.ensureDir = _obtainRequestFactory(undefined, ['path', function(path) {
        try {
            return this._mkDir(path);
        }
        catch(error) {
            if(!(error instanceof IOEntryExistsError))
                throw error;
            return 0;
        }
    }]);

    return InMemory;
});

/**
 * Copyright (c) 2011, Lasse Fister lasse@graphicore.de, http://graphicore.de
 * 
 * You should have received a copy of the MIT License along with this program.
 * If not, see http://www.opensource.org/licenses/mit-license.php
 *
 * This pen draws path data to a SVG path element. It inherts from BasePen.
 * 
 * Noteable documents:
 *    http://www.w3.org/TR/SVG/paths.html#InterfaceSVGPathSegList
 *    http://www.w3.org/TR/SVG/paths.html#InterfaceSVGPathElement
 */

define(
    'ufojs/tools/pens/SVGPen',[
        'ufojs/main',
        'ufojs/errors',
        './BasePen'
    ],
    function(
        main,
        errors,
        BasePen
    )
{
    
    var enhance = main.enhance;
    
    /*constructor*/
    function SVGPen(path, glyphSet) {
        BasePen.call(this, glyphSet);
        this.path = path;
        this.segments = path.pathSegList;
    };
    
    /*inheritance*/
    SVGPen.prototype = new BasePen;

    /*definition*/
    enhance(SVGPen, {
        _commands:
        {
            'moveTo': 'createSVGPathSegMovetoAbs',
            'lineTo': 'createSVGPathSegLinetoAbs',
            'curveTo': 'createSVGPathSegCurvetoCubicAbs',
            'closePath': 'createSVGPathSegClosePath'
        },
        _addSegment: function(name, args)
        {
                //make a real array out of this
            var args = args ? [].slice.call(args) : [],
                // make a flat list out of the points, because the
                // SVG Path Commands work that way
                points = args.concat.apply([], args),
                cmd = this._commands[name],
                path = this.path,
                segment = path[cmd].apply(path, points);
            this.segments.appendItem(segment);
        },
        _moveTo: function(pt)
        {
            this._addSegment('moveTo', arguments);
        },
        _lineTo: function(pt)
        {
            this._addSegment('lineTo', arguments);
        },
        _curveToOne: function(pt1, pt2, pt3)
        {
            //notice that we change the order of the points
            this._addSegment('curveTo', [pt3, pt1, pt2]);
        },
        _closePath: function()
        {
            this._addSegment('closePath');
        },
        /**
         * Delete all segments from path
         */
        clear: function()
        {
            this.segments.clear();
        }
    });
    
    return SVGPen;
});

define('metapolator/ui/services/GlyphRendererAPI',[
    'metapolator/errors'
  , 'metapolator/project/ExportController'
  , 'ufojs/tools/pens/PointToSegmentPen'
  , 'ufojs/tools/pens/SVGPen'
], function(
    errors
  , ExportController
  , PointToSegmentPen
  , SVGPen
) {
    

    var KeyError = errors.Key
      , AssertionError = errors.Assertion
      , ValueError = errors.Value
      , svgns = 'http://www.w3.org/2000/svg'
      , xlinkns = 'http://www.w3.org/1999/xlink'
      , renderer =  {
            penstroke: ExportController.renderPenstrokeOutline
          , contour: ExportController.renderContour
        }
      , draw = ExportController.drawGlyphToPointPen
      ;

    function EnhancedSVGPen(data, glyphRendererAPI, path, glyphSet) {
        SVGPen.call(this, path, glyphSet);
        this._data = data;
        this._glyphRendererAPI = glyphRendererAPI;
    }
    var _pp = EnhancedSVGPen.prototype = Object.create(SVGPen.prototype);
    _pp.constructor = EnhancedSVGPen;

    _pp.addComponent = function(glyphName, transformation, kwargs /*optional, object*/) {
        var data = this._data
          , masterName = data.MOM.master.name
          , use = this._glyphRendererAPI.get(masterName, glyphName, 'use')
          , key = this._glyphRendererAPI.getKey(masterName, glyphName)
          ;
        use.setAttribute('transform', 'matrix(' +  transformation.join(',') + ')');
        data.components.push(key);
        data.svg.appendChild(use);
    };

    function GlyphRendererAPI(document, controller) {
        this._doc = document;
        this._controller = controller;
        this._glyphs = Object.create(null);
        this.__renderGlyph = this._renderGlyph.bind(this);
        // A small number in ms, to allow pending changes to come in.
        // However, we don't want to wait `long`, because this will be
        // perceived as pure waiting time and new events will reset the
        // timer.
        this._schedulingTimeout = 20;
        this._glyphIDPrefix = 'mp_glyph_';// globally unique

        this._glyphContainer = this._doc.createElementNS(svgns, 'defs');
        var svg = this._doc.createElementNS(svgns, 'svg');
        svg.style.display = 'none';
        svg.appendChild(this._glyphContainer);
        svg.appendChild(this._doc.createElementNS(svgns, 'g'));

        if(this._doc.body.firstChild)
            this._doc.body.insertBefore(svg, this._doc.body.firstChild);
        else
            this._doc.body.appendChild(svg);
    }

    var _p = GlyphRendererAPI.prototype;
    _p.constructor = GlyphRendererAPI;

    _p.getKey = function(masterName, glyphName) {
        return masterName + ' ' + glyphName;
    };

    /**
     * revoke from oldComponents what is not in data.components
     */
    _p._compareAndRevoke = function(oldComponents, newComponents) {
        var i,l,k,x, old = Object.create(null), revoke;
        // count all old references
        for(i=0,l=oldComponents.length;i<l;i++) {
            k = oldComponents[i];
            old[k] = (old[k] || 0) + 1;
        }
        // for each new reference we need to revoke one old reference less
        for(i=0,l=newComponents.length;i<l;i++) {
            k = oldComponents[i];
            x = old[k];
            // no need to revoke k
            if(x === undefined) continue;
            x -= 1;
            if(x === 0) {
                // no need to revoke k anymore
                old[k] = undefined;
                continue;
            }
            old[k] = x;
        }
        // revoke the keys left
        for(k in old)
            // the number of times left
            for(i=0,l=old[k];i<l;i++)
                this._revoke(k);
    };

    _p._renderGlyph = function(data) {
        /*global clearTimeout*/
        var path = this._doc.createElementNS(svgns, 'path')
          , svgPen = new SVGPen(path, {})
          , pen = new PointToSegmentPen(svgPen)
          , oldComponents = data.components
          , matrix
          , moveUp
          , fontinfo
          ;
        if(data.timeoutId) {
            clearTimeout(data.timeoutId);
            data.timeoutId = null;
        }
        while(data.svg.lastChild)
            data.svg.removeChild(data.svg.lastChild);
        data.components = [];
        draw(renderer, this._controller, data.MOM, pen);
        this._compareAndRevoke(oldComponents, data.components);

        // FIXME: * One day we have to subscribe to unitsPerEM AND
        //          descender for this!
        //        * I guess this is only valid for horizontal writing systems.
        //        * Maybe moveUp is rather === ascender?
        fontinfo = data.MOM.master.fontinfo;
        // ascender can be < fontinfo.unitsPerEM - fontinfo.descender, then
        // this solution is better. It seems OK to give the font enough
        // room down and maximal room upwards.
        moveUp = (fontinfo.unitsPerEM || 1000) + (fontinfo.descender || 0);
        matrix = [1, 0, 0, -1, 0, moveUp];
        data.svg.setAttribute('transform', 'matrix(' + matrix.join(',') +')');
        data.svg.appendChild(path);

        // update all viewboxes
        this._setSVGViewBox(data);
    };

    _p._scheduleRender = function(data) {
        /*global clearTimeout, setTimeout*/
        if(data.timeoutId)
            clearTimeout(data.timeoutId);
        data.timeoutID = setTimeout(this.__renderGlyph, this._schedulingTimeout, data);
    };

    _p._onGlyphChangeHandler = function(key, channelKey, eventData) {
        var data = this._glyphs[key];
        if(!data)
            throw new AssertionError('There\'s no data, so there must be no subscription!');
        this._scheduleRender(data);
    };

    _p._makeGlyphData = function(key) {
        var data
          , names = key.split(' ')
          , masterName = names[0]
          , glyphName = names[1]
          , selector = ['master#', masterName ,' ', 'glyph#',glyphName].join('')
          , glyph = this._controller.query(selector)
          ;
        if(!glyph)
            throw new KeyError('Not found, a glyph for: ' + selector);
        data = {
             referenceCount: 0
           , MOM: glyph
           , id: this._glyphIDPrefix + glyph.nodeID
           , subscriptionId: glyph.on('CPS-change', [this, '_onGlyphChangeHandler'], key)
           , svg: this._doc.createElementNS(svgns, 'g')
           , timeoutId: null
           , components: [] // keys of component glyphs, used with revoke
           , svgInstances: []
        };
        data.href = '#' + data.id;
        data.svg.setAttribute('id', data.id);
        this._glyphContainer.appendChild(data.svg);
        return data;
    };

    _p._getGlyphData = function(key) {
        var data = this._glyphs[key];
        if(!data) {
            data = this._glyphs[key] = this._makeGlyphData(key);
            this._scheduleRender(data);
        }
        return data;
    };

    /**
     * FIXME: MOM.master.fontinfo.unitsPerEm must be subscribed to in
     * the future, when we start changing it!
     *
     * updating "advanceWidth" is already covered by the normal redraw flow.
     *
     * For horizontal written languages:
     *      width is advanceWidth
     *      height is should the font height (fontinfo.unitsPerEm)
     */
    _p._setSVGViewBox = function(data, svg) {
        var svgs = svg ? [svg] : data.svgInstances
          , width = data.MOM.getComputedStyle().get('advanceWidth')
          , height = data.MOM.master.fontinfo.unitsPerEm || 1000
          , viewBox = [0, 0, width, height].join(' ')
          , i,l
          ;
        for(i=0,l=svgs.length;i<l;i++) {
            if(svgs[i].parentElement);
            svgs[i].setAttribute('viewBox', viewBox);
            // FIXME: file a bug for chromiuim:
            // For some silly reason this is not always enough for chrome
            // to resize the svg element :-/ especially when the viewbox
            // is getting smaller than some magic amount, chrome sometimes
            // just stops synchronizing the real svg width.
            // This triggers the width update, however, it takes away the
            // possibility to change "display" via CSS
            // svgs[i].setAttribute('width', 0);
            // NOTE: this is also not needed with firefox
            // Filed a bug:
            // https://code.google.com/p/chromium/issues/detail?id=462107
            svgs[i].style.display = svgs[i].style.display === 'inline-block'
                   ? 'inline'
                   : 'inline-block'
                   ;
        }
    };

    _p._createDisplayElement = function(data, type) {
        var use = this._doc.createElementNS(svgns, 'use')
          , svg
          , viewBox
          , advanceWidth
          , unitsPerEm
          ;
        use.setAttributeNS(xlinkns, 'href', data.href);

        if(type === 'use')
            return use;
        else if(type && type !== 'svg')
            throw new ValueError('Type must be "use" or "svg" or undefinded: ' + type);
        svg = this._doc.createElementNS(svgns, 'svg');
        // This can be set via css as well, but since it is the only
        // choice that really makes sense, we may be happy for ever when
        // setting it here
        svg.setAttribute('overflow', 'visible');
        this._setSVGViewBox(data, svg);
        data.svgInstances.push(svg);
        svg.appendChild(use);
        return svg;
    };

    _p._get = function(key, type) {
        var data = this._getGlyphData(key);
        data.referenceCount += 1;
        return this._createDisplayElement(data, type);
    };

    _p.get = function(masterName, glyphName, type) {
        return this._get(this.getKey(masterName, glyphName), type);
    };

    _p._revoke = function(key) {
        var data = this._glyphs[key]
          , components
          , i, l
          ;
        if(!data)
            return;
        data.referenceCount -= 1;
        if(data.referenceCount > 0)
            return data.referenceCount;
        delete this._glyphs[key];
        if(data.timeoutId)
            clearTimeout(data.timeoutId);
        // unsubscribe
        data.glyph.off(data.subscriptionId);
        // delete the defs item
        data.svg.parentElement.removeChild(data.svg);
        components = data.components;
        for(i=0,l=components.length;i<l;i++)
            this._revoke(components[i]);
    };

    _p.revoke = function(masterName, glyphName) {
        return this._revoke(this.getKey(masterName, glyphName));
    };

    return GlyphRendererAPI;
});

// This file is meant to export a stand alone version of the metapolator,
// model and it's apis, that can be included as almost a single file.

require([
    'webAPI/document'
  , 'metapolator/project/MetapolatorProject'
  , 'ufojs/tools/io/staticBrowserREST'
  , 'metapolator/io/InMemory'
  , 'metapolator/ui/services/GlyphRendererAPI'
  , 'metapolator/project/parameters/registry'
  , 'metapolator/models/CPS/elements/ParameterValue'
  , 'metapolator/models/CPS/elements/Parameter'
  , 'metapolator/models/CPS/elements/ParameterDict'
  , 'metapolator/models/CPS/elements/Rule'
  , 'metapolator/models/CPS/parsing/parseSelectorList'
],
function (
    document
  , MetapolatorProject
  , ioREST
  , InMemory
  , GlyphRendererAPI
  , parameterRegistry
  , ParameterValue
  , Parameter
  , ParameterDict
  , Rule
  , parseSelectorList
) {
    
    /*global setTimeout window*/
    document.body.classList.add('dependencies-ready');
    var exports = {};
    function metapolatorReady(callback) {
        // make sure that the execution of a callback is asynchronous
        setTimeout(callback, 0, exports);
    }


    // This pattern is used by google analytics, for example, to execute
    // api calls "before" the api is available. The calling code does:
    // if(!window.metapolatorReady)
    //     window.metapolatorReady = [];
    // window.metapolatorReady.push(callback) // <= could be an array or our api
    var callbacks;
    if(window.metapolatorReady instanceof Array)
        callbacks = window.metapolatorReady;
    // call it like this: window.metapolatorReady.push(myCallback)
    window.metapolatorReady = {push: metapolatorReady};
    // if there are already registered callbacks
    if(callbacks) callbacks.map(metapolatorReady);



    // export the modules that will be needed
    exports.initProject = function(projectPath) {
        // InMemory is its own event emitter
        var fsEvents, io, promise;
        io = fsEvents = new InMemory();
        io.mkDir(false, 'project');
        // copy the project into memory
        promise = ioREST.copyRecursive(true, projectPath, io, 'project');
        return promise.then(function(){
            var project, glyphRendererAPI;
            project = new MetapolatorProject(io, 'project');
            project.load();
            // load all masters, because right now it is very confusing
            // when some masters are missing from the MOM
            project.masters.forEach(project.open, project);
            glyphRendererAPI = new GlyphRendererAPI(document, project.controller);
            glyphRendererAPI = glyphRendererAPI;

            // initialized/stateful
            return {
                 project: project
               , glyphRendererAPI: glyphRendererAPI
               , controller: project.controller // shortcut
            };
        });
    };

    // TODO: let this grow into a useful collection of tools, then make
    // a module out of it.
    // It's hard to know in advance what's going to be needed
    exports.cpsAPITools = {
        /**
         * Set `value` to the parameter `name` of `parameterDict`.
         *
         * Arguments:
         * parameterDict: an instance of ParameterDict as returned
         *                by Rule.parameters
         * name: a string with the parameter name
         * value: a string (of cps-formulae-language)
         *
         * return value: nothing.
         * raises: potentially a lot.
         *
         *  Actually this depends on which type is registered for `name`
         *   but at the time of this writing there is only cps-formulae-language.
         *   There are, however, parameters that check their return type,
         *   after evaluation of the cps-formulae-language.
         */
        setParameter: function setParameter(parameterDict, name, value) {
            var _value = new ParameterValue([value], [])
                , parameter
                , factory = parameterRegistry.getFactory(name)
                ;
            _value.initializeTypeFactory(name.name, factory);
            parameter = new Parameter({name:name}, _value);
            parameterDict.setParameter(parameter);
        },
        addNewRule: function addNewRule(parameterCollection, index, selectorListString) {
            var source = 'generated'
              , selectorList = parseSelectorList.fromString(selectorListString)
              , parameterDict = new ParameterDict([], source, 0)
              , rule = new Rule(selectorList, parameterDict, source, 0)
              ;
            // returns the actual index at which the rule was created
            return parameterCollection.splice(index, 0, rule)[0];
        }
    };
});

define("metapolatorStandAlone", function(){});

requirejs.config({
    baseUrl: 'lib'
  , paths: {
        'require/domReady': 'bower_components/requirejs-domready/domReady'
      , 'require/text': 'bower_components/requirejs-text/text'
      , 'metapolator': './'
      , 'gonzales': 'npm_converted/gonzales/lib'
      , 'complex':  'npm_converted/immutable-complex/lib'
      , 'util-logging': 'npm_converted/util-logging/lib'
      , 'util': 'npm_converted/util'
      , 'path': 'npm_converted/path/path'
      , 'inherits': 'npm_converted/inherits/inherits'
      , 'angular': 'bower_components/angular/angular'
      , 'obtain': 'obtainJS/lib'
      , 'ufojs': 'ufoJS/lib'
      , 'yaml': 'bower_components/js-yaml/dist/js-yaml.min'
         // code mirror uses AMD define style if available :-)
      , 'codemirror': 'bower_components/codemirror'
      , 'ui-codemirror': 'bower_components/angular-ui-codemirror/ui-codemirror'
      , 'es6/Reflect': 'bower_components/harmony-reflect/reflect'
      , 'socketio': '../socket.io/socket.io'
      , 'EventEmitter': 'bower_components/event-emitter.js/dist/event-emitter'
    }
  // exclude on build
  , excludeShallow: [
        // the optimizer can't read es6 generators
        // NOTE: for dependency tracing the genereated es5 version is used
        // by the optimizer. The feature detection below then swaps the path
        // used to load ExportController when the browser executes this.
        'metapolator/project/ExportController'
        // see the es6/Proxy module, we load this only when needed
      , 'es6/Reflect'
    ]
  , shim: {
        angular: {
            exports: 'angular'
        }
      , yaml: {
            exports: 'jsyaml'
        }
      , 'es6/Reflect': {
            exports: 'Reflect'
        }
        //These script dependencies should be loaded before loading
        //ui-codemirror
      , 'ui-codemirror': {
            deps: ['angular', 'GlobalCodeMirror']
        }
      , 'socketio': {
            exports: 'io'
        }
    }
});

// feature detection for generators
try {
    /*jshint evil:true*/
    eval("(function *(){})()");
    requirejs.config({
    paths: {
        'metapolator/project/ExportController': 'project/ExportController.es6'
    }});
} catch(err) {
    console.info("No generators, falling back.");
}
;
define("browserConfig", function(){});

